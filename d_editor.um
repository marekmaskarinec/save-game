import (
        "std.um"; "rect.um"; "window.um"; "th.um"; "image.um"; "canvas.um"; "input.um"; "font.um"; "csv.um"
        "utf8.um"; "map.um"; 
        "d_world.um"; "d_util.um"; "d_background.um"; "d_colors.um"; "d_game.um"; "d_fps.um"
)

type (
        Window = struct {
                rect: rect.Rect
                showDecorations: bool
                closing: bool
                closed: bool
        }
)

const (
        stateEditing = 0
        statePlaying = 1

        fileScene = "data/sc00_sky.csv"
)

var (
        state: int

        uiLeftMouseDown: bool
        uiPrevMousePos: th.Vf2
        uiTileset: image.Image
        uiTrayIconTileset: image.Image
        uiWindows: [4]Window
        uiRelocatingPlayer: bool
        uiProcessWindowId: int          // window currently processing (drawing)
        uiFocusWindowId: int            // window currently focused on (mouse over)
        uiDraggingWindowId: int         // window currently dragging
        uiMainFont: font.Cached

        worldViewOfsX: int
        worldViewOfsY: int
        worldSelTileX: int
        worldSelTileY: int
        worldSelLayer: int
        worldShowCurrentLayer: bool
        world: d_world.World
)

fn isLeftMouseReleased(): bool {
        return !input.isPressed(input.mouse1) && uiLeftMouseDown
}

fn uiSelTile(x, y: int) {
        uiTileset.crop(th.Vf2{x/4.0, y/4.0}, th.Vf2{x/4.0+1/4.0, y/4.0+1/4.0})
}

fn uiSelTrayTile(x, y: int) {
        uiTrayIconTileset.crop(th.Vf2{x/4.0, y/4.0}, th.Vf2{x/4.0+1/4.0, y/4.0+1/4.0})
}

fn actField() {

        if uiFocusWindowId == 0 && (input.isPressed(input.mouse1) || input.isPressed(input.mouse3)) {
                pos := input.getMousePos()

                tx := trunc(pos.x / 32) + worldViewOfsX
                ty := trunc(pos.y / 32) + worldViewOfsY

                painting := input.isPressed(input.mouse1)
                
                if !uiRelocatingPlayer {
                        if painting {
                                world.setTile(worldSelLayer, tx, ty, d_world.pos2Tile(worldSelTileX, worldSelTileY))
                        } else {
                                world.setTile(worldSelLayer, tx, ty, 0)
                        }
                } else {
                        world.playerSpawnPos = th.Vf2{tx, ty}
                }
        }

        if uiFocusWindowId == 0 && isLeftMouseReleased() {
                uiRelocatingPlayer = false
        }
}

fn drawGridEditor() {
        // draw grid
        nx := 640/16
        ny := 480/16

        for cx := 0; cx < nx; cx++ {
                x := cx * 32
                canvas.drawRect(0xFFFFFF11, rect.Rect{x, 0, 1, 480})
        }
        for cy := 0; cy < ny; cy++ {
                y := cy * 32
                canvas.drawRect(0xFFFFFF11, rect.Rect{0, y, 640, 1})        
        }

 
        // draw world
        if worldShowCurrentLayer {
                world.drawLayer(th.Vf2{worldViewOfsX * 32, worldViewOfsY * 32}, worldSelLayer)
        } else {
                world.draw(th.Vf2{worldViewOfsX * 32, worldViewOfsY * 32})
        }


        // draw tile highlight
        if uiFocusWindowId == 0 {
                pos := input.getMousePos()
                tx := trunc(pos.x / 32) 
                ty := trunc(pos.y / 32)
                canvas.drawRect(0x00FF0011, rect.Rect{tx*32, ty*32, 32, 32}) 
        }

        uiSelTrayTile(2, 0)
        uiTrayIconTileset.draw(th.Transform{p: world.playerSpawnPos.add(th.Vf2{-worldViewOfsX, -worldViewOfsY}).mul(th.Vf2{32.0, 32.0}), s: th.Vf2{1, 1}}, th.white)
}

fn putBtnBase(text: str, r: rect.Rect, held: bool): bool {
        // -- measure
        txtSize := d_util.measureText(uiMainFont, text)
        // center the text
        txtPos := th.Vf2{trunc(r.x+(r.w-txtSize.x)/2), trunc(r.y+(r.h-txtSize.y)/2)}
        color := d_colors.cPrimary 
        hovered := d_util.isMouseInRect(r) && uiProcessWindowId == uiFocusWindowId
        pressed := hovered && input.isPressed(input.mouse1)
        nudged  := hovered && input.isJustPressed(input.mouse1)
        if pressed || held {
                color = 0xAD3E3EFF;
        }
        if hovered {
                color += 0x11111100
        }

        // -- draw
        r1 := r
        r1.w -= 1
        r1.h -= 1
        r2 := r1
        r2.x += 1
        r2.y += 1
        r.x += 1
        r.y += 1
        r.w -= 2
        r.h -= 2
        r3 := r
        r.w -= 1
        r.h -= 1

        
        if pressed || held {
                tmp := r1
                r1 = r2
                r2 = tmp
        }
        canvas.drawRect(0xD37A70FF, r1) 
        canvas.drawRect(0x7C0000FF, r2) 
        canvas.drawRect(0xAD3E3EFF, r3) 
        canvas.drawRect(color, r) 
        uiMainFont.draw(text, txtPos, d_colors.cText, 3.2)
        return nudged
}

fn putBtn(text: str, r: rect.Rect): bool {
        return putBtnBase(text, r, false)
}

fn saveMap() { 
        file := std.fopen(fileScene, "w")
        if file == null {
                error("Can't save the scene")
        }
        dataStr := world.save()
        data := make([]uint8, 0)
        for c in dataStr {
                data = append(data, uint8(c))
        }
        std.fwrite(file, data)
        std.fclose(file)
}

fn loadMap() {
        file := std.fopen(fileScene, "r")
        if file == null {
                error("Can't load the scene")
        }
        std.fseek(file, 0, std.seekEnd)
        datasiz := std.ftell(file)
        std.fseek(file, 0, std.seekBegin)
        buffer := make([]uint8, datasiz)
        std.fread(file, buffer)
        data := ""
        for b in buffer {
                data += char(b)
        }
        
        world.load(data)
}

fn drawLayerIcon(x, y: real) {
        fills := [3]bool{worldSelLayer == -1, worldSelLayer == 0, worldSelLayer == 1}

        // NOTE: If we choose to show all layers, the icon will show all boxes filled in
        if worldShowCurrentLayer == false {
                fills = [3]bool{true, true, true}
        }

        x += 26

        for l in fills {
                rec := rect.Rect{x-20, y, 20, 12}
                x -= 2
                y += 4

                if l {
                        canvas.drawRect(0xf0b5afFF, rec)
                        d_util.drawRectLines(0xFFFFFFFF, rec)
                } else {
                        canvas.drawRect(d_colors.cPrimary, rec)
                        d_util.drawRectLines(0xFFFFFFFF, rec)
                }
        }
}

//
// putTrayBtn(
//      pos:    Position of the button
//      ix, iy: Position of the icon from the icon set 
//      active: True if you want a "button pressed" appearance
//              False if you want a "button released" appearance 
// ): True if it was activated
//
fn putTrayBtn(pos: th.Vf2, ix, iy: int, active: bool): bool {
        trayBtnRect := rect.Rect{pos.x, pos.y, 32, 32}

        if active || (isLeftMouseReleased() || input.isPressed(input.mouse1)) && (d_util.isMouseInRect(trayBtnRect) && uiFocusWindowId == uiProcessWindowId) {
                uiSelTrayTile(1, 0)
                uiTrayIconTileset.draw(th.Transform{p: pos, s: th.Vf2{1, 1}})
                uiSelTrayTile(ix, iy)
                uiTrayIconTileset.draw(th.Transform{p: pos, s: th.Vf2{1, 1}}, 0x999999FF)
        } else {
                uiSelTrayTile(0, 0)
                uiTrayIconTileset.draw(th.Transform{p: pos, s: th.Vf2{1, 1}})
                uiSelTrayTile(ix, iy)
                uiTrayIconTileset.draw(th.Transform{p: pos, s: th.Vf2{1, 1}})
        }

        return d_util.isMouseInRect(trayBtnRect) && isLeftMouseReleased() && uiFocusWindowId == uiProcessWindowId
}

fn drawBar() {

        putButton := fn(s: str, r: ^rect.Rect, w: int): bool {
                pressed := putBtn(s, d_util.rectChopRight(r, w))
                d_util.rectChopRight(r, 1) // border
                return pressed
        }

        putSelect := fn(s: str, r: ^rect.Rect, w: int, check: bool): bool {
                pressed := putBtnBase(s, d_util.rectChopRight(r, w), check)
                d_util.rectChopRight(r, 1) // border
                return pressed
        }
        
        canvas.drawRect(d_colors.cBack, uiWindows[1].rect)
        area := uiWindows[1].rect
        
        if putTrayBtn(th.Vf2{area.x, area.y}, 1, 1, false) {
                d_game.world = world
                d_game.chara = d_game.Character{rect: rect.Rect{world.playerSpawnPos.x*32, world.playerSpawnPos.y*32, 32, 32}}
                state = statePlaying
        }
        if putTrayBtn(th.Vf2{area.x+32, area.y}, 0, 1, !uiWindows[2].closed) {
                uiWindows[2].closed = !uiWindows[2].closed
        }
        if putTrayBtn(th.Vf2{area.x+64, area.y}, 3, 1, !uiWindows[3].closed) {
                uiWindows[3].closed = !uiWindows[3].closed
        }




        if putButton("Save", &area, 60) {
                saveMap()
        }
        if putButton("Load", &area, 60) {
                loadMap()
        }
        if putSelect("BG", &area, 30, worldSelLayer == -1) {
                worldSelLayer = -1
        }
        if putSelect("MG", &area, 30, worldSelLayer == 0) {
                worldSelLayer = 0
        }
        if putSelect("FG", &area, 30, worldSelLayer == 1) {
                worldSelLayer = 1
        }

        if putButton(" ", &area, 40) {
                worldShowCurrentLayer = !worldShowCurrentLayer
        }
        // FIXME: Hack to get the position of the previous butotn
        drawLayerIcon(area.x + area.w+8, area.y+6)
}

fn drawPicker() {
        canvas.drawRect(d_colors.cBack, uiWindows[2].rect)

        // selected tile
        tsw := 4
        tsh := 4
        
        for tx := 0; tx < tsw; tx++ {
                for ty := 0; ty < tsh; ty++ {
                        x := uiWindows[2].rect.x + 2 + tx * 36
                        y := uiWindows[2].rect.y + 2 + ty * 36
                                
                        rec := rect.Rect{x, y, 32, 32}
                        world.tileset.crop(th.Vf2{tx/real(tsw), ty/real(tsh)}, th.Vf2{tx/real(tsw)+1/real(tsw), ty/real(tsh)+1/real(tsh)})
                        world.tileset.draw(d_util.posTrans(x, y))
                        
                        if (worldSelTileX == tx) && (worldSelTileY == ty) {
                                canvas.drawRect(0x00FF0033, rec)
                        }

                        if uiFocusWindowId == 2 && d_util.isMouseInRect(rec) && input.isJustPressed(input.mouse1) { 
                                worldSelTileX = tx
                                worldSelTileY = ty
                        }
                }
        }

        world.tileset.crop(th.Vf2{0, 0}, th.Vf2{1, 1})
}

fn drawPlayerPlacer() {
        canvas.drawRect(d_colors.cBack, uiWindows[3].rect)
        uiMainFont.draw("Player at x"+std.itoa(trunc(world.playerSpawnPos.x))+" y"+std.itoa(trunc(world.playerSpawnPos.y)), th.Vf2{uiWindows[3].rect.x+10, uiWindows[3].rect.y+10}, d_colors.cText, 3.2);
        if !uiRelocatingPlayer {
                uiRelocatingPlayer = putBtn("Relocate", rect.Rect{uiWindows[3].rect.x + 10, uiWindows[3].rect.y + 40, uiWindows[3].rect.w - 20, 30})
        } else {
                uiRelocatingPlayer = !putBtnBase("Relocate", rect.Rect{uiWindows[3].rect.x + 10, uiWindows[3].rect.y + 40, uiWindows[3].rect.w - 20, 30}, true)
                uiMainFont.draw("Click on the grid\nTo place player", th.Vf2{uiWindows[3].rect.x+10, uiWindows[3].rect.y+80}, d_colors.cText, 3.2);
        }
}

fn getWindowOuterRect(win: int): rect.Rect {
        r := uiWindows[win].rect
        r.y -= 16
        r.h += 16
        return r
}

fn getWindowTitlebarRect(win: int): rect.Rect {
        outerFrame := getWindowOuterRect(win)
        outerFrame.x += 16
        outerFrame.w -= 16
        outerFrame.h = 16
        return outerFrame
}

fn getWindowCloseRect(win: int): rect.Rect {
        outerFrame := getWindowOuterRect(win)
        outerFrame.w = 16
        outerFrame.h = 16
        return outerFrame
}

fn setupUiWindows() {
        uiWindows[0].rect = rect.Rect{0, 0, 640, 480}
        uiWindows[1].rect = rect.Rect{0, 480-32, 640, 32}        
        uiWindows[2].rect = rect.Rect{480, 20, 146, 408}
        uiWindows[2].showDecorations = true
        uiWindows[3].rect = rect.Rect{20, 20, 160, 120}
        uiWindows[3].showDecorations = true
}

fn getMouseDelta(): th.Vf2 {
        delta := input.getMousePos()
        
        delta.x -= uiPrevMousePos.x
        delta.y -= uiPrevMousePos.y
        return delta
}

fn handleUiWindows() {
        // -- handle window dragging
        // no window is being dragged if we aren't holding the button
        if (!input.isPressed(input.mouse1)) {
                uiDraggingWindowId = -1
        }

        if (uiDraggingWindowId > 0) {
                mouseDelta := getMouseDelta()
                uiWindows[uiDraggingWindowId].rect.x += mouseDelta.x
                uiWindows[uiDraggingWindowId].rect.y += mouseDelta.y
        }

        // -- handle mouse events on windows
        for i := 0; i < 4; i++ {
                if uiWindows[i].rect.x < 0 {
                        uiWindows[i].rect.x = 0
                }
                if uiWindows[i].rect.y < 8 {
                        uiWindows[i].rect.y = 8
                }
                if uiWindows[i].rect.x > 600 {
                        uiWindows[i].rect.x = 600
                }
                if uiWindows[i].rect.y > 480 {
                        uiWindows[i].rect.y = 480
                }
                
        
                if uiWindows[i].closed {
                        continue
                }
                if isLeftMouseReleased() && uiWindows[i].closing {
                        uiWindows[i].closed = true
                }
                uiWindows[i].closing = false
                if d_util.isMouseInRect(uiWindows[i].rect) {
                        uiFocusWindowId = i
                } 
        }
        
        for i := 3; i >= 0; i-- {
                if (uiWindows[i].closed || !uiWindows[i].showDecorations) {
                        continue
                }
                outerRect := getWindowOuterRect(i)
                titlebarRect := getWindowTitlebarRect(i)
                closeRect := getWindowCloseRect(i)

                if d_util.isMouseInRect(outerRect) && uiFocusWindowId < i {
                        uiFocusWindowId = -1
                        if input.isJustPressed(input.mouse1) && d_util.isMouseInRect(titlebarRect) {
                                uiDraggingWindowId = i
                        }
                        if input.isPressed(input.mouse1) && d_util.isMouseInRect(closeRect) {
                                uiWindows[i].closing = true
                        }
                        break
                }
        }
        
        if (uiDraggingWindowId > 0) {
                uiFocusWindowId = -1
        }
}
fn drawDebugUiWindows() {
        for i := 0; i < 4; i++ {
                color := 0x0000FFFF
                if i == uiFocusWindowId {
                        color = 0x00FF00FF
                }               
                d_util.drawRectLines(color, uiWindows[i].rect)
                d_util.drawRectLines(color, getWindowOuterRect(i))
        }
}

fn drawUiDecorations(winId: int, title: str) {
        if uiWindows[winId].showDecorations == false {
                return
        }
        outerRect := getWindowOuterRect(winId)
        closeBtnRect := getWindowCloseRect(winId)
        for x := 16.0; x < outerRect.w; x += 16 {
                if x < 16 {
                        uiSelTile(1, 0) 
                } else {
                        uiSelTile(2, 0) 
                } 
                if x + 16 > outerRect.w {
                        uiSelTile(3, 0) /* select win trail */
                        x = outerRect.w - 16
                }
                uiTileset.draw(th.Transform{p: th.Vf2{outerRect.x+x, outerRect.y}, s: th.Vf2{1, 1}})
        }

        if uiWindows[winId].closing {
                uiSelTile(0, 1) /* select close btn pressed */
        } else {
                uiSelTile(0, 0) /* select close btn */
        }
        uiTileset.draw(th.Transform{p: th.Vf2{outerRect.x, outerRect.y}, s: th.Vf2{1, 1}})

        uiMainFont.draw(title, th.Vf2{outerRect.x+18, outerRect.y-1}, d_colors.cText, 3.2)
        uiMainFont.draw(title, th.Vf2{outerRect.x+18+1, outerRect.y-1}, d_colors.cText, 3.2)


        borderRect := outerRect
        borderRect.x -= 1
        borderRect.y -= 1
        borderRect.w += 2
        borderRect.h += 2
        d_util.drawRectLines(0x000000FF, borderRect)
}

fn drawWindows() {
        for i := 0; i < 4; i++ {
                if (uiWindows[i].closed) {
                        continue
                }
                uiProcessWindowId = i
                switch i {
                case 0: drawUiDecorations(i, "Tile window (why are you even able to read this?")
                case 1: drawUiDecorations(i, "Controls toolbar")
                case 2: drawUiDecorations(i, "Tile picker")
                case 3: drawUiDecorations(i, "Player placer")
                default: drawUiDecorations(i, " ")
                }
                switch i {
                case 0: drawGridEditor()
                case 1: drawBar()
                case 2: drawPicker()
                case 3: drawPlayerPlacer()
                default:
                }
        }
}

fn main*() {
        window.setup("title", 640, 480)
        world.tileset = image.load("data/ts00_sky.png")
        uiTileset = image.load("data/ts01_ui.png")
        uiTrayIconTileset = image.load("data/ts02_trayicons.png")

        screen := rect.mk(0, 0, 640, 480)
        uiMainFont = font.mkCached(font.load("data/font_mono.ttf"), 16)
        d_background.init()
        setupUiWindows()
        uiPrevMousePos = input.getMousePos()
        for window.cycle(screen) {
                d_fps.update()
                d_background.draw(screen)
                switch state {
                case stateEditing:
                        handleUiWindows()

                        if input.isJustPressed(input.key_up) {
                                worldViewOfsY -= 1
                        }
                        if input.isJustPressed(input.key_down) {
                                worldViewOfsY += 1
                        }
                        if input.isJustPressed(input.key_left) {
                                worldViewOfsX -= 1
                        }
                        if input.isJustPressed(input.key_right) {
                                worldViewOfsX += 1
                        }

                        actField()

                        drawWindows()

                        if uiRelocatingPlayer {
                                uiSelTrayTile(2, 0)
                                uiTrayIconTileset.draw(th.Transform{p: input.getMousePos(), s: th.Vf2{1, 1}}, th.white)
                        }

                case statePlaying:
                        d_game.draw()
                        uiProcessWindowId = uiFocusWindowId
                        if putTrayBtn(th.Vf2{0, 480-32}, 1, 1, true) {
                                state = stateEditing
                        }
                }

                uiPrevMousePos = input.getMousePos()
                uiLeftMouseDown = input.isPressed(input.mouse1)
                uiMainFont.draw(std.itoa(trunc(d_fps.getFps()))+"fps", th.Vf2{0, 0}, d_colors.cText, 3.2) 
        }

}

