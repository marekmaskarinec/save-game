import ("std.um"; "rect.um"; "window.um"; "th.um"; "image.um"; "canvas.um"; "input.um"; "font.um"; "csv.um"
        "utf8.um"; "map.um"; 
        "d_world.um"; "d_util.um"; "d_background.um")


var (
        uiWindows: [3]rect.Rect
        uiFocusWindow: int
        mainFont: font.Cached


        worldViewOfsX: int
        worldViewOfsY: int
        worldSelTileX: int
        worldSelTileY: int
        worldSelLayer: int
        worldShowCurrentLayer: bool
        world: d_world.World
)



fn actField() {

        if uiFocusWindow == 0 && (input.isPressed(input.mouse1) || input.isPressed(input.mouse3)) {
                pos := input.getMousePos()

                tx := trunc(pos.x / 16) + worldViewOfsX
                ty := trunc(pos.y / 16) + worldViewOfsY

                painting := input.isPressed(input.mouse1)

                if painting {
                        world.setTile(worldSelLayer, tx, ty, d_world.pos2Tile(worldSelTileX, worldSelTileY))
                } else {
                        world.setTile(worldSelLayer, tx, ty, 0)
                }
        }
}

fn drawGridEditor() {
        // draw grid
        nx := 320/16
        ny := 240/16

        for cx := 0; cx < nx; cx++ {
                x := cx * 16
                canvas.drawRect(0xFFFFFF11, rect.Rect{x, 0, 1, 240})
        }
        for cy := 0; cy < ny; cy++ {
                y := cy * 16
                canvas.drawRect(0xFFFFFF11, rect.Rect{0, y, 320, 1})        
        }

 
        // draw world
        if worldShowCurrentLayer {
                world.drawLayer(th.Vf2{worldViewOfsX * 16, worldViewOfsY * 16}, worldSelLayer)
        } else {
                world.draw(th.Vf2{worldViewOfsX * 16, worldViewOfsY * 16})
        }

        // draw tile highlight
        if uiFocusWindow == 0 {
                pos := input.getMousePos()
                tx := trunc(pos.x / 16) 
                ty := trunc(pos.y / 16)
                canvas.drawRect(0x00FF0011, rect.Rect{tx*16, ty*16, 16, 16}) 
        }
}

fn putBtnBase(text: str, r: rect.Rect, colorMod: uint32): bool {
        // -- measure
        txtSize := d_util.measureText(mainFont, text)
        // center the text
        txtPos := th.Vf2{r.x+(r.w-txtSize.x)/2, r.y+(r.h-txtSize.y)/2}
        color := 0x224455FF + colorMod
        hovered := d_util.isMouseInRect(r)
        nudged  := hovered && input.isJustPressed(input.mouse1)
        if (hovered) {
                color += 0x11111100
        }

        // -- draw
        canvas.drawRect(color, r); 
        mainFont.draw(text, txtPos, 0xFFFFFFFF, 1.6)
        return nudged
}

fn putBtn(text: str, r: rect.Rect): bool {

        hovered := d_util.isMouseInRect(r)
        pressed := hovered && input.isPressed(input.mouse1)
        color := 0
        if (hovered) {
                color += 0x11111100
        }

        return putBtnBase(text, r, color)
}

fn saveMap() { 
        file := std.fopen("data/sc00_sky.csv", "w")
        if file == null {
                error("Can't save the scene")
        }
        dataStr := world.save()
        data := make([]uint8, 0)
        for c in dataStr {
                data = append(data, uint8(c))
        }
        std.fwrite(file, data)
        std.fclose(file)
}

fn loadMap() {
        file := std.fopen("data/sc00_sky.csv", "r")
        if file == null {
                error("Can't load the scene")
        }
        std.fseek(file, 0, std.seekEnd)
        datasiz := std.ftell(file)
        std.fseek(file, 0, std.seekBegin)
        buffer := make([]uint8, datasiz)
        std.fread(file, buffer)
        data := ""
        for b in buffer {
                data += char(b)
        }
        
        world.load(data)
}

fn drawBar() {
        canvas.drawRect(0x001122FF, uiWindows[1])
        mx := uiWindows[1].x+3
        my := uiWindows[1].y+3
        mainFont.draw("x: " + std.itoa(worldViewOfsX) + " y: " + std.itoa(worldViewOfsY), th.Vf2{mx, my}, 0xFFFFFFFF, 1.6);
        
        area := uiWindows[1]

        putButton := fn(s: str, r: ^rect.Rect, w: int): bool {
                pressed := putBtn(s, d_util.rectChopRight(r, w))
                d_util.rectChopRight(r, 1) // border
                return pressed
        }

        putSelect := fn(s: str, r: ^rect.Rect, w: int, check: bool): bool {
                var colorMod : uint32 = 0
                if check {
                        colorMod = 0x00009900
                }
                pressed := putBtnBase(s, d_util.rectChopRight(r, w), colorMod)
                d_util.rectChopRight(r, 1) // border
                return pressed
        }

        if putButton("Save", &area, 30) {
                saveMap()
        }
        if putButton("Load", &area, 30) {
                loadMap()
        }
        if putSelect("FG", &area, 15, worldSelLayer == 1) {
                worldSelLayer = 1
        }
        if putSelect("MG", &area, 15, worldSelLayer == 0) {
                worldSelLayer = 0
        }
        if putSelect("BG", &area, 15, worldSelLayer == -1) {
                worldSelLayer = -1
        }
        
        var switchText: str
        if (worldShowCurrentLayer) {
                switchText = "CUR"
        } else {
                switchText = "ALL"
        }

        if putButton(switchText, &area, 20) {
                worldShowCurrentLayer = !worldShowCurrentLayer
        }
}

fn drawPicker() {
        canvas.drawRect(0x001122FF, uiWindows[2])

        // selected tile
        tsw := 4
        tsh := 4
        
        for tx := 0; tx < tsw; tx++ {
                for ty := 0; ty < tsh; ty++ {
                        x := uiWindows[2].x + 2 + tx * 18
                        y := uiWindows[2].y + 10 + ty * 18
                                
                        rec := rect.Rect{x, y, 16, 16}
                        world.tileset.crop(th.Vf2{tx/real(tsw), ty/real(tsh)}, th.Vf2{tx/real(tsw)+1/real(tsw), ty/real(tsh)+1/real(tsh)})
                        world.tileset.draw(d_util.posTrans(x, y))
                        
                        if (worldSelTileX == tx) && (worldSelTileY == ty) {
                                canvas.drawRect(0x00FF0033, rect.Rect{x, y, 16, 16});
                        }

                        if uiFocusWindow == 2 && d_util.isMouseInRect(rec) && input.isJustPressed(input.mouse1) { 
                                worldSelTileX = tx
                                worldSelTileY = ty
                        }
                }
        }

        world.tileset.crop(th.Vf2{0, 0}, th.Vf2{1, 1})
}

fn handleUiWindows() {
        uiWindows[0] = rect.Rect{0, 0, 320, 240}        
        uiWindows[1] = rect.Rect{0, 240-16, 320, 16}        
        uiWindows[2] = rect.Rect{240, 10, 72, 240-36}
        for i := 0; i < 3; i++ {
                if d_util.isMouseInRect(uiWindows[i]) {
                        uiFocusWindow = i
                }
        }
}

fn drawDebugUiWindows() {
        for i := 0; i < 3; i++ {
                color := 0x0000FFFF;
                if i == uiFocusWindow {
                        color = 0x00FF00FF;
                }               
                d_util.drawRectLines(color, uiWindows[i]);
        }
}

fn main() {
        window.setup("title", 640, 480)
        world.tileset = image.load("data/ts00_sky.png")


        screen := rect.mk(0, 0, 320, 240)
        mainFont = font.mkCached(font.load("data/font_mono.ttf"), 16);
        d_background.init()
        for window.cycle(screen) {
                handleUiWindows()

                if input.isJustPressed(input.key_up) {
                        worldViewOfsY -= 1;
                }
                if input.isJustPressed(input.key_down) {
                        worldViewOfsY += 1;
                }
                if input.isJustPressed(input.key_left) {
                        worldViewOfsX -= 1;
                }
                if input.isJustPressed(input.key_right) {
                        worldViewOfsX += 1;
                }

                actField()


                d_background.draw(screen)
                drawGridEditor()
                drawBar()
                drawPicker()
                //drawDebugUiWindows()
        }
}

