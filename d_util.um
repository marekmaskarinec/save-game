import (
        "th.um"; "font.um"; "rect.um"; "input.um"; "canvas.um"; "utf8.um"
)

fn posTrans*(x, y: th.fu): th.Transform {
        return th.Transform{p: th.Vf2{x, y}, s: th.Vf2{1, 1}}
}

fn isMouseInRect*(r: rect.Rect): bool {
        p := input.getMousePos()
        return p.x >= r.x && p.y >= r.y && p.x <= (r.x+r.w) && p.y <= (r.y+r.h)
}


fn drawRectLines*(color: uint32, r: rect.Rect) {
        // top
        canvas.drawRect(color, rect.Rect{r.x, r.y, r.w, 0.5})
        // bottom
        canvas.drawRect(color, rect.Rect{r.x, r.y+r.h-0.5, r.w, 0.5})
        // left
        canvas.drawRect(color, rect.Rect{r.x, r.y+0.5, 0.5, r.h-1})
        // right
        canvas.drawRect(color, rect.Rect{r.x+r.w-0.5, r.y+0.5, 0.5, r.h-1})
}

fn floor*(n: real): int {
        return trunc(n-int(n < 0 && real(trunc(n)) != n))
}

fn rectChopRight*(r: ^rect.Rect, by: int): rect.Rect {
        r.w -= by
        return rect.Rect{r.x+r.w, r.y, by, r.h}
}

fn measureText*(f: font.Cached, text: str): th.Vf2 {
        result := th.Vf2{0, 0}
        runes := utf8.decode(text)
        for rune in runes {
                dims := f.runeDims(rune)
                result.x += dims.x
                result.y = dims.y
        }
        result.x *= 1.6
        result.x -= 1
        result.y *= 1.6
        result.y += 1
        return result
}
