import (
  "window.um"
  "rect.um"
  "th.um"
  "canvas.um"
  "input.um"
  th_font = "font.um"
)

fn textSplitBy(text: str, by: char): []str {
  items := []str{}
  last := 0
  for i, c in text {
    if c == by {
      items = append(items, slice(text, last, i))
      last = i+1 // Skip the character by adding one.
    }
  }
  items = append(items, slice(text, last))
  return items
}

fn join(strl: []str): str {
  result := ""
  for i, s in strl {
    result += s
  }
  return result
}

fn wrapBoundaryRow(font: ^th_font.Font, offset: int, items: []str, boundary: real): int {
  fit := 0
  pos := 0.0

  for offset+fit < len(items) {
    pos += font.measure(items[offset+fit]).x

    if pos < boundary {
      fit += 1
    } else {
      break
    }
  }

  return fit
}

fn wrapTextItems(font: ^th_font.Font, items: []str, boundary: real): []str {
  result := []str{}
  offset := 0
  for offset < len(items) {
    nWrapped := wrapBoundaryRow(font, offset, items, boundary)

    // NOTE: Still draw one word even if we can't fit it
    if nWrapped == 0 {
      nWrapped = 1
    }

    result = append(result, join(slice(items, offset, offset+nWrapped)))
    offset += nWrapped
  } 

  return result
}

// TODO: fix the fact that I need to add spaces at the end, this has side effect that they are also
//       accounted in measurements, so the word doesn't wrap at the end of the word.
fn wrapText(font: ^th_font.Font, text: str, boundary: real): []str {
  split := textSplitBy(text, ' ')
  for i in split {
    // necessary to make calculations in wrapboundaryrow count spaces
    split[i] = split[i]+' '
  }
  return wrapTextItems(font, split, boundary)
}

fn main() {
  window.setup("New dialogs", 800, 600) 
  
  font := th_font.load("data/font/monospace.ttf", 16)
  screen := rect.mk(0, 0, 800, 600)
  boundary := 100.0
  sampleText := "Lorem ipsum dolor sit amet. Hello world! Now this is a story all about how my life got turned upside down." 

  for window.cycle(screen) {
    boundary = input.getMousePos().x
    lines := wrapText(&font, sampleText, boundary)

    for i, line in lines {
      font.draw(line, th.Vf2{0, i*font.measure(" ").y}, th.black)
    }

    canvas.drawLine(th.red, th.Vf2{boundary, 0}, th.Vf2{boundary, len(lines)*font.measure(" ").y}, 1)
  }
}