import (
  "window.um"
  "rect.um"
  "th.um"
  "canvas.um"
  "input.um"
  th_font = "font.um"
)

type PushLayout = struct {
  boundary: real
  position: th.Vf2
  maxY: real
  line: int
}

fn makePushLayout(boundary: real): PushLayout {
  return PushLayout{boundary: boundary}
}

fn (pl: ^PushLayout) pushLine() {
  pl.position.x = 0
  pl.position.y += pl.maxY
  pl.maxY = 0
  pl.line += 1
}

fn (pl: ^PushLayout) push(size: th.Vf2): th.Vf2 {
  if pl.position.x + size.x > pl.boundary {
    pl.pushLine()
  }

  pl.position.x += size.x
  if pl.maxY < size.y {
    pl.maxY = size.y
  }

  return pl.position
}

fn textSplitBy(text: str, by: char): []str {
  items := []str{}
  last := 0
  for i, c in text {
    if c == by {
      items = append(items, slice(text, last, i))
      last = i+1 // NOTE: Skip the character by adding one.
    }
  }
  items = append(items, slice(text, last))
  return items
}

fn pushTextLayout(pl: ^PushLayout, font: ^th_font.Font, text: str) {
  split := textSplitBy(text, "\n")
  pl.push(font.measure(split[0]))
  for i := 1; i < len(split); i++ {
    pl.pushLine()
    pl.push(split[i])
  }
}

fn join(strl: []str): str {
  result := ""
  for i, s in strl {
    result += s
  }
  return result
}

// inserts string `sub` at the end of every string in array except for last
fn intersperse(strl: []str, sub: str): []str {
  newl := copy(strl)

  for i := 0; i < len(newl)-1; i++ {
    newl[i] += sub
  }

  return newl
}

// TODO: fix the fact that I need to add spaces at the end, this has side effect that they are also
//       accounted in measurements, so the word doesn't wrap at the end of the word.
fn wrapText(font: ^th_font.Font, text: str, boundary: real): []str {
  items := textSplitBy(text, ' ')
  pl := makePushLayout(boundary)

  for i, item in items {
    items := textSplitBy(text, '\n')

    for i, item in items {
      if pushTextLayout(&pl, font, item) {

      }
      pushTextLayout(&pl, font, " ")
    }
  }


}

fn main() {
  window.setup("New dialogs", 800, 600) 
  
  font := th_font.load("data/font/monospace.ttf", 16)
  screen := rect.mk(0, 0, 800, 600)
  boundary := 100.0
  sampleText := "Lorem ipsum dolor sit amet. Hello world! Now this is a story all about how my life got turned upside down." 

  for window.cycle(screen) {
    boundary = input.getMousePos().x
    lines := wrapText(&font, sampleText, boundary)

    for i, line in lines {
      font.draw(line, th.Vf2{0, i*font.measure(" ").y}, th.black)
    }

    canvas.drawLine(th.red, th.Vf2{boundary, 0}, th.Vf2{boundary, len(lines)*font.measure(" ").y}, 1)
  }
}