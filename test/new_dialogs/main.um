// TODO(skejeton): 
//  Currently typer operates on the original text,
//  but that's an issue, because the words will wrap as they are typed,
//  it really impairs readability of the dialogs.
//  
//  How I can solve this is by putting the entire word width into the word wrapper routine.
//  I can also try operating on the transformed text, but that comes with a problem of "disappearing characters",
//  for example if I make the boundary so narrow, there's going to be more newline characters, and the typer will 
//  return to a few characters back because there's more characters in the new string added. One way to avoid this
//  is not counting newlines as characters, but that would require a sequential typer, which may be a price worth paying
//  considering the typer in d_typer is also sequential by nature, it has commands that can't be executed out of order,
//  or repeatedly. But when the boundary changes, the text also changes, I'll probably have to re-do the typer somehow again.
//  
//  Another option is to have a word wrapping routine specifically designed for this purpose, that works around the original
//  word wrapping routine by adding the rest of the word when wrapping, but removing the untyped letters when rendering.
//
// TODO(skejeton):
//  The way text is currently typed is really boring and has no expression at all.
//   
//  I want to be able to emphasize and make things go faster if the writer wants, but making it too manual would
//  make things hard to make.
//
//  I should experiment with what looks emotional enough, and of course reserve different typing styles for
//  certain types of moods. The current style, where letters just appear linearly, can be called "typewriter".
//  My charecters won't be typewriters :P
//
//  An idea of a typing style I have rn is when words are typed fast, then spaces wait for a bit, then commas wait for a bit longer,
//  and dots wait for even longer, in theory that could even work in other alphabetic languages like Russian, Ukrainian, Spanish, Portuguese, German etc
//     


import (
  "window.um"
  "rect.um"
  "th.um"
  "canvas.um"
  "input.um"
  "strings.um"
  "load_poems.um"
  "draw_dialog.um"
  "../../src/d_test.um"
  "../../src/d_typer.um"
  "../../src/d_util.um"
  "../../src/d_mouseinput.um"
  "../../src/d_fps.um"
  th_font = "font.um"
  th_color = "color.um"
)

type Wrapping = struct {
  position: real
  boundary: real
  lastSize: real // FIXME: lastSize is kind of meh way to solve ressetting previous elements to new line
}

fn (w: ^Wrapping) wrap(): bool {
  if w.position > w.boundary {
    w.position = w.lastSize
    return true
  }

  return false
}

fn (w: ^Wrapping) push(size: real) {
  w.position += size
  w.lastSize = size
}

fn pushText(w: ^Wrapping, font: th_font.Font, text: str) {
  w.push(font.measure(text).x)
}

fn wrapTextLine(font: th_font.Font, text: str, boundary: real): []str {
  words := strings.splitBy(text, ' ')
  lines := []str{}
  wrapper := Wrapping{position: 0, boundary: boundary}
  line := ""

  for i, word in words {
    pushText(&wrapper, font, word)
    if i != 0 && wrapper.wrap() {
      lines = append(lines, line)
      line = ""
    }
    pushText(&wrapper, font, " ")
    line += word+" "
  }
  // NOTE(skejeton): Remove last space
  lines = append(lines, slice(line, 0, len(line)-1))

  return lines
}

fn wrapText(font: th_font.Font, text: str, boundary: real): []str {
  lines := strings.splitBy(text, '\n')
  resultLines := []str{}

  for i, line in lines {
    resultLines = append(resultLines, wrapTextLine(font, line, boundary))
  }
  return resultLines
}

fn blockCursorFromVisualTextCursor(cursor: draw_dialog.VisualTextCursor, font: th_font.Font): rect.Rect {
  return rect.Rect{cursor.position.x, cursor.position.y, font.measure(" ").x, cursor.height}
}

//wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww

fn drawTempDialogBackdrop(boundingBox: rect.Rect) {
  canvas.drawRect(th.black, d_util.rectShrink(boundingBox, -5))
  d_util.drawRectLines(th.white, d_util.rectShrink(boundingBox, -4), 1)
  canvas.drawRect(0xFF8888FF, d_util.rectShrink(boundingBox, -3))
}

fn drawTempDialog(lines: []draw_dialog.AppearingText, font: th_font.Font, boundingBox: rect.Rect) {
  drawTempDialogBackdrop(boundingBox)
  for i in lines {
    draw_dialog.drawAppearingText(&lines[i], font, boundingBox.getPos().add(th.Vf2{0, font.measure(" ").y*i}), th.black)
  }
}

fn handleResizableRectangle(mouseInput: d_mouseinput.MouseState, rectangle: ^rect.Rect) {
  motion := mouseInput.delta

  if d_util.rectVsPoint(rectangle^, mouseInput.lastPos) {
    if mouseInput.lmb.isDown {
      rectangle.x += motion.x
      rectangle.y += motion.y
    }
    if mouseInput.rmb.isDown {
      rectangle.w += motion.x
      rectangle.h += motion.y
    }
  }
}

const poemNoFile = 
  "After error and trial\n"+
  "I couldn't find your poem file\n"+
  "(No poem file found)";

const poemBadId = 
  "Searching far and above\n"+
  "Poem up and below\n"+
  "I've came to realise\n"+
  "It will not materialise\n"+
  "(Invalid poem ID)";

fn loadPoemFromFile(file: str, poemId: int): str {
  if ok, poems := d_util.readFileStr(file); ok {
    if ok, poem := load_poems.getPoem(load_poems.loadPoems(poems), poemId); ok {
      return poem
    }
    return poemBadId
  }
  return poemNoFile
}

fn controlTypingTime(typingTime: ^real) {
  if input.isPressed(input.key_left) {
    typingTime^ -= th.delta/1000.0
  }
  if input.isPressed(input.key_right) {
    typingTime^ += th.delta/1000.0
  }  
  if typingTime^ < 0 {
    typingTime^ = 0
  }      
}

fn makeAppearingTextArrayFromLines(lines: []str, time: real, timePerLetter: real): []draw_dialog.AppearingText {
  appearingTexts := []draw_dialog.AppearingText{}
  offset := 0
  
  for i in lines {
    timeShift := offset*timePerLetter
    if time - timeShift < 0 {
      timeShift = time
    }
    appearingTexts = append(appearingTexts, draw_dialog.constructAppearingTextFromTime(lines[i], time-timeShift, timePerLetter))
    offset += len(lines[i])
  } 

  return appearingTexts
}

fn booleanColor(boolean: bool): uint32 {
  if boolean {
    return 0x00FF00FF;
  }
  return 0xFF0000FF;
}

fn main() {
  autoplay := false

  d_test.isUnitTest(false)
  window.setup("New dialogs", 800, 600)

  font := th_font.load(d_test.pfx()+"FuzzyBubbles-Bold.ttf", 24)
  screen := rect.mk(0, 0, 800, 600)
  sampleText := loadPoemFromFile(d_test.pfx()+"poems.txt", 0)

  boundingBox := rect.mk(0, 0, 400, 300)
  mouseInput := d_mouseinput.MouseState{}

  typingTime := 0.0
  const timePerLetter = 0.1

  for window.cycle(screen) {
    mouseInput = mouseInput.updated()
    if input.isJustPressed(' ') {
      autoplay = !autoplay
    }
    if autoplay {
      typingTime += th.delta/1000.0
    }
    controlTypingTime(&typingTime)
  
    // Transform lines into appearing texts
    lines := wrapText(font, sampleText, boundingBox.w)
    

    handleResizableRectangle(mouseInput, &boundingBox)

    drawTempDialog(makeAppearingTextArrayFromLines(lines, typingTime, timePerLetter), font, boundingBox)
    canvas.drawRect(booleanColor(autoplay), rect.mk(0, 0, 10, 10))
  }
}
