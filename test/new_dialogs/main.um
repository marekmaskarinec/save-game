//
// TODO(skejeton):
//  The way text is currently typed is really boring and has no expression at all.
//   
//  I want to be able to emphasize and make things go faster if the writer wants, but making it too manual would
//  make things hard to make.
//
//  I should experiment with what looks emotional enough, and of course reserve different typing styles for
//  certain types of moods. The current style, where letters just appear linearly, can be called "typewriter".
//  My charecters won't be typewriters :P
//
//  An idea of a typing style I have rn is when words are typed fast, then spaces wait for a bit, then commas wait for a bit longer,
//  and dots wait for even longer, in theory that could even work in other alphabetic languages like Russian, Ukrainian, Spanish, Portuguese, German etc
//     


import (
  "window.um"
  "rect.um"
  "th.um"
  "canvas.um"
  "input.um"
  "strings.um"
  "load_poems.um"
  m_layout = "layout.um"
  "draw_dialog.um"
  "sequence.um"
  "../../src/d_test.um"
  "../../src/d_typer.um"
  "../../src/d_util.um"
  "../../src/d_mouseinput.um"
  "../../src/d_fps.um"
  th_font = "font.um"
  th_color = "color.um"
)

fn blockCursorFromVisualTextCursor(cursor: draw_dialog.VisualTextCursor, font: th_font.Font): rect.Rect {
  return rect.Rect{cursor.position.x, cursor.position.y, font.measure(" ").x, cursor.height}
}

//wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww

fn handleResizableRectangle(mouseInput: d_mouseinput.MouseState, rectangle: ^rect.Rect) {
  motion := mouseInput.delta

  if d_util.rectVsPoint(rectangle^, mouseInput.lastPos) {
    if mouseInput.lmb.isDown {
      rectangle.x += motion.x
      rectangle.y += motion.y
    }
    if mouseInput.rmb.isDown {
      rectangle.w += motion.x
      rectangle.h += motion.y
    }
  }
}

const poemNoFile = 
  "After error and trial\n"+
  "I couldn't find your poem file\n"+
  "(No poem file found)";

const poemBadId = 
  "Searching far and above\n"+
  "Poem up and below\n"+
  "I've came to realise\n"+
  "It will not materialise\n"+
  "(Invalid poem ID)";

fn loadPoemFromFile(file: str, poemId: int): str {
  if ok, poems := d_util.readFileStr(file); ok {
    if ok, poem := load_poems.getPoem(load_poems.loadPoems(poems), poemId); ok {
      return poem
    }
    return poemBadId
  }
  return poemNoFile
}

fn controlTypingTime(typingTime: ^real) {
  if input.isPressed(input.key_left) {
    typingTime^ -= th.delta/1000.0
  }
  if input.isPressed(input.key_right) {
    typingTime^ += th.delta/1000.0
  }  
  if typingTime^ < 0 {
    typingTime^ = 0
  }      
}

type PushObj = interface{}
type NewLine = struct{}

fn makeAppearingTextArrayFromWordsAndPlaybacks(words: []str, playbacks: []sequence.ItemPlayback): []PushObj {
  appearingTexts := []PushObj{}

  for i, pb in playbacks {
    if words[i] == "\n" {
      appearingTexts = append(appearingTexts, NewLine{})
    } else {
      appearingTexts = append(appearingTexts, draw_dialog.constructAppearingTextFromUnit(words[i], pb.unit*pb.unit))
    }
  }

  return appearingTexts
}

fn booleanColor(boolean: bool): uint32 {
  if boolean {
    return 0x00FF00FF;
  }
  return 0xFF0000FF;
}

fn drawTempDialogBackdrop(boundingBox: rect.Rect) {
  canvas.drawRect(th.black, d_util.rectShrink(boundingBox, -5))
  d_util.drawRectLines(th.white, d_util.rectShrink(boundingBox, -4), 1)
  canvas.drawRect(0xFF8888FF, d_util.rectShrink(boundingBox, -3))
}


fn drawTempDialog(words: []PushObj, font: th_font.Font, boundingBox: rect.Rect) {
  drawTempDialogBackdrop(boundingBox)
  layout := m_layout.makeWrappingLayoutFromBoundary(boundingBox.w)

  for i in words {
    if nl := ^NewLine(words[i]); nl != null {
      layout.wrapAtMin(font.measure(" ").y)
    } else if word := ^draw_dialog.AppearingText(words[i]); word != null {
      size := font.measure(word.orig)
      pos := layout.push(size).add(boundingBox.getPos())

      colour := th.black
      if i % 2 == 0 {
        colour = th.red
      }

      canvas.drawRect(0x33, rect.mk(pos.x, pos.y, size.x, size.y));
      draw_dialog.drawAppearingText(word, font, pos, colour)
    }
  }
}

fn separateNewlines(words: []str): []str {
  result := []str{}
  for i, word in words {
    lines := strings.splitBy(words[i], '\n')
    for i, line in lines {
      if i != 0 {
        result = append(result, '\n')
      }
      result = append(result, line)
    }
  }
  return result
}

fn main() {
  autoplay := false

  d_test.isUnitTest(false)
  window.setup("New dialogs", 800, 600)

  font := th_font.load(d_test.pfx()+"FuzzyBubbles-Bold.ttf", 24)
  screen := rect.mk(0, 0, 800, 600)
  sampleText := loadPoemFromFile(d_test.pfx()+"poems.txt", 1)

  boundingBox := rect.mk(0, 0, 400, 300)
  mouseInput := d_mouseinput.MouseState{}

  typingTime := 0.0
  const timePerLetter = 0.1


  for window.cycle(screen) {
    mouseInput = mouseInput.updated()
    if input.isJustPressed(' ') {
      autoplay = !autoplay
    }
    if autoplay {
      typingTime += th.delta/1000.0
    }
    controlTypingTime(&typingTime)

    // Transform lines into appearing texts
    words := separateNewlines(strings.intersperse(strings.splitBy(sampleText, ' '), ' '))



    seq := sequence.Sequence{}
    for i in words {
      seq.pushNext((i%4+1)/4.0)
    }

    handleResizableRectangle(mouseInput, &boundingBox)

    drawTempDialog(makeAppearingTextArrayFromWordsAndPlaybacks(words, seq.playbacksAt(typingTime)), font, boundingBox)
    canvas.drawRect(booleanColor(autoplay), rect.mk(0, 0, 10, 10))
  }
}
