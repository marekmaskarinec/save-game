// It's an experimental editor that redoes the way the editor is made.
// Yes, I discarded old d_ui.um but let's be honest, it sucks balls.
// Obtuse asf and almost impossible to maintain because of myraid bugs
//  The docking thing.. oh dear.. docking...
// 
// (C) skejeton

import (
  "../../src/d_test.um"; "../../src/d_util.um"; "../../src/d_font.um";
  "window.um"; "rect.um"; "th.um"; "image.um"; "canvas.um"; "input.um"
)

////////////
// UI

////////////
// USAGE

type (
  EditorGrid = struct {
    scaling: real
    panning: th.Vf2
  }

  EditorGridMouseInput = struct {
    isDown: bool
    mousePos: th.Vf2
    mouseDelta: th.Vf2
  }

  Editor = struct {
    // Visual data
    mainFont: d_font.Font

    // Editors
    tileGrid: EditorGrid

    // Input
    mouseWheel: int
    mousePos: th.Vf2
    lastMousePos: th.Vf2

    // Census
    lastToolName: str
    tools: map[str]rect.Rect
    maybeActiveTool: str
    activeTool: str
  }
)

var (
  bevelImage: image.Image
  toolbarIcons: image.Image
  screen: rect.Rect
)

fn (e: ^Editor) beginTool(name: str, toolRect: rect.Rect): bool {
  if d_util.rectVsPoint(toolRect, e.mousePos) {
    e.maybeActiveTool = name
  }

  if e.lastToolName != "" {
    error("Unfinished tool "+name)
  }

  e.lastToolName = name
  e.tools[name] = toolRect

  return e.activeTool == name
}

fn (e: ^Editor) endTool() {
  e.lastToolName = ""
}

fn (e: ^Editor) isLastToolActive(): bool {
  return e.lastToolName == e.activeTool
}

// Draw bevel rect(
//   Rectangle to draw,
//   Does rectangle look pushed in,
//   Color tint, the iconic gray is the default
// )
//
// Draws a beveled rectangle in Windows 98 style.
// It may have a problem with displaying colors somewhat incorrectly,
//   because the middle of the rectangle is tinted gray slightly.
fn drawBevelRect(r: rect.Rect, pushed: bool = false, color: uint32 = th.white) {
  const (
    bevelOuterRect = rect.Rect{0, 0, 5, 5}
    bevelInnerRect = rect.Rect{2, 2, 1, 1}
   
    bevelPushedOuterRect = rect.Rect{5, 0, 5, 5}
    bevelPushedInnerRect = rect.Rect{2, 2, 1, 1}
  )

  if pushed {
    d_util.drawRectNinepatch(bevelImage, bevelPushedOuterRect, bevelPushedInnerRect, r, color)
  } else {
    d_util.drawRectNinepatch(bevelImage, bevelOuterRect, bevelInnerRect, r, color)
  }
}

// Vf2 granulate(
//   Vector to granulate
//   The granulation sizes
// )
// 
// Granulation is making number A a multiple of B by rounding.
// This boy does same thing but for vectors, so `th.Vf2{Granulate(A.x, B.x), Granulate(A.y, B.y)}`.
fn vf2Granulate(a, b: th.Vf2): th.Vf2 {
  a = a.div(b)
  a.x = d_util.floor(a.x)
  a.y = d_util.floor(a.y)
  return a.mul(b)
}

// Vf2 int modulo(
//   Divident
//   Divisor
// )
// 
// Performs an integer (!!!) modulo operator on scalars of vector a wrt b
// All floating point is lost.
fn vf2IntMod(a, b: th.Vf2): th.Vf2 {
  return th.Vf2{trunc(a.x)%trunc(b.x), trunc(a.y)%trunc(b.y)}
}


// Draw text centered(
//   The font
//   The text
//   The color
//   The rect to center in
// )
fn centerTextWithinRect(font: d_font.Font, text: str, r: rect.Rect): th.Vf2 {
  return r.getDims().sub(font.measure(text)).divf(2.0).add(r.getPos())
}

// TODO: Ability to pass colour
fn putButton(editor: ^Editor, r: rect.Rect): bool {
  pressed := editor.isLastToolActive() && d_util.rectVsPoint(r, editor.mousePos) && input.isPressed(input.mouse1)
  if pressed {
    drawBevelRect(r, true, 0xCCCCCCFF)
  } else {
    drawBevelRect(r, false)
  }
  return pressed
}

// Draws titlebar title styled text
fn drawTitlebarText(font: d_font.Font, text: str, p: th.Vf2) {
  font.draw(text, p.add(th.Vf2{0, 0}), th.black)
  font.draw(text, p.add(th.Vf2{1, 0}), th.black)
  font.draw(text, p.add(th.Vf2{0, 1}), th.white)
  font.draw(text, p.add(th.Vf2{1, 1}), th.white)
}

fn uiPutWindow(editor: ^Editor) {
  const (
    padding = 2
    titlebarHeight = 18
    title = "Tile Picker"
  )

  var (
    windowRect: rect.Rect = rect.Rect{30, 30, 300, 500}
    position: th.Vf2 = th.Vf2{padding, padding}
  )

  editor.beginTool(title, windowRect)
  {
    drawBevelRect(windowRect)

    buttonSize := th.Vf2{18, titlebarHeight}
    drawBevelRect(rect.mk(position.x+windowRect.x, position.y+windowRect.y, buttonSize.x, buttonSize.y))
    canvas.drawRect(th.black, rect.mk(position.x+windowRect.x+5, position.y+windowRect.y+titlebarHeight/2-1, buttonSize.x-10, 2))
    position.x += buttonSize.x + padding

    {
      handleSize := th.Vf2{windowRect.w - position.x - padding, titlebarHeight}
      rectangle := rect.mk(position.x+windowRect.x, position.y+windowRect.y, handleSize.x-1, handleSize.y)
      canvas.drawRect(th.blue, rectangle)
      window.beginScissorRect(rectangle)
        drawTitlebarText(editor.mainFont, title, centerTextWithinRect(editor.mainFont, title, rectangle))
      window.endScissor()
    
      position.x += handleSize.x + padding
    }

    position.x = padding
    position.y += titlebarHeight + padding

    contentSize := th.Vf2{windowRect.w - position.x - padding, windowRect.h - position.y - padding}
    drawBevelRect(rect.mk(position.x+windowRect.x, position.y+windowRect.y, contentSize.x-1, contentSize.y-1), true)
  }
  editor.endTool()
}

// Puts editor grid spanning the entire screen
// TODO: Fix scaling
fn uiPutEditorGrid(editor: ^Editor, ge: ^EditorGrid, mi: EditorGridMouseInput) {
  const (
    lineColor = th.white&0xFFFFFF11
    tileColor = th.white&0xFFFFFF22
    debugColor = th.red&0xFFFFFF33
  )

  var (
    scale: real = ge.scaling
    tileSize: real = 32*scale
    tileSizes: th.Vf2 = th.Vf2{tileSize, tileSize}

    mousePos: th.Vf2 = mi.mousePos
    mouseDelta: th.Vf2 = mi.mouseDelta

    // This is the viewport rect, no panning applied
    rectangle: rect.Rect = rect.mk(0, 0, window.w, window.h)

    isActive: bool = editor.beginTool("TileEditor", rectangle)
  )

  if isActive {
    // Handle input
    if mi.isDown {
      ge.panning = ge.panning.add(mouseDelta.divf(scale))
    }
  }

  var (
    // This is the panning :P
    offset: th.Vf2 = th.Vf2{rectangle.w/2, rectangle.h/2}.add(ge.panning).mulf(scale)

    // This is panning but adjusted so that it wraps around every TileSize'th time
    visualOffset: th.Vf2 = vf2IntMod(offset, tileSizes)

    highlightedTileWorldPosition: th.Vf2 = mousePos.sub(offset)
    highlightedTileScreenPosition: th.Vf2 = vf2Granulate(highlightedTileWorldPosition, tileSizes).add(offset)
    highlightedTileRect: rect.Rect = rect.mk(highlightedTileScreenPosition.x, highlightedTileScreenPosition.y, tileSize, tileSize)
  )

  // Draw background (debug)
  canvas.drawRect(debugColor, rectangle)

  // Draw grid
  for y := visualOffset.y; y < rectangle.h; y += tileSize {
    lineRect := rect.mk(round(rectangle.x), round(rectangle.y + y), rectangle.w, 1)
    canvas.drawRect(lineColor, lineRect)
  }

  for x := visualOffset.x; x < rectangle.w; x += tileSize {
    lineRect := rect.mk(round(rectangle.x + x), round(rectangle.y), 1, rectangle.h)
    canvas.drawRect(lineColor, lineRect)
  }

  if isActive {
    // Draw highlighted tile
    canvas.drawRect(tileColor, highlightedTileRect)
  }

  editor.endTool()
}


fn putIconButton(editor: ^Editor, r: rect.Rect, img: image.Image): bool {
  pressed := putButton(editor, r)
  img.draw(th.Transform{p: th.Vf2{r.x, r.y}, s: th.Vf2{1, 1}})
  return pressed
}

// Puts window toolbar on the bottom of the screen
fn uiPutToolbar(editor: ^Editor) {
  const (
    margin = 4
    padding = 4
    rectangleHeight = 32 + margin * 2 + padding * 2
  )

  rectangle := rect.Rect{margin, screen.h - rectangleHeight + margin, screen.w - margin * 2, rectangleHeight - margin * 2}

  editor.beginTool("ToolBar", rectangle)

  drawBevelRect(rectangle, false)

  buttonRectangle := rect.mk(rectangle.x+padding, rectangle.y+padding, rectangle.h-padding*2, rectangle.h-padding*2)

  toolbarIcons.crop(th.Vf2{0.25, 0.25}, th.Vf2{0.50, 0.50})
  putIconButton(editor, buttonRectangle, toolbarIcons)

  buttonRectangle.x += buttonRectangle.w + margin

  toolbarIcons.crop(th.Vf2{0.0, 0.25}, th.Vf2{0.25, 0.50})
  putIconButton(editor, buttonRectangle, toolbarIcons)

  buttonRectangle.x += buttonRectangle.w + margin

  editor.endTool()
}

fn editorInit(): Editor {
  return Editor{
    tileGrid: EditorGrid{scaling: 1.0},
    lastMousePos: input.getMousePos(),
    mainFont: d_font.loadFont("data/font_mono.ttf", 16),
    tools: map[str]rect.Rect{}}
}

fn putEditorDebugToolFrames(editor: ^Editor) {
  font := editor.mainFont

  for toolName in editor.tools {
    baseColor := th.red
    if editor.activeTool == toolName {
      baseColor = th.green
    }

    tool := editor.tools[toolName]

    // NOREP(PlaneText,TextRect,MeasureText,ColorAlpha,RectFrom2Vec2f)
    planeSize := font.measure(toolName)
    canvas.drawRect(baseColor&0xFFFFFFAA, rect.mk(tool.x, tool.y, planeSize.x, planeSize.y))
    d_util.drawRectLines(baseColor, tool)
    font.draw(toolName, tool.getPos(), th.white)
    d_util.drawRectLines(baseColor, tool)
  }
}

fn editorPutUi(editor: ^Editor) {
  // handle pre input states
  editor.mousePos = input.getMousePos()
  editor.mouseWheel = int(input.isJustPressed(input.mouse_up)) - int(input.isJustPressed(input.mouse_down));

  // put ui
  uiPutEditorGrid(editor, &editor.tileGrid, EditorGridMouseInput{input.isPressed(input.mouse2), editor.mousePos, editor.mousePos.sub(editor.lastMousePos)}) 
  uiPutToolbar(editor)
  uiPutWindow(editor)
 
  // put debug overlays
  putEditorDebugToolFrames(editor)

  // handle post input states
  editor.lastMousePos = input.getMousePos()

  // NOREP(PressDetect,MouseInput,AnyMouseButton)
  // swap frame census
  if !(input.isPressed(input.mouse1) || input.isPressed(input.mouse2) || input.isPressed(input.mouse3)) {
    editor.activeTool = editor.maybeActiveTool
  }
  editor.maybeActiveTool = ""
  editor.tools = map[str]rect.Rect{}
}

fn main() {
  d_test.itsNotAUnitTest()

  screen = rect.mk(0, 0, 800, 600)
  window.setup("Cool editor nice", 800, 600)

  // init data
  bevelImage = image.load("data/ts04_bevelbutton.png")
  if bevelImage.handle == 0 {
    error("Couldn't load bevel image.")
  }

  toolbarIcons = image.load("data/ts02_trayicons.png")
  if toolbarIcons.handle == 0 {
    error("Couldn't load toolbar icons image.")
  }


  editor := editorInit()

  // cycle
  for window.cycle(screen) {
    screen.w = window.w
    screen.h = window.h

    canvas.drawRect(th.black, screen)
    editorPutUi(&editor)
  }
}
