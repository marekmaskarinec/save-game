// It's an experimental editor that redoes the way the editor is made.
// Yes, I discarded old d_ui.um but let's be honest, it sucks balls.
// Obtuse asf and almost impossible to maintain because of myraid bugs
//  The docking thing.. oh dear.. docking...
// 
// (C) skejeton

import (
  "../../src/editor/e_drawcmd.um";
  "../../src/d_background.um"; "../../src/d_world.um"; "../../src/d_tileset.um"; "../../src/d_test.um"; "../../src/d_util.um"; "../../src/d_mouseinput.um";
  th_font = "font.um"; th_color = "color.um"; 
  "window.um"; "rect.um"; "th.um"; "image.um"; "canvas.um"; "input.um"
)

////////////
// USAGE

type (
  EditorGrid = struct {
    scaling: real
    panning: th.Vf2
  }

  ToolNode = struct {
    children: map[str]^ToolNode
    parent: ^ToolNode
    lastFrameTouched: int
    rect: rect.Rect
  }

  ButtonState = struct {
    isOver: bool
    isDown: bool
    isPressed: bool
    isReleased: bool
  }

  Editor = struct {
    // Misc
    isDebugOverlayShown: bool
    frameNumber: int

    // Visual data
    ctx: e_drawcmd.DrawContext
    mainFont: th_font.Font

    // Editors
    tileGrid: EditorGrid
    tilemapGrid: EditorGrid
    tileSelected: th.Vf2
    tileset: d_tileset.Tileset
    world: d_world.World

    // Input
    mouseState: d_mouseinput.MouseState

    // Census
    tools: ^ToolNode
    currentTool: ^ToolNode
    maybeActiveTool: ^ToolNode
    activeTool: ^ToolNode
  }
)

var (
  bevelImage: image.Image
  toolbarIcons: image.Image
  screen: rect.Rect
)

fn (e: ^Editor) acquireToolNode(name: str): ^ToolNode {
  if e.currentTool == null {
    e.currentTool = e.tools
  }

  if !validkey(e.currentTool.children, name) {
    tool := new(ToolNode)
    tool ^= ToolNode{children: map[str]^ToolNode{}, parent: e.currentTool}
    e.currentTool.children[name] = tool
  }

  return e.currentTool.children[name]
}

// Prunes all tools untouched last frame
fn (e: ^Editor) pruneToolsRecursive(node: ^ToolNode) {
  for key in node.children {
    if node.children[key].lastFrameTouched < e.frameNumber {
      // Fix leak
      node.children[key].parent = null
      // Prune untouched
      node.children = delete(node.children, key)
    } else {
      // Recurse otherwise
      e.pruneToolsRecursive(node.children[key])
    }
  }
}

fn (e: ^Editor) beginTool(name: str, toolRect: rect.Rect): ^ToolNode {
  node := e.acquireToolNode(name)
  node.lastFrameTouched = e.frameNumber
  node.rect = toolRect

  e.currentTool = node

  if d_util.rectVsPoint(node.rect, e.mouseState.pos) {
    e.maybeActiveTool = node
  }

  return e.currentTool
}

fn (e: ^Editor) endTool() {
  if e.currentTool.parent == null {
    error("Parent node is null, beginTool/endTool mismatched!")
  }
  e.currentTool = e.currentTool.parent
}

fn (e: ^Editor) isCurrentToolActive(): bool {
  return e.activeTool == e.currentTool
}

/*
// QueryMouse()
// 
// Queries mouse button `btn` if it has the `which` property set.
// Returns false if the current tool is not focused.
//
// `btn` maybe be on of the following values:
//   0 :: Left mouse button
//   1 :: Middle mouse button
//   2 :: Right mouse button
//
// `which` may be one of those values:
//   d_mouseinput.down     :: IsDown
//   d_mouseinput.pressed  :: IsPressed
//   d_mouseinput.released :: IsReleased
*/
fn (e: ^Editor) queryMouse(btn: int, which: int): bool {
  if e.isCurrentToolActive() == false {
    return false
  }

  var mouseButton: d_mouseinput.MouseButtonState

  switch btn {
    case 0:
      mouseButton = e.mouseState.lmb
    case 1:
      mouseButton = e.mouseState.mmb
    case 2:
      mouseButton = e.mouseState.rmb
    default:
      error(sprintf("Invalid mouse button index %d", btn))
  }

  switch which {
    case d_mouseinput.down:
      return mouseButton.isDown
    case d_mouseinput.pressed:
      return mouseButton.isPressed
    case d_mouseinput.released:
      return mouseButton.isReleased
    default:
      error(sprintf("Invalid mouse button property index %d", which))
  }
  return false;
}

// Draw bevel rect(
//   Rectangle to draw,
//   Does rectangle look pushed in,
//   Color tint, the iconic gray is the default
// )
//
// Draws a beveled rectangle in Windows 98 style.
// It may have a problem with displaying colors somewhat incorrectly,
//   because the middle of the rectangle is tinted gray slightly.
fn drawBevelRect(ctx: ^e_drawcmd.DrawContext, r: rect.Rect, pushed: bool = false, color: uint32 = th.white) {
  const (
    bevelOuterRect = rect.Rect{0, 0, 5, 5}
    bevelInnerRect = rect.Rect{2, 2, 1, 1}
   
    bevelPushedOuterRect = rect.Rect{5, 0, 5, 5}
    bevelPushedInnerRect = rect.Rect{2, 2, 1, 1}
  )

  if pushed {
    ctx.drawNinepatch(bevelImage, bevelPushedOuterRect, bevelPushedInnerRect, r, color)
  } else {
    ctx.drawNinepatch(bevelImage, bevelOuterRect, bevelInnerRect, r, color)
  }
}

// Vf2 granulate(
//   Vector to granulate
//   The granulation sizes
// )
// 
// Granulation is making number A a multiple of B by rounding.
// This boy does same thing but for vectors, so `th.Vf2{Granulate(A.x, B.x), Granulate(A.y, B.y)}`.
fn vf2Granulate(a, b: th.Vf2): th.Vf2 {
  return a.div(b).floor().mul(b)
}

// Vf2 int modulo(
//   Divident
//   Divisor
// )
// 
// Performs an integer (!!!) modulo operator on scalars of vector a wrt b
// All floating point is lost.
fn vf2IntMod(a, b: th.Vf2): th.Vf2 {
  return th.Vf2{trunc(a.x)%trunc(b.x), trunc(a.y)%trunc(b.y)}
}

// Draw text centered(
//   The font
//   The text
//   The color
//   The rect to center in
// )
fn centerTextWithinRect(font: th_font.Font, text: str, r: rect.Rect): th.Vf2 {
  return r.getDims().sub(font.measure(text)).divf(2.0).add(r.getPos())
}

// TODO: Ability to pass colour
fn drawButton(ctx: ^e_drawcmd.DrawContext, r: rect.Rect, buttonState: ButtonState) {
  if buttonState.isDown {
    drawBevelRect(ctx, r, true, 0xCCCCCCFF)
  } else {
    drawBevelRect(ctx, r, false)
  }
}

fn putButton(editor: ^Editor, r: rect.Rect, name: str): ButtonState {
  editor.beginTool(name,  r)

  buttonState := ButtonState{}

  if (editor.isCurrentToolActive()) {
    buttonState.isOver = true;
    buttonState.isDown = editor.mouseState.lmb.isDown;
    buttonState.isPressed = editor.mouseState.lmb.isPressed;
    buttonState.isReleased = editor.mouseState.lmb.isReleased && d_util.rectVsPoint(r, editor.mouseState.pos);
  }

  editor.endTool()
  return buttonState
}

var (
  windowVisible: bool = true
  windowRect: rect.Rect = rect.Rect{30, 30, 300, 500}
)

fn uiPutWindow(editor: ^Editor, title: str): (rect.Rect, bool) {
  const (
    padding = 2
    titlebarHeight = 18
  )

  var (
    contentRect: rect.Rect
    movement: th.Vf2
    squishing: th.Vf2  // Same as movement but changes the window size
  )

  if !windowVisible {
    return rect.mk(0, 0, 0, 0), false
  }

  position := th.Vf2{padding, padding}

  // Frame tool.
  editor.beginTool(title, windowRect)
  {
    drawBevelRect(&editor.ctx, windowRect)

    buttonSize := th.Vf2{20, titlebarHeight}
    buttonRect := rect.mk(position.x+windowRect.x, position.y+windowRect.y, buttonSize.x, buttonSize.y)
    buttonState := putButton(editor, buttonRect, "Close")
    drawButton(&editor.ctx, buttonRect, buttonState)
    if (buttonState.isReleased) {
      windowVisible = false
    }
    editor.ctx.drawRect(th.black, rect.mk(position.x+windowRect.x+5, position.y+windowRect.y+titlebarHeight/2-1, buttonSize.x-10, 2))
    position.x += buttonSize.x + padding

    {
      handleSize := th.Vf2{windowRect.w - position.x - padding, titlebarHeight}
      rectangle := rect.mk(position.x+windowRect.x, position.y+windowRect.y, handleSize.x-1, handleSize.y)

      // Titlebar tool.
      editor.beginTool("Titlebar", rectangle)
      {
        if (editor.queryMouse(0, d_mouseinput.down)) {
          movement = editor.mouseState.delta
        }
      }
      editor.endTool()

      editor.ctx.drawRect(0x000077FF, rectangle)
      editor.ctx.beginScissorRect(rectangle)
        editor.ctx.drawText(editor.mainFont, title, centerTextWithinRect(editor.mainFont, title, rectangle), th.white)
      editor.ctx.endScissor()
    
      position.x += handleSize.x + padding
    }

    position.x = 1
    position.y += titlebarHeight + 1

    contentSize := th.Vf2{windowRect.w - position.x - padding, windowRect.h - position.y - padding}
    contentRect = rect.mk(position.x+windowRect.x, position.y+windowRect.y, contentSize.x-1, contentSize.y-1)

    editor.beginTool("Body", contentRect)
    {
      if (editor.queryMouse(0, d_mouseinput.down)) {
        movement = editor.mouseState.delta
      }
    }
    editor.endTool()

    gripSize := th.Vf2{10, 10};
    gripRect := rect.mk(windowRect.x+windowRect.w-gripSize.x, windowRect.y+windowRect.h-gripSize.y, gripSize.x, gripSize.y)
    editor.beginTool("Grip", gripRect)
    {
      if (editor.queryMouse(0, d_mouseinput.down)) {
        squishing = editor.mouseState.delta
      }
    }
    editor.endTool()
  }
  editor.endTool()


  windowRect = d_util.rectMove(windowRect, movement)
  windowRect.w += squishing.x; windowRect.h += squishing.y;

  // Clamp
  if windowRect.w < 100 {
    windowRect.w = 100
  }
  if windowRect.h < 100 {
    windowRect.h = 100
  }

  return contentRect, true
}


fn (ge: ^EditorGrid) mapPos(rectangle: rect.Rect, pos: th.Vf2): th.Vf2 {
  return ge.panning.mulf(ge.scaling).add(pos).add(rectangle.getPos())
}

// Puts editor grid spanning the entire screen
// TODO: Fix scaling
fn (ge: ^EditorGrid) put(editor: ^Editor, rectangle: rect.Rect): th.Vf2 {
  const (
    lineColor = th.white&0xFFFFFF11
    tileColor = th.white&0xFFFFFF22
    debugColor = th.red&0xFFFFFF00
  )

  var (
    scale: real = ge.scaling
    tileSize: real = 32*scale
    tileSizes: th.Vf2 = th.Vf2{tileSize, tileSize}

    mousePos: th.Vf2 = editor.mouseState.pos.sub(rectangle.getPos())
    mouseDelta: th.Vf2 = editor.mouseState.delta
  )

  if editor.isCurrentToolActive() {
    // Handle input
    if editor.mouseState.mmb.isDown {
      ge.panning = ge.panning.add(mouseDelta.divf(scale))
    }
  }

  var (
    // This is the panning :P
    offset: th.Vf2 = ge.panning.mulf(scale)

    // This is panning but adjusted so that it wraps around every TileSize'th time
    visualOffset: th.Vf2 = vf2IntMod(offset, tileSizes)

    highlightedTileWorldPosition: th.Vf2 = mousePos.sub(offset)
    highlightedTileScreenPosition: th.Vf2 = vf2Granulate(highlightedTileWorldPosition, tileSizes).add(offset).add(rectangle.getPos())
    highlightedTileRect: rect.Rect = rect.mk(highlightedTileScreenPosition.x, highlightedTileScreenPosition.y, tileSize, tileSize)
  )

  editor.ctx.beginScissorRect(rectangle)

  // Draw background (debug)
  editor.ctx.drawRect(debugColor, rectangle)

  // Draw grid
  for y := visualOffset.y; y < rectangle.h; y += tileSize {
    lineRect := rect.mk(round(rectangle.x), round(rectangle.y + y), rectangle.w, 1)
    editor.ctx.drawRect(lineColor, lineRect)
  }

  for x := visualOffset.x; x < rectangle.w; x += tileSize {
    lineRect := rect.mk(round(rectangle.x + x), round(rectangle.y), 1, rectangle.h)
    editor.ctx.drawRect(lineColor, lineRect)
  }

  if editor.isCurrentToolActive() {
    // Draw highlighted tile
    editor.ctx.drawRect(tileColor, highlightedTileRect)
  }

  coordinate := ge.panning.mulf(-1).div(tileSizes).floor()
  coordinateString := sprintf("%+-4g %+-4g", coordinate.x, coordinate.y)

  bottomLeft := th.Vf2{rectangle.x, rectangle.y+rectangle.h}
  bottomLeft.y -= editor.mainFont.measure(coordinateString).y
  editor.ctx.drawText(editor.mainFont, coordinateString, bottomLeft, th.white)

  editor.ctx.endScissor()

  return highlightedTileWorldPosition.div(tileSizes).floor()
}

fn putIconButton(editor: ^Editor, name: str, r: rect.Rect, img: image.Image): bool {
  buttonState := putButton(editor, r, name)
  drawButton(&editor.ctx, r, buttonState)
  editor.ctx.drawImage(img, th.Transform{p: th.Vf2{r.x, r.y}, s: th.Vf2{1, 1}})
  return buttonState.isPressed
}

// Puts window toolbar on the bottom of the screen
fn editorPutToolbar(editor: ^Editor) {
  const (
    margin = 0
    padding = 1
    rectangleHeight = 32 + margin * 2 + padding * 2
  )

  rectangle := rect.Rect{margin, screen.h - rectangleHeight + margin, screen.w - margin * 2, rectangleHeight - margin * 2}

  editor.beginTool("ToolBar", rectangle)

  drawBevelRect(&editor.ctx, rectangle, false)

  buttonRectangle := rect.mk(rectangle.x+padding, rectangle.y+padding, rectangle.h-padding*2, rectangle.h-padding*2)

  toolbarIcons.crop(th.Vf2{0.25, 0.25}, th.Vf2{0.50, 0.50})
  putIconButton(editor, "Play", buttonRectangle, toolbarIcons)

  buttonRectangle.x += buttonRectangle.w + margin

  toolbarIcons.crop(th.Vf2{0.0, 0.25}, th.Vf2{0.25, 0.50})
  putIconButton(editor, "Tile Picker", buttonRectangle, toolbarIcons)

  buttonRectangle.x += buttonRectangle.w + margin

  editor.endTool()
}

fn editorInit(): Editor {
  rootNode := new(ToolNode)
  rootNode ^= ToolNode{children: map[str]^ToolNode{}}


  tilesetImage := image.load("data/ts00_sky.png")
  if tilesetImage.validate() == false {
    error("Couldn't load tileset image.")
  }
  tileset := d_tileset.fromImage(tilesetImage, 32, 32)
  world := d_world.fromTileset(tileset)
  world.load(d_util.readFileStr("data/sc00_sky.csv"))

  return Editor{
    ctx: e_drawcmd.init(),
    tileGrid: EditorGrid{scaling: 1.0},
    tilemapGrid: EditorGrid{scaling: 1.0},
    tileset: tileset,
    world: world,
    mainFont: th_font.load("data/font_mono.ttf", 16, th_font.filterNearest),
    tools: rootNode}
}

fn putEditorDebugToolFramesRecursive(editor: ^Editor, tool: ^ToolNode, prefix: str = "") {
  font := editor.mainFont

  for toolName, toolChild in tool.children {
    baseColor := th.red
    if editor.activeTool == toolChild {
      baseColor = th.green
    }

    toolName = prefix + toolName

    // NOREP(PlaneText,TextRect,MeasureText,ColorAlpha,RectFrom2Vec2f)
    if editor.activeTool == toolChild {
      planeSize := font.measure(toolName)
      r := rect.mk(toolChild.rect.x, toolChild.rect.y-planeSize.y, planeSize.x, planeSize.y)
      if r.y < 0 {
        r.y += planeSize.y
      }
      canvas.drawRect(baseColor&0xFFFFFFAA, r)
      font.draw(toolName, r.getPos(), th.white)
    }
    d_util.drawRectLines(baseColor, toolChild.rect)

    putEditorDebugToolFramesRecursive(editor, toolChild, toolName+"::")
  }
}

fn putEditorDebugToolFrames(editor: ^Editor) {
  putEditorDebugToolFramesRecursive(editor, editor.tools)
}

fn isAnyButtonHeld(mouseState: ^d_mouseinput.MouseState): bool {
  return mouseState.lmb.isDown || mouseState.mmb.isDown || mouseState.rmb.isDown
} 

fn putSimpleButton(editor: ^Editor, r: rect.Rect, text: str) {
  drawButton(&editor.ctx, r, putButton(editor, r, text))
  editor.ctx.drawText(editor.mainFont, text, centerTextWithinRect(editor.mainFont, text, r), th.black)
}

type WorldEditCmd = struct {
  rect: rect.Rect
  offset: th.Vf2
  world: ^d_world.World
}

fn (d: ^WorldEditCmd) draw(props: e_drawcmd.DrawProperties) {
  d_background.draw(d.rect)
  d.world.draw(d.offset)
}

fn editorPutUi(editor: ^Editor) {
  editor.mouseState = editor.mouseState.updated()

  editor.frameNumber += 1;

  // put ui
  tool := editor.beginTool("TileEditor", rect.mk(0, 0, window.w, window.h-34))

  selectedTile := editor.tileGrid.put(editor, tool.rect)
  if editor.queryMouse(0, d_mouseinput.down) {
    editor.world.setTile(0, trunc(selectedTile.x), trunc(selectedTile.y), editor.tileset.tileToPos(trunc(editor.tileSelected.x), trunc(editor.tileSelected.y)))
  }
  if editor.queryMouse(2, d_mouseinput.down) {
    editor.world.setTile(0, trunc(selectedTile.x), trunc(selectedTile.y), 0)
  }

  editor.ctx.moveLayer(-1)
  editor.ctx.drawCustom(WorldEditCmd{tool.rect, editor.tileGrid.mapPos(tool.rect, th.Vf2{0, 0}).mulf(-1), &editor.world})
  editor.ctx.moveLayer(1)

  editorPutToolbar(editor)
  editor.endTool()

  if contentRect, ok := uiPutWindow(editor, "Tile Picker"); ok { 
    editor.beginTool("TilePicker", contentRect)
    {
      editor.ctx.drawRect(th.black, contentRect)
      editor.ctx.moveLayer(1)

      selectedTile := editor.tilemapGrid.put(editor, contentRect)
      if editor.queryMouse(0, d_mouseinput.down) {
        editor.tileSelected = selectedTile
      }

      selectedTilePos := editor.tilemapGrid.mapPos(contentRect, editor.tileSelected.mulf(32))
      
      editor.ctx.beginScissorRect(contentRect)
      editor.ctx.drawRect(th_color.alpha(th.green, 0.3), rect.mk(selectedTilePos.x, selectedTilePos.y, 32, 32))
      editor.ctx.endScissor()

      editor.ctx.moveLayer(-1)
      editor.ctx.beginScissorRect(contentRect)

      editor.tileset.image.crop(th.Vf2{0, 0}, th.Vf2{1, 1})
      editor.ctx.drawImage(editor.tileset.image, th.Transform{s: th.Vf2{1, 1}, p: editor.tilemapGrid.mapPos(contentRect, th.Vf2{0, 0})})
      editor.ctx.endScissor()
    }
    editor.endTool()
  }

  // flush render context
  editor.ctx.flush()
 
  // put debug overlays
  if (editor.isDebugOverlayShown) {
    putEditorDebugToolFrames(editor)
  }

  // handle post input states
  if (input.isJustPressed(input.key_escape)) {
    editor.isDebugOverlayShown = !editor.isDebugOverlayShown
  }

  // swap frame census
  if !isAnyButtonHeld(&editor.mouseState) {
    editor.activeTool = editor.maybeActiveTool
  }
  editor.maybeActiveTool = null
  editor.pruneToolsRecursive(editor.tools)
}

// Disconnects all nodes in the editor from their parents.
// Due to how the Umka GC currently works, it's not able to collect
//   circular references, so I must do it myself.
fn editorDisconnectAllNodes(editor: ^Editor, node: ^ToolNode) {
  if node == null {
    node = editor.tools
  }

  node.parent = null
  for _, child in node.children {
    editorDisconnectAllNodes(editor, child)
  }
}

fn main() {
  d_test.itsNotAUnitTest()

  screen = rect.mk(0, 0, 800, 600)
  window.setup("Cool editor nice", 800, 600)

  // init data
  bevelImage = image.load("data/ts04_bevelbutton.png")
  if bevelImage.validate() == false {
    error("Couldn't load bevel image.")
  }

  toolbarIcons = image.load("data/ts02_trayicons.png")
  if toolbarIcons.validate() == false {
    error("Couldn't load toolbar icons image.")
  }

  d_background.init()

  editor := editorInit()

  // cycle
  for window.cycle(screen) {
    screen.w = window.w
    screen.h = window.h

    canvas.drawRect(th.black, screen)
    editorPutUi(&editor)
  }

  editorDisconnectAllNodes(&editor, null)
}
