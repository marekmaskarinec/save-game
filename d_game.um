import ("th.um"; "rect.um"; "canvas.um"; "input.um"
        "d_world.um")

const (
        shapeBlock              = 0
        shapeLeftUpSlope        = 1
        shapeRightUpSlope       = 2
        shapeLeftDownSlope      = 3
        shapeRightDownSlope     = 4
)

type (
        Shape* = struct {
                rect: rect.Rect
                shape: int
        }

        Character* = struct {
                rect: rect.Rect
                vel: th.Vf2
                onGround: bool
        }
)

var (
        world*: d_world.World
        chara*: Character
        camera: th.Vf2
)

fn centerPlayerOnCamera() {
        camera.x += ((chara.rect.x-(320-chara.rect.w)/2)-camera.x)/4;
        camera.y += ((chara.rect.y-(240-chara.rect.h)/2)-camera.y)/4;
}

fn cameraOffsetRect(r: rect.Rect): rect.Rect {
        r.x -= camera.x
        r.y -= camera.y
        return r
}

fn moveCharacter() {
        chara.vel.x = 0
        if input.isPressed(input.key_up) && chara.onGround {
                chara.vel.y = -3.19
        }
        if input.isPressed(input.key_left) {
                chara.vel.x = -1
        }
        if input.isPressed(input.key_right) {
                chara.vel.x = 1
        }
        if chara.rect.y > 1e3 {
                // NOTE: Respawn
                chara.vel.y = 0;
                chara.vel.x = 0;
                chara.rect.x = 0;
                chara.rect.y = 0;
        }


        chara.vel.y += 0.1

        if chara.vel.y > 5 {
                chara.vel.y = 5
        }

        chara.rect.x += chara.vel.x
        chara.rect.y += chara.vel.y

        chara.onGround = false
}

fn collCalcRectSnap(r, along: rect.Rect): th.Vf2 {
        x_left := r.x + r.w - along.x;
        y_up := r.y + r.h - along.y;

        x_right := along.x + along.w - r.x;
        y_down := along.y + along.h - r.y;

        var (min_x: real; min_y: real)

        if fabs(x_left) < fabs(x_right) {
                min_x = -x_left
        } else {
                min_x = x_right
        }

        if fabs(y_up) < fabs(y_down) {
                min_y = -y_up
        } else {
                min_y = y_down
        }

        if fabs(min_x) < fabs(min_y) {
                return th.Vf2{min_x, 0};
        } 
        return th.Vf2{0, min_y};
}

fn collRectVsRect(r1, r2: rect.Rect): bool {
        return (r1.x + r1.w) > (r2.x) && (r1.y + r1.h) > (r2.y) && (r1.x) < (r2.x + r2.w) && (r1.y) < (r2.y + r2.h)
}

fn collSortShapesByProximity(shapes: ^[]Shape, along: th.Vf2) {
        for i := 0; i < len(shapes^); i++ {
                closest := &shapes[i];
                mindist := real(99999999);
                for j := i; j < len(shapes^); j++ {
                        current := shapes[j].rect;
                        point := th.Vf2{current.x + current.w / 2, current.y + current.h / 2};
                        dist := point.distanceTo(along);
                        if dist < mindist {
                                mindist = dist;
                                closest = &shapes[j];
                        }
                }
                tmp := closest^;
                closest^ = shapes[i];
                shapes[i] = tmp;
        }
}

fn playerVsShape(s: Shape) {
        r := s.rect
        snap := collCalcRectSnap(chara.rect, r)
        var (hit: real; cornerY: real) 

        // Calc slope values
        switch s.shape {
        case shapeLeftUpSlope:
                if snap.x > 0 {
                        s.shape = shapeBlock
                } else {
                        hit = 16-(chara.rect.x+chara.rect.w-r.x)
                        cornerY = chara.rect.y+chara.rect.h-r.y
                }
        case shapeRightUpSlope:
                if snap.x < 0 {
                        s.shape = shapeBlock
                } else {
                        hit = chara.rect.x-r.x
                        cornerY = chara.rect.y+chara.rect.h-r.y
                }
        case shapeLeftDownSlope:
                if snap.x > 0 {
                        s.shape = shapeBlock
                } else {
                        hit = chara.rect.x+chara.rect.w-r.x
                        cornerY = chara.rect.y-r.y
                }
        case shapeRightDownSlope:
                if snap.x < 0 {
                        s.shape = shapeBlock
                } else {
                        hit = 16-(chara.rect.x-r.x)
                        cornerY = chara.rect.y-r.y
                }
        }

        switch s.shape {
        case shapeLeftUpSlope, shapeRightUpSlope:
                if cornerY > 17 {
                        s.shape = shapeBlock
                }
                // If jumping below the slope
                if chara.vel.y < 0 && (cornerY-hit) > 0 {
                        s.shape = shapeBlock
                }
        case shapeLeftDownSlope, shapeRightDownSlope:
                if cornerY < -1 {
                        s.shape = shapeBlock
                }
                // If walking above the slope
                if chara.vel.y > 0 && (hit-cornerY) > 16 {
                        s.shape = shapeBlock
                }
        }
 
        
        // Not a valid collision (probably pushed back by other blocks?)
        if collRectVsRect(chara.rect, r) == false {
                return;
        }
        // Resolve slope collision
        switch s.shape {
        case shapeBlock:
                if snap.x != 0 {
                        chara.vel.x = 0
                } else if snap.y != 0 {
                        chara.vel.y = 0;
                }
                if snap.y < 0 {
                        chara.onGround = true;
                }
                chara.rect.x += snap.x
                chara.rect.y += snap.y
        case shapeLeftUpSlope, shapeRightUpSlope:
                if hit < 0 { 
                        hit = 0
                }
                if cornerY-hit > 0 {
                        chara.rect.y -= cornerY-hit
                        chara.vel.y = 0
                        chara.onGround = true
                }
        case shapeLeftDownSlope, shapeRightDownSlope:
                if hit > 16 { 
                        hit = 16
                }
                if hit-cornerY > 0 {
                        chara.rect.y += hit-cornerY
                        if (chara.vel.y < 0) {
                                chara.vel.y = 0
                        }
                }

        }
}

fn playerConstructColidingSolids(): []Shape {
        tangents := world.getTangentTiles(chara.rect)
        solids := []Shape{}

        for tangent in tangents {
                shapeRect := rect.Rect{tangent.x*16.0, tangent.y*16.0, 16, 16} 
                shapeType := -1

                switch tangent.id {
                case 1, 5, 7:   shapeType = shapeBlock;
                case 9:         shapeType = shapeLeftUpSlope;
                case 10:        shapeType = shapeRightUpSlope;
                case 13:        shapeType = shapeLeftDownSlope;
                case 14:        shapeType = shapeRightDownSlope;
                
                // TODO: Investigate why uncommenting this causes a bug where you can pass through blocks
                // default:        break;
                }
                
                solids = append(solids, Shape{shapeRect, shapeType})
        }

        collSortShapesByProximity(&solids, th.Vf2{chara.rect.x+chara.rect.w/2, chara.rect.y+chara.rect.h/2});
        return solids       
}

fn playerSolveCollision() {
        solids := playerConstructColidingSolids()

        for solid in solids {
                playerVsShape(solid);
        }
}

fn drawRectTangents(r: rect.Rect) {
        solids := playerConstructColidingSolids()

        i := 0
        for solid in solids {
                rec := cameraOffsetRect(solid.rect)
                switch solid.shape {
                case shapeBlock:
                        canvas.drawRect(0x00FF0055, rec)
                case shapeLeftUpSlope, shapeRightDownSlope:
                        canvas.drawLine(0x00FF0055, th.Vf2{rec.x, rec.y+rec.h}, th.Vf2{rec.x+rec.w, rec.y}, 2);
                case shapeRightUpSlope, shapeLeftDownSlope:
                        canvas.drawLine(0x00FF0055, th.Vf2{rec.x, rec.y}, th.Vf2{rec.x+rec.w, rec.y+rec.h}, 2);
                }
                canvas.drawText(repr(i), th.Vf2{rec.x, rec.y}, th.white, 1);
                i++
        }
}

fn draw*() {
        moveCharacter();
        playerSolveCollision();
        centerPlayerOnCamera();

        world.drawLayer(camera, -1)
        if chara.onGround { 
                canvas.drawRect(th.red, cameraOffsetRect(chara.rect))
        } else {
                canvas.drawRect(th.blue, cameraOffsetRect(chara.rect))
        }
        world.drawLayer(camera, 0)
        world.drawLayer(camera, 1)
        drawRectTangents(chara.rect)
}
