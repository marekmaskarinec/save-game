import ("th.um"; "rect.um"; "canvas.um"; "input.um"
        "d_world.um")

type (
        Character* = struct {
                rect: rect.Rect
                vel: th.Vf2
                onGround: bool
        }
)

var (
        world*: d_world.World
        chara*: Character
        camera: th.Vf2
)

fn centerPlayerOnCamera() {
        camera.x += ((chara.rect.x-(320-chara.rect.w)/2)-camera.x)/4;
        camera.y += ((chara.rect.y-(240-chara.rect.h)/2)-camera.y)/4;
}

fn cameraOffsetRect(r: rect.Rect): rect.Rect {
        r.x -= camera.x
        r.y -= camera.y
        return r
}

fn moveCharacter() {
        if input.isJustPressed(input.key_up) && chara.onGround {
                chara.vel.y = -3.19
        }
        if input.isPressed(input.key_left) {
                chara.vel.x = -1
        }
        if input.isPressed(input.key_right) {
                chara.vel.x = 1
        }


        chara.vel.y += 0.1
        if chara.vel.y >= 0 {
                chara.vel.y += 0.1
        }
        if chara.vel.y > 5 {
                chara.vel.y = 5
        }

        chara.rect.x += chara.vel.x
        chara.rect.y += chara.vel.y

        chara.vel.x = 0
        chara.onGround = false
}

fn collCalcRectSnap(r, along: rect.Rect): th.Vf2 {
        x_left := r.x + r.w - along.x;
        y_up := r.y + r.h - along.y;

        x_right := along.x + along.w - r.x;
        y_down := along.y + along.h - r.y;

        var (min_x: real; min_y: real)

        if fabs(x_left) < fabs(x_right) {
                min_x = -x_left
        } else {
                min_x = x_right
        }

        if fabs(y_up) < fabs(y_down) {
                min_y = -y_up
        } else {
                min_y = y_down
        }

        if fabs(min_x) < fabs(min_y) {
                return th.Vf2{min_x, 0};
        } 
        return th.Vf2{0, min_y};
}

fn collSortRectsByProximity(recs: ^[]rect.Rect, along: th.Vf2) {
    for i := 0; i < len(recs^); i++ {
        closest := &recs[i];
        mindist := real(99999999);
        for j := i; j < len(recs^); j++ {
            current := recs[j];
            point := th.Vf2{current.x + current.w / 2, current.y + current.h / 2};
            dist := point.distanceTo(along);
            if dist < mindist {
                mindist = dist;
                closest = &recs[j];
            }
        }
        tmp := closest^;
        closest^ = recs[i];
        recs[i] = tmp;
    }
}

fn playerVsSolid(r: rect.Rect) {
        snap := collCalcRectSnap(chara.rect, r)
        if snap.x != 0 {
                chara.vel.x = 0
        }
        if snap.y != 0 {
                chara.vel.y = 0
        }

        if (snap.y < 0) {
                chara.onGround = true;
        }
        chara.rect.x += snap.x
        chara.rect.y += snap.y
}

fn playerConstructColidingSolids(): []rect.Rect {
        tangents := world.getTangentTiles(chara.rect)
        solids := []rect.Rect{}

        for tangent in tangents {
                if (tangent.id == 1) || (tangent.id == 5) || (tangent.id == 7) {
                        tileRect := rect.Rect{tangent.x*16.0, tangent.y*16.0, 16, 16} 
                        solids = append(solids, tileRect)
                }
        }

        collSortRectsByProximity(&solids, th.Vf2{chara.rect.x+chara.rect.w/2, chara.rect.y+chara.rect.h/2});
        return solids       
}

fn playerSolveCollision() {
        solids := playerConstructColidingSolids()

        for solid in solids {
                playerVsSolid(solid)
        }
}

fn drawRectTangents(r: rect.Rect) {
        solids := playerConstructColidingSolids()

        i := 0
        for solid in solids {
                solid = cameraOffsetRect(solid)
                canvas.drawRect(0x00FF0055, solid)
                canvas.drawText(repr(i), th.Vf2{solid.x, solid.y}, th.white, 1);
                i++
        }
}

fn draw*() {
        moveCharacter();
        playerSolveCollision();
        centerPlayerOnCamera();

        world.draw(camera)
        drawRectTangents(chara.rect)
        if chara.onGround { 
                canvas.drawRect(th.red, cameraOffsetRect(chara.rect))
        } else {
                canvas.drawRect(th.blue, cameraOffsetRect(chara.rect))
        }
}
