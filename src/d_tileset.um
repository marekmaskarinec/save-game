import ("th.um"; "image.um")

type (
  Tileset* = struct {
    image: image.Image
    scale: real
    tileSizeX, tileSizeY: int
    tileCountX, tileCountY: int
  }
)

fn fromImage*(img: image.Image, tileSizeX, tileSizeY: int, scale: real): Tileset {
  dims := img.getDims()
  return Tileset{
    image: img,
    tileSizeX: tileSizeX, tileSizeY: tileSizeY,
    tileCountX: trunc(dims.x/(tileSizeX/scale)), tileCountY: trunc(dims.y/(tileSizeY/scale)), scale: scale+0.01}
}

fn (ts: ^Tileset) tileToPos*(x, y: int): int {
  return x + ts.tileCountX * y + 1
}

fn (ts: ^Tileset) posToTile*(pos: int): th.Vf2 {
  pos -= 1
  return th.Vf2{pos%ts.tileCountX, pos/ts.tileCountX}
}

fn (ts: ^Tileset) selectTile*(x, y: int) {
  tcx, tcy := real(ts.tileCountX), real(ts.tileCountY)
  xr, yr, otcx, otcy := x/tcx, y/tcy, 1/tcx, 1/tcy

  ts.image.crop(th.Vf2{xr+0.001, yr+0.001},
          th.Vf2{xr+otcx-0.001, yr+otcy-0.001})
}

fn (ts: ^Tileset) selectTilePos*(pos: int) {
  pos -= 1
  ts.selectTile(pos%ts.tileCountX, pos/ts.tileCountX)
}

fn (ts: ^Tileset) isTileValid*(pos: int): bool {
  if pos < 1 || pos > (ts.tileCountX*ts.tileCountY) {
    return false
  }
  return true
}
