//  d_world.um
//
//  The world is split up into layers, which contain chunks.
//  There's 3 layers:
//    -1: the background layer, no collision checks are performed on it
//    0: the middleground layer, this is where the collisions are tested
//    1: the foreground layer, this is drawn over the character, no collision checks

import (
  "th.um"; "rect.um"
  "d_util.um"; "d_tileset.um"
)

const (
  chunkW* = 320/16*2
  chunkH* = 240/16*2
)

type (
  Chunk* = [chunkW][chunkH]int
  ChunkPos* = struct {
    x: int
    y: int
  }
  World* = struct {
    playerSpawnPos: th.Vf2
    tileset: d_tileset.Tileset
    tilemap: [3]map[ChunkPos]Chunk
  }
  Tangent* = struct {
    x, y: int
    id: int
  }
)

fn fromTileset*(ts: d_tileset.Tileset): World {
  return World{tileset: ts, tilemap: [3]map[ChunkPos]Chunk{map[ChunkPos]Chunk{}, map[ChunkPos]Chunk{}, map[ChunkPos]Chunk{}}}
}

fn (world: ^World) setTile*(layer, tx, ty, tile: int) {
  layer++
  if layer < 0 || layer > 2 {
    return
  }

  // get or construct a chunk
  chunk_pos := ChunkPos{d_util.floor(tx/real(chunkW)), d_util.floor(ty/real(chunkH))}

  chunk := &world.tilemap[layer][chunk_pos]

  // make tile positions local
  tx = tx - chunk_pos.x * chunkW
  ty = ty - chunk_pos.y * chunkH

  chunk[tx][ty] = tile
}

fn (world: ^World) getTile*(layer, tx, ty: int): int {
  layer++
  if layer < 0 || layer > 2 {
    return 0
  }

  chunk_pos := ChunkPos{d_util.floor(tx/real(chunkW)), d_util.floor(ty/real(chunkH))}
  if !validkey(world.tilemap[layer], chunk_pos) {
    return 0
  }

  chunk := &world.tilemap[layer][chunk_pos]

  // make tile positions local
  tx = tx - chunk_pos.x * chunkW
  ty = ty - chunk_pos.y * chunkH

  return chunk[tx][ty]
}


//
// getTangentTiles(
//      r: Rectangle to find tangent tiles around
// ): List of tangents, position of tile and it's id.
//
// NOTE: This function only checks middleground layer (layer 0)
//
fn (world: ^World) getTangentTiles*(r: rect.Rect): []Tangent {
  x, y, w, h := d_util.floor(r.x/world.tileset.tileSizeX), d_util.floor(r.y/world.tileset.tileSizeY), d_util.ceil(r.w/world.tileset.tileSizeX), d_util.ceil(r.h/world.tileset.tileSizeY)
  x2, y2 := x + w, y + h
  inity := y
  tangents := []Tangent{}

  for x <= x2 {
    y = inity
    for y <= y2 {
      tile := world.getTile(0, x, y)
      if tile > 0 {
        tangents = append(tangents, Tangent{x, y, tile})
      }
      y++
    }
    x++
  }

  return tangents
}

fn (world: ^World) drawLayer*(pan: th.Vf2, layerId: int, scale: real = 1.0) {
  layerId++
  if layerId < 0 || layerId > 2 {
    return
  }
  
  layer := &world.tilemap[layerId]
  tileSizeX := world.tileset.tileSizeX 
  tileSizeY := world.tileset.tileSizeY

  // TODO: Just don't draw tiles we don't need to draw.
  for pos in layer {
    chunk := &layer[pos]
    initialTransform := th.Transform{p: th.Vf2{(pos.x*chunkW*tileSizeX-pan.x)*scale, (pos.y*chunkH*tileSizeY-pan.y)*scale}, s: th.Vf2{scale*world.tileset.scale, scale*world.tileset.scale}}
    transform := initialTransform
    
    for cx := 0; cx < chunkW; cx++ {
      transform.p.y = initialTransform.p.y
      for cy := 0; cy < chunkH; cy++ {
        if chunk[cx][cy] > 0 {
          world.tileset.selectTilePos(chunk[cx][cy])
          world.tileset.image.draw(transform)
        }
        transform.p.y += tileSizeY*scale
      }
      transform.p.x += tileSizeX*scale
    }
  }
}

fn (world: ^World) draw*(pan: th.Vf2) {
  for i := -1; i < 2; i++ {
    world.drawLayer(pan, i)
  }
}

