/*
// Draw commands.
*/

import ("th.um"; "window.um"; "rect.um"; "image.um"; "font.um"; "canvas.um")

type (
  DrawProperties* = struct{}

  CustomCommand* = interface {
    draw(props: DrawProperties): void
  }

  Command = struct {
    kind: int
    rect: rect.Rect
    color: uint32
    custom: CustomCommand
  }

  Layer = struct {
    commands: []Command
    commandsLen: uint
  }

  DrawContext* = struct {
    currentLayer: ^Layer
    layerOrder: []int
    layers: map[int]^Layer
  }
)

const (
  commandRect   = 0
  commandBeginScissorRect = 1
  commandEndScissor = 2
  commandCustom = 255
)

fn (lay: ^Layer) appendCommand(cmd: Command) {
  // Buffered allocations. Currently umka reallocates the entire array
  // after every insert which is really taxing.
  if lay.commandsLen & 127 == 0 {
    var newCommands: [128]Command
    lay.commands = append(lay.commands, newCommands)
  }

  lay.commands[lay.commandsLen] = cmd
  lay.commandsLen++
}

fn (ctx: ^DrawContext) acquireLayer(layer: int) {
  // Insert the layer ordering at the correct spot.

  if (validkey(ctx.layers, layer)) {
    return
  }

  insertIndex := 0
  for i in ctx.layerOrder {
    if ctx.layerOrder[i] > layer {
      insertIndex = i
      break
    } else {
      insertIndex = i+1
    }
  }

  ctx.layers[layer] = new(Layer)
  ctx.layers[layer].commands = make([]Command, 0)
  ctx.layerOrder = insert(ctx.layerOrder, insertIndex, layer)
}


fn init*(): DrawContext {
  ctx := DrawContext{layerOrder: []int{}, layers: map[int]^Layer{}}
  ctx.acquireLayer(0)
  ctx.currentLayer = ctx.layers[0]
  return ctx
}


fn (ctx: ^DrawContext) setLayer*(layer: int) {
  ctx.acquireLayer(layer)
  ctx.currentLayer = ctx.layers[layer]
}

/*
// DrawContext.Flush()
//
// Flushes all the layers and commands, outputting them onto the screen.
*/
fn (ctx: ^DrawContext) flush*() {
  for _, i in ctx.layerOrder {
    layer := ctx.layers[i]

    for j := 0; j < layer.commandsLen; j++ {
      command := &layer.commands[j]

      switch command.kind {
        case commandRect:
          canvas.drawRect(command.color, command.rect)
        case commandBeginScissorRect:
          window.beginScissorRect(command.rect)
        case commandEndScissor:
          window.endScissor()
        case commandCustom:
          command.custom.draw(DrawProperties{})
      }
    } 
  }

  ctx ^= init()
}

type TextCmd = struct {
  font: font.Font
  text: str
  pos: th.Vf2
  color: uint32
  size: real
}

fn (d: ^TextCmd) draw(props: DrawProperties) {
  d.font.draw(d.text, d.pos, d.color, d.size)
}

fn (ctx: ^DrawContext) drawText*(f: font.Font, text: str, position: th.Vf2, color: uint32, size: th.fu = 1.0) {
  command := Command{kind: commandCustom, custom: TextCmd{f, text, position, color, size}}

  ctx.currentLayer.appendCommand(command)
}

fn (ctx: ^DrawContext) drawRect*(color: uint32, r: rect.Rect) {
  command := Command{kind: commandRect, color: color, rect: r}

  ctx.currentLayer.appendCommand(command)
}

fn (ctx: ^DrawContext) beginScissorRect*(r: rect.Rect) {
  ctx.currentLayer.appendCommand(Command{kind: commandBeginScissorRect, rect: r})
}

fn (ctx: ^DrawContext) endScissor*() {
  ctx.currentLayer.appendCommand(Command{kind: commandEndScissor})
}

type ImageCmd = struct {
  image: image.Image
  transform: th.Transform
  quadCrop: th.Quad
  tint: uint32
}

fn (d: ^ImageCmd) draw(props: DrawProperties) {
  d.image.cropQuad(d.quadCrop)
  d.image.draw(d.transform, d.tint)
}

fn (ctx: ^DrawContext) drawImage*(img: image.Image, transform: th.Transform, color: uint32 = 0xFFFFFFFF) {
  ctx.currentLayer.appendCommand(Command{kind: commandCustom, custom: ImageCmd{img, transform, img.getCropQuad(), color}})
}

type NinepatchCmd = struct {
  image: image.Image
  outer, inner, dest: rect.Rect
  quadCrop: th.Quad
  tint: uint32
}

fn (d: ^NinepatchCmd) draw(props: DrawProperties) {
  d.image.cropQuad(d.quadCrop)
  d.image.drawNinepatch(d.outer, d.inner, d.dest, d.tint)
}

fn (ctx: ^DrawContext) drawNinepatch*(img: image.Image, outer, inner, dest: rect.Rect, tint: uint32 = th.white) {
  ctx.currentLayer.appendCommand(Command{kind: commandCustom, custom: NinepatchCmd{img, outer, inner, dest, img.getCropQuad(), tint}})
}

fn (ctx: ^DrawContext) drawCustom*(custom: CustomCommand) {
  command := Command{kind: commandCustom, custom: custom}

  ctx.currentLayer.appendCommand(command)
}