// Entry point for the editor.
// (C) skejeton

import (
  "e_drawcmd.um"
  
  "../d_global.um";
  "../d_background.um"; "../d_colors.um"; "../d_world.um";
  "../d_tileset.um"; "../d_test.um"; "../d_util.um"; "../d_mouseinput.um";
  "../d_game.um"; "../d_script.um";

  th_font = "font.um"; th_color = "color.um"; 

  "window.um"; "rect.um"; "th.um"; "image.um"; "canvas.um"; "input.um"
)

type (
  EditorGrid = struct {
    scaling: real
    panning: th.Vf2
  }

  ToolNode = struct {
    children: map[str]^ToolNode
    parent: ^ToolNode
    lastFrameTouched: int
    layer: int
    rect: rect.Rect
  }

  ButtonState = struct {
    isOver: bool
    isDown: bool
    isPressed: bool
    isReleased: bool
  }

  Window = struct {
    lastFrameTouched: int
    isVisible: bool
    rect: rect.Rect
    layer: int
  }

  WindowManager = struct {
    topmostWindowLayer: int
    frameNumber: int
    windowCount: int
    windows: map[str]Window
  }

  Editor = struct {
    // Misc
    isDebugOverlayShown: bool
    frameNumber: int

    // Visual data
    ctx: e_drawcmd.DrawContext
    mainFont: th_font.Font

    // Editors
    tileGrid: EditorGrid
    tilemapGrid: EditorGrid
    tilemapLayer: int
    tilemapShowAllLayers: bool
    tileSelected: th.Vf2
    tileset: d_tileset.Tileset
    world: d_world.World
    isPlaying: bool
    isRelocatingPlayer: bool

    // UI misc.
    currentWindow: str
    currentWindowLayer: int
    wm: WindowManager

    // Input
    mouseState: d_mouseinput.MouseState

    // Census
    tools: ^ToolNode
    currentTool: ^ToolNode
    maybeActiveTool: ^ToolNode
    activeTool: ^ToolNode
  }
)

var (
  bevelImage: image.Image
  toolbarIcons: image.Image
)

fn initWindowManager(): WindowManager {
  return WindowManager{windows: map[str]Window{}}
}

fn (wm: ^WindowManager) isWindowVisible(name: str): bool {
  return validkey(wm.windows, name) && wm.windows[name].lastFrameTouched == wm.frameNumber && wm.windows[name].isVisible
}

fn (wm: ^WindowManager) getWindowRect(name: str, fallback: rect.Rect): ^rect.Rect {
  if validkey(wm.windows, name) {
    wm.windows[name].lastFrameTouched = wm.frameNumber
    return &wm.windows[name].rect
  } 

  // Create window.
  wm.windowCount += 1
  wm.windows[name] = Window{isVisible: true, rect: fallback, lastFrameTouched: wm.frameNumber}
  return &wm.windows[name].rect
}

fn (wm: ^WindowManager) getWindowLayer(name: str): int {
  if validkey(wm.windows, name) {
    return wm.windows[name].layer 
  } 
  return -1
}

fn (wm: ^WindowManager) putWindowOnFront(name: str) {
  if validkey(wm.windows, name) {
    wm.topmostWindowLayer += 1
    wm.windows[name].layer = wm.topmostWindowLayer
  }
}

fn (wm: ^WindowManager) setWindowVisible(name: str, to: bool) {
  if validkey(wm.windows, name) {
    wm.windows[name].isVisible = to
  } 
}

fn (e: ^Editor) acquireToolNode(name: str): ^ToolNode {
  if e.currentTool == null {
    e.currentTool = e.tools
  }

  if !validkey(e.currentTool.children, name) {
    tool := new(ToolNode)
    tool ^= ToolNode{children: map[str]^ToolNode{}, parent: e.currentTool}
    e.currentTool.children[name] = tool
  }

  return e.currentTool.children[name]
}

// Prunes all tools untouched last frame
fn (e: ^Editor) pruneToolsRecursive(node: ^ToolNode) {
  for key in node.children {
    e.pruneToolsRecursive(node.children[key])

    if node.children[key].lastFrameTouched < e.frameNumber {
      node.children = delete(node.children, key)

      // Fix leak
      node.parent = null
    }

  }
}

fn (e: ^Editor) beginTool(name: str, toolRect: rect.Rect): ^ToolNode {
  node := e.acquireToolNode(name)
  node.lastFrameTouched = e.frameNumber
  node.rect = toolRect
  node.layer = e.ctx.currentLayerId

  e.currentTool = node
  isOverMaybeActiveTool := true

  if e.maybeActiveTool != null {
    isOverMaybeActiveTool = node.layer >= e.maybeActiveTool.layer
  }

  if isOverMaybeActiveTool && d_util.rectVsPoint(node.rect, e.mouseState.pos) {
    e.maybeActiveTool = node
  }

  return e.currentTool
}

fn (e: ^Editor) endTool() {
  if e.currentTool.parent == null {
    error("Parent node is null, beginTool/endTool mismatched!")
  }
  e.currentTool = e.currentTool.parent
}

fn (e: ^Editor) isCurrentToolActive(): bool {
  return e.activeTool == e.currentTool
}

/*
// QueryMouse()
// 
// Queries mouse button `btn` if it has the `which` property set.
// Returns false if the current tool is not focused.
//
// `btn` maybe be on of the following values:
//   0 :: Left mouse button
//   1 :: Middle mouse button
//   2 :: Right mouse button
//
// `which` may be one of those values:
//   d_mouseinput.down     :: IsDown
//   d_mouseinput.pressed  :: IsPressed
//   d_mouseinput.released :: IsReleased
*/
fn (e: ^Editor) queryMouse(btn: int, which: int): bool {
  if e.isCurrentToolActive() == false {
    return false
  }

  var mouseButton: d_mouseinput.MouseButtonState

  switch btn {
    case 0: mouseButton = e.mouseState.lmb
    case 1: mouseButton = e.mouseState.mmb
    case 2: mouseButton = e.mouseState.rmb
    default: error(sprintf("Invalid mouse button index %d", btn))
  }

  switch which {
    case d_mouseinput.down: return mouseButton.isDown
    case d_mouseinput.pressed: return mouseButton.isPressed
    case d_mouseinput.released: return mouseButton.isReleased
    default: error(sprintf("Invalid mouse button property index %d", which))
  }
  return false;
}

// Draw bevel rect(
//   Rectangle to draw,
//   Does rectangle look pushed in,
//   Color tint, the iconic gray is the default
// )
//
// Draws a beveled rectangle in Windows 98 style.
// It may have a problem with displaying colors somewhat incorrectly,
//   because the middle of the rectangle is tinted gray slightly.
fn drawBevelRect(ctx: ^e_drawcmd.DrawContext, r: rect.Rect, pushed: bool = false, color: uint32 = th.white) {
  const (
    bevelOuterRect = rect.Rect{0, 0, 5, 5}
    bevelInnerRect = rect.Rect{2, 2, 1, 1}
   
    bevelPushedOuterRect = rect.Rect{5, 0, 5, 5}
    bevelPushedInnerRect = rect.Rect{2, 2, 1, 1}
  )

  if pushed {
    ctx.drawNinepatch(bevelImage, bevelPushedOuterRect, bevelPushedInnerRect, r, color)
  } else {
    ctx.drawNinepatch(bevelImage, bevelOuterRect, bevelInnerRect, r, color)
  }
}

// Vf2 granulate(
//   Vector to granulate
//   The granulation sizes
// )
// 
// Granulation is making number A a multiple of B by rounding.
// This boy does same thing but for vectors, so `th.Vf2{Granulate(A.x, B.x), Granulate(A.y, B.y)}`.
fn vf2Granulate(a, b: th.Vf2): th.Vf2 {
  return a.div(b).floor().mul(b)
}

// Vf2 int modulo(
//   Divident
//   Divisor
// )
// 
// Performs an integer (!!!) modulo operator on scalars of vector a wrt b
// All floating point is lost.
fn vf2IntMod(a, b: th.Vf2): th.Vf2 {
  return th.Vf2{trunc(a.x)%trunc(b.x), trunc(a.y)%trunc(b.y)}
}

// Draw text centered(
//   The font
//   The text
//   The color
//   The rect to center in
// )
fn centerTextWithinRect(font: th_font.Font, text: str, r: rect.Rect): th.Vf2 {
  return r.getDims().sub(font.measure(text)).divf(2.0).add(r.getPos())
}

// TODO: Ability to pass colour
fn drawButton(ctx: ^e_drawcmd.DrawContext, r: rect.Rect, buttonState: ButtonState, revert: bool = false) {
  pushed := buttonState.isDown != revert

  colorMod := 0xFFFFFFFF
  if pushed {
    colorMod = 0xCCCCCCFF
  }

  drawBevelRect(ctx, r, pushed, colorMod)
}

fn putButton(editor: ^Editor, r: rect.Rect, name: str): ButtonState {
  editor.beginTool(name,  r)

  buttonState := ButtonState{}

  if (editor.isCurrentToolActive()) {
    buttonState.isOver = true;
    buttonState.isDown = editor.mouseState.lmb.isDown||editor.mouseState.lmb.isReleased;
    buttonState.isPressed = editor.mouseState.lmb.isPressed;
    buttonState.isReleased = editor.mouseState.lmb.isReleased && d_util.rectVsPoint(r, editor.mouseState.pos);
  }

  editor.endTool()
  return buttonState
}

fn putButtonBase(editor: ^Editor, r: rect.Rect, name: str, revert: bool = false): ButtonState {
  bs := putButton(editor, r, name)
  drawButton(&editor.ctx, r, bs, revert)
  return bs
}

fn uiBeginWindow(editor: ^Editor, title: str, r: rect.Rect): (rect.Rect, bool) {
  const (
    padding = 2
    titlebarHeight = 18
  )

  var (
    contentRect: rect.Rect
    movement: th.Vf2
  )

  windowRect := editor.wm.getWindowRect(title, r)


  if !editor.wm.isWindowVisible(title) {
    return rect.mk(0, 0, 0, 0), false
  }
  if editor.currentWindow != "" {
    error("BeginWindow is called before EndWindow")
  }

  editor.currentWindow = title
  // FIXME: This is a hack around windows being able to change their layers mid drawing.
  //        Which would de-sync the results from getWindowLayer.
  editor.currentWindowLayer = editor.wm.getWindowLayer(title)

  position := th.Vf2{padding, padding}

  editor.ctx.moveLayer(1000*editor.currentWindowLayer)
  // Frame tool.
  editor.beginTool(title, windowRect^)
  {
    drawBevelRect(&editor.ctx, windowRect^)

    buttonSize := th.Vf2{20, titlebarHeight}
    buttonRect := rect.mk(position.x+windowRect.x, position.y+windowRect.y, buttonSize.x, buttonSize.y)

    if (putButtonBase(editor, buttonRect, "Close").isReleased) {
      editor.wm.setWindowVisible(title, false)
    }

    editor.ctx.drawRect(th.black, rect.mk(position.x+windowRect.x+5, position.y+windowRect.y+titlebarHeight/2-1, buttonSize.x-10, 2))
    position.x += buttonSize.x + padding

    {
      handleSize := th.Vf2{windowRect.w - position.x - padding, titlebarHeight}
      rectangle := rect.mk(position.x+windowRect.x, position.y+windowRect.y, handleSize.x-1, handleSize.y)

      // Titlebar tool.
      editor.beginTool("Titlebar", rectangle)
      {
        if (editor.queryMouse(0, d_mouseinput.pressed)) {
          editor.wm.putWindowOnFront(title)
        }
        if (editor.queryMouse(0, d_mouseinput.down)) {
          movement = editor.mouseState.delta
        }
      }
      editor.endTool()

      editor.ctx.drawRect(0x000077FF, rectangle)
      editor.ctx.beginScissorRect(rectangle)
        editor.ctx.drawText(editor.mainFont, title, centerTextWithinRect(editor.mainFont, title, rectangle), th.white)
      editor.ctx.endScissor()
    
      position.x += handleSize.x + padding
    }

    position.x = 1
    position.y += titlebarHeight + 1

    contentSize := th.Vf2{windowRect.w - position.x - padding, windowRect.h - position.y - padding}
    contentRect = rect.mk(position.x+windowRect.x, position.y+windowRect.y, contentSize.x-1, contentSize.y-1)

    editor.beginTool("Body", contentRect)
    {
      if (editor.queryMouse(0, d_mouseinput.pressed)) {
        editor.wm.putWindowOnFront(title)
      }
      if (editor.queryMouse(0, d_mouseinput.down)) {
        movement = editor.mouseState.delta
      }
    }
  }

  windowRect ^= d_util.rectMove(windowRect^, movement)

  return contentRect, true
}

fn uiEndWindow(editor: ^Editor) {
  if editor.currentWindow == "" {
    error("EndWindow has no match with BeginWindow")
  }

  title := editor.currentWindow
  squishing := th.Vf2{0, 0} // Same as movement but changes the window size
  windowRect := editor.wm.getWindowRect(title, rect.mk(0, 0, 0, 0))

  // Finish ui tools.
  {
      editor.endTool()

      gripSize := th.Vf2{10, 10};
      gripRect := rect.mk(windowRect.x+windowRect.w-gripSize.x, windowRect.y+windowRect.h-gripSize.y, gripSize.x, gripSize.y)
      editor.beginTool("Grip", gripRect)
      {
        if (editor.queryMouse(0, d_mouseinput.down)) {
          squishing = editor.mouseState.delta
        }
      }
      editor.endTool()
    editor.endTool()
  }
  editor.ctx.moveLayer(-1000*editor.currentWindowLayer)

  windowRect.w += squishing.x; windowRect.h += squishing.y;
  // Clamp
  if windowRect.w < 100 {
    windowRect.w = 100
  }
  if windowRect.h < 100 {
    windowRect.h = 100
  }

  editor.currentWindow = ""
}


fn (ge: ^EditorGrid) mapPos(rectangle: rect.Rect, pos: th.Vf2): th.Vf2 {
  return ge.panning.mulf(ge.scaling).add(pos).add(rectangle.getPos()).add(rectangle.getDims().divf(2))
}

// Puts editor grid spanning the entire screen
// TODO: Fix scaling
fn (ge: ^EditorGrid) put(editor: ^Editor, rectangle: rect.Rect): th.Vf2 {
  const (
    lineColor = th.white&0xFFFFFF11
    tileColor = th.white&0xFFFFFF22
    debugColor = th.red&0xFFFFFF00
  )

  var (
    scale: real = ge.scaling
    tileSize: real = 32*scale
    tileSizes: th.Vf2 = th.Vf2{tileSize, tileSize}

    mousePos: th.Vf2 = editor.mouseState.pos.sub(rectangle.getPos())
    mouseDelta: th.Vf2 = editor.mouseState.delta
  )

  if editor.isCurrentToolActive() {
    // Handle input
    if editor.mouseState.mmb.isDown {
      ge.panning = ge.panning.add(mouseDelta.divf(scale))
    }
  }

  var (
    // This is the panning :P
    offset: th.Vf2 = ge.panning.add(rectangle.getDims().divf(2)).mulf(scale)

    // This is panning but adjusted so that it wraps around every TileSize'th time
    visualOffset: th.Vf2 = vf2IntMod(offset, tileSizes)

    highlightedTileWorldPosition: th.Vf2 = mousePos.sub(offset)
    highlightedTileScreenPosition: th.Vf2 = vf2Granulate(highlightedTileWorldPosition, tileSizes).add(offset).add(rectangle.getPos())
    highlightedTileRect: rect.Rect = rect.mk(highlightedTileScreenPosition.x, highlightedTileScreenPosition.y, tileSize, tileSize)
  )

  editor.ctx.beginScissorRect(rectangle)

  // Draw background (debug)
  editor.ctx.drawRect(debugColor, rectangle)

  // Draw grid
  for y := visualOffset.y; y < rectangle.h; y += tileSize {
    lineRect := rect.mk(round(rectangle.x), round(rectangle.y + y), rectangle.w, 1)
    editor.ctx.drawRect(lineColor, lineRect)
  }

  for x := visualOffset.x; x < rectangle.w; x += tileSize {
    lineRect := rect.mk(round(rectangle.x + x), round(rectangle.y), 1, rectangle.h)
    editor.ctx.drawRect(lineColor, lineRect)
  }

  if editor.isCurrentToolActive() {
    // Draw highlighted tile
    editor.ctx.drawRect(tileColor, highlightedTileRect)
  }

  coordinate := ge.panning.mulf(-1).div(tileSizes).floor()
  coordinateString := sprintf("%+-4g %+-4g", coordinate.x, coordinate.y)

  bottomLeft := th.Vf2{rectangle.x, rectangle.y+rectangle.h}
  bottomLeft.y -= editor.mainFont.measure(coordinateString).y
  editor.ctx.drawText(editor.mainFont, coordinateString, bottomLeft, th.white)

  editor.ctx.endScissor()

  return highlightedTileWorldPosition.div(tileSizes).floor()
}

fn putIconButton(editor: ^Editor, name: str, r: rect.Rect, img: image.Image, revert: bool = false): ButtonState {
  bs := putButtonBase(editor, r, name, revert)
  editor.ctx.drawImage(img, th.Transform{p: th.Vf2{r.x, r.y}, s: th.Vf2{1, 1}})
  return bs
}

fn putSimpleButton(editor: ^Editor, r: rect.Rect, text: str, revert: bool = false): ButtonState {
  bs := putButtonBase(editor, r, text, revert)
  editor.ctx.drawText(editor.mainFont, text, centerTextWithinRect(editor.mainFont, text, r), th.black)
  return bs
}

const worldPath = "data/sc00_nowayup.csv"

fn editorLoadWorld(editor: ^Editor) {
  if ok, data := d_util.readFileStr(worldPath); ok {
    editor.world.load(data)
  }
}

fn editorSaveWorld(editor: ^Editor) {
  d_util.writeFileStr(worldPath, editor.world.save())
}

fn editorToggleGame(editor: ^Editor) {
  if (!editor.isPlaying) {
    d_game.world = editor.world
    d_game.start()
    d_script.init()
  }
  editor.isPlaying = !editor.isPlaying
} 

// Puts window toolbar on the bottom of the screen
fn editorPutToolbar(editor: ^Editor) {
  const (
    margin = 0
    padding = 1
    rectangleHeight = 32 + margin * 2 + padding * 2
  )

  rectangle := rect.Rect{margin, d_global.screen.h - rectangleHeight + margin, d_global.screen.w - margin * 2, rectangleHeight - margin * 2}

  editor.beginTool("ToolBar", rectangle)
  {
    drawBevelRect(&editor.ctx, rectangle, false)

    buttonRectangle := rect.mk(rectangle.x+padding, rectangle.y+padding, rectangle.h-padding*2, rectangle.h-padding*2)

    toolbarIcons.crop(th.Vf2{0.25, 0.25}, th.Vf2{0.50, 0.50})
    if (putIconButton(editor, "Play", buttonRectangle, toolbarIcons, editor.isPlaying).isReleased) {
      editorToggleGame(editor)
    }

    buttonRectangle.x += buttonRectangle.w + margin


    {
      toolbarIcons.crop(th.Vf2{0.0, 0.25}, th.Vf2{0.25, 0.50})
      isVisible := editor.wm.isWindowVisible("Tile Picker")
      if (putIconButton(editor, "Tile Picker", buttonRectangle, toolbarIcons, isVisible).isReleased) {
        editor.wm.setWindowVisible("Tile Picker", !isVisible)
      }
      buttonRectangle.x += buttonRectangle.w + margin
    }

    {
      toolbarIcons.crop(th.Vf2{3.0/4.0, 1.0/4.0}, th.Vf2{4.0/4.0, 2.0/4.0})
      isVisible := editor.wm.isWindowVisible("Player Placer")
      if (putIconButton(editor, "Player Placer", buttonRectangle, toolbarIcons, isVisible).isReleased) {
        editor.wm.setWindowVisible("Player Placer", !isVisible)
      }
      buttonRectangle.x += buttonRectangle.w + margin
    }


    // Draw Save/Load
    {
      position := rectangle.getEnd()
      position.y -= rectangle.h
      
      position.x -= 80
      if (putSimpleButton(editor, rect.mk(position.x, position.y, 80, rectangle.h), "Save").isReleased) {
        editorSaveWorld(editor)
      }

      position.x -= 80
      if (putSimpleButton(editor, rect.mk(position.x, position.y, 80, rectangle.h), "Load").isReleased) {
        editorLoadWorld(editor)
      }
    }
  }
  editor.endTool()
}

fn editorInit(): Editor {
  rootNode := new(ToolNode)
  rootNode ^= ToolNode{children: map[str]^ToolNode{}}


  tilesetImage := image.load("data/ts00_sky.png")
  if tilesetImage.validate() == false {
    error("Couldn't load tileset image.")
  }
  tilesetImage.setfilter(0)
  tileset := d_tileset.fromImage(tilesetImage, 32, 32)
  world := d_world.fromTileset(tileset)

  result := Editor{
    ctx: e_drawcmd.init(),
    tileGrid: EditorGrid{scaling: 1.0},
    tilemapGrid: EditorGrid{scaling: 1.0},
    tilemapShowAllLayers: true,
    tileset: tileset,
    world: world,
    wm: initWindowManager(),
    mainFont: th_font.load("data/font_mono.ttf", 16),
    tools: rootNode}

  editorLoadWorld(&result)
  result.tileGrid.panning = result.world.playerSpawnPos.mulf(-32)
  return result
}

fn putEditorDebugToolFramesRecursive(editor: ^Editor, tool: ^ToolNode, prefix: str = "") {
  font := editor.mainFont

  for toolName, toolChild in tool.children {
    baseColor := th.red
    if editor.activeTool == toolChild {
      baseColor = th.green
    }

    toolName = prefix + toolName

    // NOREP(PlaneText,TextRect,MeasureText,ColorAlpha,RectFrom2Vec2f)
    if editor.activeTool == toolChild {
      planeSize := font.measure(toolName)
      r := rect.mk(toolChild.rect.x, toolChild.rect.y-planeSize.y, planeSize.x, planeSize.y)
      r = d_util.rectKeepInBounds(r, rect.mk(0, 0, d_global.screen.w, d_global.screen.h))
      if r.y < 0 {
        r.y += planeSize.y
      }
      canvas.drawRect(baseColor&0xFFFFFFAA, r)
      font.draw(toolName, r.getPos(), th.white)
    }
    d_util.drawRectLines(baseColor, toolChild.rect)

    putEditorDebugToolFramesRecursive(editor, toolChild, toolName+"::")
  }
}

fn putEditorDebugToolFrames(editor: ^Editor) {
  putEditorDebugToolFramesRecursive(editor, editor.tools)
}

fn isAnyButtonHeld(mouseState: ^d_mouseinput.MouseState): bool {
  return mouseState.lmb.isDown || mouseState.mmb.isDown || mouseState.rmb.isDown
} 

type WorldEditCmd = struct {
  showLayers: uint // 3 bits
  rect: rect.Rect
  offset: th.Vf2
  world: ^d_world.World
}

fn (d: ^WorldEditCmd) draw(props: e_drawcmd.DrawProperties) {
  d_background.draw(d.rect)
  if (d.showLayers & 1 > 0) {
    d.world.drawLayer(d.offset, -1)
  }
  if (d.showLayers & 2 > 0) {
    d.world.drawLayer(d.offset, 0)
  }
  if (d.showLayers & 4 > 0) {
    d.world.drawLayer(d.offset, 1)
  }

  toolbarIcons.crop(th.Vf2{2.0/4.0, 0.0/4.0}, th.Vf2{3.0/4.0, 1.0/4.0})
  pos := d.world.playerSpawnPos.mulf(32).sub(d.offset)
  toolbarIcons.draw(d_util.posTrans(pos.x, pos.y))
}

fn getShownLayersBitmap(layerSelected: int, showAllLayers: bool): uint {
  return 1<<(layerSelected+1)|(int(showAllLayers)*0x7)
}

fn drawLayerIcon(ctx: ^e_drawcmd.DrawContext, position: th.Vf2, layer: int, showAllLayers: bool) {
  fills := [3]bool{layer == -1, layer == 0, layer == 1}

  // NOTE: If we choose to show all layers, the icon will show all boxes filled in
  if showAllLayers {
    fills = [3]bool{true, true, true}
  }

  position.x += 26

  for i, l in fills {
    rec := rect.Rect{position.x-20, position.y, 20, 12}
    position.x -= 2
    position.y += 4

    if l {
      ctx.drawRect(0xf0b5afFF, rec)
      ctx.drawRectLines(0xFFFFFFFF, rec)
    } else {
      ctx.drawRect(d_colors.cPrimary, rec)
      ctx.drawRectLines(0xFFFFFFFF, rec)
    }
  }
}

type GameCmd = struct {}

fn (gc: ^GameCmd) draw(props: e_drawcmd.DrawProperties) {
  d_background.draw(rect.mk(0, 0, d_global.screen.w, d_global.screen.h))
  d_game.draw()
}

fn editorPutUi(editor: ^Editor) {

  editor.mouseState = editor.mouseState.updated()

  editor.frameNumber += 1;

  // put ui
  if editor.isPlaying {
    d_game.update()
    d_script.update()

    editor.ctx.drawCustom(GameCmd{})
  } else {
    tool := editor.beginTool("TileEditor", rect.mk(0, 0, d_global.screen.w, d_global.screen.h-34))

    selectedTile := editor.tileGrid.put(editor, tool.rect)

    if editor.isRelocatingPlayer {
      if (editor.queryMouse(0, d_mouseinput.down)) {
        editor.world.playerSpawnPos = selectedTile
      }
      if (editor.queryMouse(0, d_mouseinput.released)) {
        editor.isRelocatingPlayer = false
      }
    } else {
      if editor.queryMouse(0, d_mouseinput.down) {
        editor.world.setTile(editor.tilemapLayer, trunc(selectedTile.x), trunc(selectedTile.y), editor.tileset.tileToPos(trunc(editor.tileSelected.x), trunc(editor.tileSelected.y)))
      }
      if editor.queryMouse(2, d_mouseinput.down) {
        editor.world.setTile(editor.tilemapLayer, trunc(selectedTile.x), trunc(selectedTile.y), 0)
      }
    }

    // Draw ToggleAll/FG/MG/BG buttons.
    {
      const padding = 10
      const elementSize = 30

      position := tool.rect.getEnd().subf(padding).subf(elementSize)

      if (putSimpleButton(editor, rect.mk(position.x, position.y, elementSize, elementSize), "BG", editor.tilemapLayer == -1).isReleased) {
        editor.tilemapLayer = -1
      }
      position.x -= elementSize

      if (putSimpleButton(editor, rect.mk(position.x, position.y, elementSize, elementSize), "MG", editor.tilemapLayer == 0).isReleased) {
        editor.tilemapLayer = 0
      }
      position.x -= elementSize

      if (putSimpleButton(editor, rect.mk(position.x, position.y, elementSize, elementSize), "FG", editor.tilemapLayer == 1).isReleased) {
        editor.tilemapLayer = 1
      }
      position.x -= elementSize

      if (putSimpleButton(editor, rect.mk(position.x, position.y, elementSize, elementSize), "", editor.tilemapShowAllLayers).isReleased) {
        editor.tilemapShowAllLayers = !editor.tilemapShowAllLayers
      }
      drawLayerIcon(&editor.ctx, position.add(th.Vf2{1, 5}), editor.tilemapLayer, editor.tilemapShowAllLayers)
      position.x -= elementSize
    }

    editor.ctx.moveLayer(-1)
    editor.ctx.drawCustom(WorldEditCmd{getShownLayersBitmap(editor.tilemapLayer, editor.tilemapShowAllLayers), tool.rect, editor.tileGrid.mapPos(tool.rect, th.Vf2{0, 0}).mulf(-1), &editor.world})
    editor.ctx.moveLayer(1)

    editor.endTool()
  }
  editorPutToolbar(editor)

  if !editor.isPlaying {
    if contentRect, ok := uiBeginWindow(editor, "Player Placer", rect.mk(30, 30+32*7+20, 32*5, 32*7)); ok { 
      contentRect = d_util.rectShrink(contentRect, 5)
      position := contentRect.getPos()
      playerPos := editor.world.playerSpawnPos

      editor.ctx.beginScissorRect(contentRect)
      {
        text := sprintf("Player at: %d %d", trunc(playerPos.x), trunc(playerPos.y))
        editor.ctx.drawText(editor.mainFont, text, position, th.black)
        position.y += editor.mainFont.measure(text).y+10

        if (putSimpleButton(editor, rect.mk(position.x, position.y, contentRect.w, 30), "Relocate", editor.isRelocatingPlayer).isReleased) {
          editor.isRelocatingPlayer = !editor.isRelocatingPlayer
        }
        position.y += 30+10

        if (editor.isRelocatingPlayer) {
          editor.ctx.drawText(editor.mainFont, "Click on the grid\nTo place player.", position, th.black)
        }
      }
      editor.ctx.endScissor()
      uiEndWindow(editor)
    }

    if contentRect, ok := uiBeginWindow(editor, "Tile Picker", rect.mk(30, 30, 32*5, 32*7)); ok { 
      editor.ctx.drawRect(th.black, contentRect)
      editor.ctx.moveLayer(1)
      {
        selectedTile := editor.tilemapGrid.put(editor, contentRect)

        // NOT-SURE: Currently you can only have one active window,
        //             it's the window furthest in the hierarchy your mouse is over (roughly).
        //           We need to create the TilePicker tool manually for that reason, because if EditorGrid did,
        //             we wouldn't be able to query the mouse here. That means right now EditorGrid.put uses the current tool
        //             instead of creating a new one. This seems alright for now, but it might be done differently
        //             later.
        if editor.queryMouse(0, d_mouseinput.down) {
          editor.tileSelected = selectedTile
        }

        selectedTilePos := editor.tilemapGrid.mapPos(contentRect, editor.tileSelected.mulf(32))
        
        editor.ctx.beginScissorRect(contentRect)
        editor.ctx.drawRect(th_color.alpha(th.green, 0.3), rect.mk(selectedTilePos.x, selectedTilePos.y, 32, 32))
        editor.ctx.endScissor()
      }
      editor.ctx.moveLayer(-1)
      editor.ctx.beginScissorRect(contentRect)

      editor.tileset.image.crop(th.Vf2{0, 0}, th.Vf2{1, 1})
      editor.ctx.drawImage(editor.tileset.image, th.Transform{s: th.Vf2{1, 1}, p: editor.tilemapGrid.mapPos(contentRect, th.Vf2{0, 0})})
      editor.ctx.endScissor()

      uiEndWindow(editor)
    }
  }

  if editor.isRelocatingPlayer {
    editor.ctx.moveLayer(100000)
    toolbarIcons.crop(th.Vf2{2.0/4.0, 0.0/4.0}, th.Vf2{3.0/4.0, 1.0/4.0})
    editor.ctx.drawImage(toolbarIcons, d_util.posTrans(editor.mouseState.pos.x, editor.mouseState.pos.y))
    editor.ctx.moveLayer(-100000)
  }

  // flush render context
  editor.ctx.flush()
 
  // put debug overlays
  if (editor.isDebugOverlayShown) {
    putEditorDebugToolFrames(editor)
  }

  // handle post input states
  if (input.isJustPressed(input.key_escape)) {
    editor.isDebugOverlayShown = !editor.isDebugOverlayShown
  }

  // swap frame census
  if !isAnyButtonHeld(&editor.mouseState) {
    editor.activeTool = editor.maybeActiveTool
  }
  editor.maybeActiveTool = null
  editor.pruneToolsRecursive(editor.tools)
}

// Disconnects all nodes in the editor from their parents.
// Due to how the Umka GC currently works, it's not able to collect
//   circular references, so I must do it myself.
fn editorDisconnectAllNodes(editor: ^Editor, node: ^ToolNode) {
  if node == null {
    node = editor.tools
  }

  node.parent = null
  for _, child in node.children {
    editorDisconnectAllNodes(editor, child)
  }
}

fn editorMain*() {
  d_test.itsNotAUnitTest()

  d_global.screen = rect.mk(0, 0, 640, 480)
  window.setup("Cool editor nice", 640, 480)

  // init data
  bevelImage = image.load("data/ts04_bevelbutton.png")
  if bevelImage.validate() == false {
    error("Couldn't load bevel image.")
  }
  bevelImage.setfilter(0)

  toolbarIcons = image.load("data/ts02_trayicons.png")
  if toolbarIcons.validate() == false {
    error("Couldn't load toolbar icons image.")
  }
  toolbarIcons.setfilter(0)

  d_background.init()

  editor := editorInit()

  // cycle
  for window.cycle(d_global.screen) {
    //screen.w = window.w
    //screen.h = window.h

    canvas.drawRect(th.black, d_global.screen)
    editorPutUi(&editor)
  }

  editorDisconnectAllNodes(&editor, null)
}
