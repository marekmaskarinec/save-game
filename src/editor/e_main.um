// Entry point for the editor.
// (C) skejeton

import (
  "e_drawcmd.um"; "e_buffer.um"; 

  "../d_config.um";  
  "../d_hashname.um"; "../d_fps.um"; "../d_worlddata.um"
  "../d_global.um"; "../d_resources.um"; "../d_problem_screen.um";
  "../d_background.um"; "../d_world.um";
  "../d_tileset.um"; "../d_util.um"; "../d_mouseinput.um";
  "../d_game.um"; "../d_script.um";

  th_font = "font.um"; th_color = "color.um"; 

  "window.um"; "rect.um"; "th.um"; "image.um"; "canvas.um"; "input.um"

  "utf8.um"; "std.um"
)

const (
  eventMouseLeft = 0
  eventMouseMiddle = 1
  eventMouseRight = 2
  eventMouseScroll = 3
  eventCount = 4
)

type (
  EditorGrid = struct {
    rect: rect.Rect
    scaling: real
    panning: th.Vf2
  }

  ToolNode = struct {
    children: map[str]^ToolNode
    parent: ^ToolNode
    userdata: interface{}
    // If set to -1, the node is frozen and not pruned therefore.
    lastFrameTouched: int
    layer: int
    rect: rect.Rect
  }

  ButtonState = struct {
    isOver: bool
    isDown: bool
    isPressed: bool
    isReleased: bool
  }

  Window = struct {
    lastFrameTouched: int
    rect: rect.Rect
    layer: int
  }

  WindowManager = struct {
    topmostWindowLayer: int
    frameNumber: int
    windowCount: int
    windowVisibility: map[str]bool
    windows: map[str]Window
  }

  ScrollAreaInfo = struct {
    areaRect: rect.Rect
    contentRect: rect.Rect
  }

  WindowInfo = struct {
    contentRect: rect.Rect
    titlebarRect: rect.Rect
  }

  EntityListAction = int

  EditorResources = struct {
    toolbarIcons: image.Image
    bevelImage: image.Image
    tilesetImage: image.Image
    mainFont: th_font.Font
  }

  ToolState = struct {
    active: bool
    hovered: bool
  }

  EditorEntities = struct {
    entitySelected: int
    list: []d_worlddata.EntityDesc
  }

  InputSink = struct {
    sunk: [eventCount]bool
  }

  EditorEvents = struct {
    sink: ^InputSink
    // The events the element itself has sunk, so we can return true if the event were to be queried again.
    acquired: InputSink
    mask: InputSink
    mouseState: d_mouseinput.MouseState
  }

  Editor = struct {
    // Misc
    isDebugOverlayShown: bool
    frameNumber: int

    // Visual data
    ctx: e_drawcmd.DrawContext
    resources: EditorResources

    // Editors
    tileGrid: EditorGrid
    tilemapGrid: EditorGrid
    tilemapLayer: int
    tilemapShowAllLayers: bool
    tileSelected: th.Vf2
    tileset: d_tileset.Tileset
    world: d_world.World
    isPlaying: bool
    isRelocatingPlayer: bool
    isIgnoringGuides: bool
    entities: EditorEntities
    potentialPortal: str // the portal which is in the text box
    currentPortal: str


    // UI misc.
    inputSink: InputSink
    currentWindow: str
    currentWindowLayer: int
    wm: WindowManager

    // Input
    mouseState: d_mouseinput.MouseState

    // Census
    tools: ^ToolNode
    currentTool: ^ToolNode
    maybeActiveTool: ^ToolNode
    activeTool: ^ToolNode
    hoveredTool: ^ToolNode
  }
)

const (
  entityListActionNone = EntityListAction(0)
  entityListActionRemove = EntityListAction(1)
  entityListActionEdit = EntityListAction(2)
)

// Creates an input sink with all inputs set to 1.
// Can be used for masking.
fn initInputSinkSet(): InputSink {
  sink := InputSink{}
 
  for i in sink.sunk {
    sink.sunk[i] = true
  }

  return sink
}

fn sinkAcquireMaskEvent(sink, acquire: ^InputSink, mask: InputSink, event: int): bool {
  if event < 0 || event >= eventCount {
    error(sprintf("Invalid event id: %d", event))
  }
 
  // This event is masked so we can't process it.
  if mask.sunk[event] {
    return false
  }

  // This event was acquired, so it's successful.
  if acquire.sunk[event] {
    return true
  }

  // This event was already sunk. Can't sink it again.
  if sink.sunk[event] {
    return false 
  }

  // Sink and acquire the event.
  sink.sunk[event] = true;
  acquire.sunk[event] = true;

  return true
}

fn sinkEditorEvent(events: ^EditorEvents, event: int): bool {
  return sinkAcquireMaskEvent(events.sink, &events.acquired, events.mask, event)
}

fn convertButtonToEvent(btn: int): int {
  return btn
}

fn (events: ^EditorEvents) queryMouse(btn: int, which: int): bool {
  if sinkEditorEvent(events, convertButtonToEvent(btn)) == false {
    return false
  }

  var mouseButton: d_mouseinput.MouseButtonState

  switch btn {
    case 0: mouseButton = events.mouseState.lmb
    case 1: mouseButton = events.mouseState.mmb
    case 2: mouseButton = events.mouseState.rmb
    default: error(sprintf("Invalid mouse button index %d", btn))
  }

  switch which {
    case d_mouseinput.down: return mouseButton.isDown
    case d_mouseinput.pressed: return mouseButton.isPressed
    case d_mouseinput.released: return mouseButton.isReleased
    default: error(sprintf("Invalid mouse button property index %d", which))
  }
  return false;

}

fn (events: ^EditorEvents) queryScroll(): real {
  if sinkEditorEvent(events, eventMouseScroll) == false {
    return 0
  }

  return events.mouseState.wheelY
}

fn initWindowManager(): WindowManager {
  return WindowManager{windows: map[str]Window{}}
}

fn (wm: ^WindowManager) isWindowVisible(name: str): bool {
  return validkey(wm.windows, name) && wm.windows[name].lastFrameTouched == wm.frameNumber && wm.windowVisibility[name]
}

fn (wm: ^WindowManager) getWindowRect(name: str, fallback: rect.Rect): ^rect.Rect {
  if validkey(wm.windows, name) {
    wm.windows[name].lastFrameTouched = wm.frameNumber
    return &wm.windows[name].rect
  }

  // Create window.
  wm.windowCount += 1
  wm.windows[name] = Window{layer: wm.topmostWindowLayer, rect: fallback, lastFrameTouched: wm.frameNumber}
  wm.topmostWindowLayer++
  return &wm.windows[name].rect
}

fn (wm: ^WindowManager) getWindowLayer(name: str): int {
  if validkey(wm.windows, name) {
    return wm.windows[name].layer 
  } 
  return -1
}

fn (wm: ^WindowManager) putWindowOnFront(name: str) {
  if validkey(wm.windows, name) {
    wm.topmostWindowLayer += 1
    wm.windows[name].layer = wm.topmostWindowLayer
  }
}

fn (wm: ^WindowManager) setWindowVisible(name: str, to: bool) {
  if validkey(wm.windows, name) {
    wm.windowVisibility[name] = to
  } 
}

fn (e: ^Editor) maybeAcquireToolNode(name: str): ^ToolNode {
  if e.currentTool == null {
    e.currentTool = e.tools
  }

  if !validkey(e.currentTool.children, name) {
    return null
  }

  return e.currentTool.children[name]
}

fn (e: ^Editor) acquireToolNode(name: str): ^ToolNode {
  node := e.maybeAcquireToolNode(name)

  if node == null {
    tool := new(ToolNode)
    tool ^= ToolNode{children: map[str]^ToolNode{}, parent: e.currentTool}
    node = tool
    e.currentTool.children[name] = node    
  }

  return node
}

// Prunes all tools untouched last frame
fn (e: ^Editor) pruneToolsRecursive(node: ^ToolNode) {
  if node.lastFrameTouched == -1 {
    // Nodes with last frame -1 are not candidates to pruning (just a hardcoded value).
    // Here we automatically unfreeze the node because you need to freeze it every time.
    node.lastFrameTouched = e.frameNumber
    return
  }

  for key in node.children {
    e.pruneToolsRecursive(node.children[key])

    if node.children[key].lastFrameTouched < e.frameNumber {
      // Fix leak
      node.children[key].parent = null
      node.children = delete(node.children, key)
    }

  }
}

fn (e: ^Editor) freezeTool(name: str) {
  node := e.maybeAcquireToolNode(name)
  if node != null {
    node.lastFrameTouched = -1
  }
}

fn (e: ^Editor) beginTool(name: str, toolRect: rect.Rect): ^ToolNode {
  node := e.acquireToolNode(name)
  node.lastFrameTouched = e.frameNumber
  node.rect = toolRect
  node.layer = e.ctx.currentLayerId
  e.currentTool = node
  isOverMaybeActiveTool := true

  if e.maybeActiveTool != null {
    isOverMaybeActiveTool = node.layer >= e.maybeActiveTool.layer
  }
 
  if ok, scissorRect := e.ctx.getCurrentScissorRect(); ok {
    isOverMaybeActiveTool = isOverMaybeActiveTool && d_util.rectVsPoint(scissorRect, e.mouseState.pos)
  }

  if isOverMaybeActiveTool && d_util.rectVsPoint(node.rect, e.mouseState.pos) {
    e.maybeActiveTool = node
  }

  return e.currentTool
}

fn (e: ^Editor) getToolState(tool: ^ToolNode): ToolState {
  return ToolState{
    active: tool == e.activeTool,
    hovered: tool == e.hoveredTool}
}

fn (e: ^Editor) getCurrentToolState(): ToolState {
  return e.getToolState(e.currentTool)
}

fn (e: ^Editor) isCurrentToolActive(): bool {
  return e.getCurrentToolState().active
}

fn areToolsRelated(parent, child: ^ToolNode): bool {
  for child != null && child != parent {
    child = child.parent
  }
  return child == parent;
}

fn (e: ^Editor) endTool(): EditorEvents {
  if e.currentTool.parent == null {
    error("Parent node is null, beginTool/endTool mismatched!")
  }

  mask := InputSink{}
  if !areToolsRelated(e.currentTool, e.activeTool) {
    // Block all events if the current tool isn't hovered.
    mask = initInputSinkSet()
  }

  e.currentTool = e.currentTool.parent

  return EditorEvents{sink: &e.inputSink, mask: mask, mouseState: e.mouseState}
}

fn (e: ^Editor) getProperty(name: str, def: interface{}): interface{} {
  // Create a dummy tool where we'll store the data.
  tool := e.beginTool(name, rect.mk(-100000, -100000, 0, 0))
  e.endTool()

  if !valid(tool.userdata) {
    tool.userdata = def
  }

  return tool.userdata
}

fn (e: ^Editor) getPropertyLazy(name: str, ctx: interface{}, do:  fn (ctx: interface{}): interface{}): interface{} {
  // Create a dummy tool where we'll store the data.
  tool := e.beginTool(name, rect.mk(-100000, -100000, 0, 0))
  e.endTool()

  if !valid(tool.userdata) {
    tool.userdata = do(ctx)
  }

  return tool.userdata
}

// Draw bevel rect(
//   Rectangle to draw,
//   Does rectangle look pushed in,
//   Color tint, the iconic gray is the default
// )
//
// Draws a beveled rectangle in Windows 98 style.
// It may have a problem with displaying colors somewhat incorrectly,
//   because the middle of the rectangle is tinted gray slightly.
fn drawBevelRect(editor: ^Editor, r: rect.Rect, pushed: bool = false, color: uint32 = th.white) {
  const (
    bevelOuterRect = rect.Rect{0, 0, 5, 5}
    bevelInnerRect = rect.Rect{2, 2, 1, 1}
   
    bevelPushedOuterRect = rect.Rect{5, 0, 5, 5}
    bevelPushedInnerRect = rect.Rect{2, 2, 1, 1}
  )

  if pushed {
    editor.ctx.drawNinepatch(editor.resources.bevelImage, bevelPushedOuterRect, bevelPushedInnerRect, r, color)
  } else {
    editor.ctx.drawNinepatch(editor.resources.bevelImage, bevelOuterRect, bevelInnerRect, r, color)
  }
}

// Vf2 granulate(
//   Vector to granulate
//   The granulation sizes
// )
// 
// Granulation is making number A a multiple of B by rounding.
// This boy does same thing but for vectors, so `th.Vf2{Granulate(A.x, B.x), Granulate(A.y, B.y)}`.
fn vf2Granulate(a, b: th.Vf2): th.Vf2 {
  return a.div(b).floor().mul(b)
}

// Vf2 int modulo(
//   Divident
//   Divisor
// )
// 
// Performs an integer (!!!) modulo operator on scalars of vector a wrt b
// All floating point is lost.
fn vf2IntMod(a, b: th.Vf2): th.Vf2 {
  return th.Vf2{trunc(a.x)%trunc(b.x), trunc(a.y)%trunc(b.y)}
}

fn centerTextWithinRect(font: th_font.Font, text: str, r: rect.Rect): th.Vf2 {
  return r.getDims().sub(font.measure(text)).divf(2.0).add(r.getPos()).subf(1)
}

// TODO: Ability to pass colour
fn drawButton(editor: ^Editor, r: rect.Rect, buttonState: ButtonState, revert: bool = false) {
  pushed := buttonState.isDown != revert

  colorMod := 0xFFFFFFFF
  if pushed {
    colorMod = 0xCCCCCCFF
  }

  drawBevelRect(editor, r, pushed, colorMod)
}

fn drawButtonInactive(editor: ^Editor, r: rect.Rect, text: str) {
  editor.ctx.drawRect(0x999999FF, r)
  editor.ctx.drawText(editor.resources.mainFont, text, centerTextWithinRect(editor.resources.mainFont, text, r), 0x000000FF)
}

fn putButton(editor: ^Editor, r: rect.Rect, name: str): ButtonState {
  editor.beginTool(name,  r)

  buttonState := ButtonState{}
  toolState := editor.getCurrentToolState()
  events := editor.endTool()

  if (toolState.active) {
    buttonState.isOver = true;
    buttonState.isDown = events.queryMouse(0, d_mouseinput.down) || events.queryMouse(0, d_mouseinput.released);
    buttonState.isPressed = events.queryMouse(0, d_mouseinput.pressed);
    buttonState.isReleased = events.queryMouse(0, d_mouseinput.released) && toolState.hovered;
  }

  return buttonState
}

fn putButtonBase(editor: ^Editor, r: rect.Rect, name: str, revert: bool = false): ButtonState {
  bs := putButton(editor, r, name)
  drawButton(editor, r, bs, revert)
  return bs
}

fn uiBeginWindow(editor: ^Editor, title: str, r: rect.Rect): (WindowInfo, bool) {
  const (
    padding = 2
    titlebarHeight = 18
  )

  var (
    contentRect: rect.Rect
    titlebarRect: rect.Rect
    movement: th.Vf2
  )

  windowRect := editor.wm.getWindowRect(title, r)

  if !editor.wm.isWindowVisible(title) {
    // Prevent from getting pruned
    editor.freezeTool(title)

    return WindowInfo{}, false
  }
  if editor.currentWindow != "" {
    error("BeginWindow is called before EndWindow")
  }

  editor.currentWindow = title
  // FIXME: This is a hack around windows being able to change their layers mid drawing.
  //        Which would de-sync the results from getWindowLayer.
  editor.currentWindowLayer = editor.wm.getWindowLayer(title)

  position := th.Vf2{padding, padding}

  editor.ctx.moveLayer(1000*editor.currentWindowLayer)
  // Frame tool.
  editor.beginTool(title, windowRect^)
  {
    drawBevelRect(editor, windowRect^)

    buttonSize := th.Vf2{titlebarHeight, titlebarHeight}
    buttonRect := rect.mk(position.x+windowRect.x, position.y+windowRect.y, buttonSize.x, buttonSize.y)

    if (putButtonBase(editor, buttonRect, "Close").isReleased) {
      editor.wm.setWindowVisible(title, false)
    }

    editor.ctx.drawRect(th.black, rect.mk(position.x+windowRect.x+5, position.y+windowRect.y+titlebarHeight/2-1, buttonSize.x-10, 2))
    position.x += buttonSize.x + padding

    {
      handleSize := th.Vf2{windowRect.w - position.x - padding, titlebarHeight}
      titlebarRect = rect.mk(position.x+windowRect.x, position.y+windowRect.y, handleSize.x-1, handleSize.y)

      // Titlebar tool.
      {
        editor.beginTool("Titlebar", titlebarRect)
        events := editor.endTool()

        if (events.queryMouse(0, d_mouseinput.pressed)) {
          editor.wm.putWindowOnFront(title)
        }
        if (events.queryMouse(0, d_mouseinput.down)) {
          movement = events.mouseState.delta
        }
      }

      editor.ctx.drawRect(0x000077FF, titlebarRect)
      editor.ctx.beginScissorRect(titlebarRect)
        editor.ctx.drawText(editor.resources.mainFont, title, centerTextWithinRect(editor.resources.mainFont, title, titlebarRect), th.white)
      editor.ctx.endScissor()
    
      position.x += handleSize.x + padding
    }

    position.x = 1
    position.y += titlebarHeight + 1

    contentSize := th.Vf2{windowRect.w - position.x - padding, windowRect.h - position.y - padding}
    contentRect = rect.mk(position.x+windowRect.x, position.y+windowRect.y, contentSize.x-1, contentSize.y-1)

    editor.beginTool("Body", contentRect)
  }

  windowRect ^= d_util.rectMove(windowRect^, movement)

  return WindowInfo{contentRect: contentRect, titlebarRect: titlebarRect}, true
}

fn uiEndWindow(editor: ^Editor) {
  if editor.currentWindow == "" {
    error("EndWindow has no match with BeginWindow")
  }

  title := editor.currentWindow
  movement := th.Vf2{0, 0} // Same as movement but changes the window size
  squishing := th.Vf2{0, 0} // Same as movement but changes the window size
  windowRect := editor.wm.getWindowRect(title, rect.mk(0, 0, 0, 0))

  // Finish ui tools.
  {
      events := editor.endTool()

      if (events.queryMouse(0, d_mouseinput.pressed)) {
        editor.wm.putWindowOnFront(title)
      }
      if (events.queryMouse(0, d_mouseinput.down)) {
        movement = events.mouseState.delta
      }

      gripSize := th.Vf2{10, 10};
      gripRect := rect.mk(windowRect.x+windowRect.w-gripSize.x, windowRect.y+windowRect.h-gripSize.y, gripSize.x, gripSize.y)

      {
        editor.beginTool("Grip", gripRect)
        events := editor.endTool()
        if events.queryMouse(0, d_mouseinput.down) {
          squishing = editor.mouseState.delta
        }
      }

    editor.endTool()
  }
  editor.ctx.moveLayer(-1000*editor.currentWindowLayer)

  windowRect ^= d_util.rectMove(windowRect^, movement)
  windowRect.w += squishing.x; windowRect.h += squishing.y;
  // Clamp
  if windowRect.w < 100 {
    windowRect.w = 100
  }
  if windowRect.h < 100 {
    windowRect.h = 100
  }

  editor.currentWindow = ""
}


fn (ge: ^EditorGrid) mapPos(pos: th.Vf2): th.Vf2 {
  return ge.panning.mulf(ge.scaling).add(pos).add(ge.rect.getPos()).add(ge.rect.getDims().divf(2))
}

// Puts editor grid spanning the entire screen
// TODO: Fix scaling
fn (ge: ^EditorGrid) put(editor: ^Editor, rectangle: rect.Rect): th.Vf2 {
  ge.rect = rectangle

  const (
    lineColor = th.white&0xFFFFFF11
    tileColor = th.white&0xFFFFFF22
    debugColor = th.red&0xFFFFFF00
  )

  var (
    scale: real = ge.scaling
    tileSize: real = 32*scale
    tileSizes: th.Vf2 = th.Vf2{tileSize, tileSize}

    mousePos: th.Vf2 = editor.mouseState.pos.sub(rectangle.getPos())
    mouseDelta: th.Vf2 = editor.mouseState.delta
  )

  // TODO: Create a new tool instead of quering the state of existing tool. 
  // Then I can use events.queryMouse()
  if editor.isCurrentToolActive() {
    // Handle input
    if editor.mouseState.mmb.isDown {
      ge.panning = ge.panning.add(mouseDelta.divf(scale))
    }
  }

  var (
    // This is the panning :P
    offset: th.Vf2 = ge.panning.add(rectangle.getDims().divf(2)).mulf(scale)

    // This is panning but adjusted so that it wraps around every TileSize'th time
    visualOffset: th.Vf2 = vf2IntMod(offset, tileSizes)

    highlightedTileWorldPosition: th.Vf2 = mousePos.sub(offset)
    highlightedTileScreenPosition: th.Vf2 = vf2Granulate(highlightedTileWorldPosition, tileSizes).add(offset).add(rectangle.getPos())
    highlightedTileRect: rect.Rect = rect.mk(highlightedTileScreenPosition.x, highlightedTileScreenPosition.y, tileSize, tileSize)
  )

  editor.ctx.beginScissorRect(rectangle)

  // Draw background (debug)
  editor.ctx.drawRect(debugColor, rectangle)

  // Draw grid
  for y := visualOffset.y; y < rectangle.h; y += tileSize {
    lineRect := rect.mk(round(rectangle.x), round(rectangle.y + y), rectangle.w, 1)
    editor.ctx.drawRect(lineColor, lineRect)
  }

  for x := visualOffset.x; x < rectangle.w; x += tileSize {
    lineRect := rect.mk(round(rectangle.x + x), round(rectangle.y), 1, rectangle.h)
    editor.ctx.drawRect(lineColor, lineRect)
  }

  if editor.isCurrentToolActive() {
    // Draw highlighted tile
    editor.ctx.drawRect(tileColor, highlightedTileRect)
  }

  coordinate := ge.panning.mulf(-1).div(tileSizes).floor()
  coordinateString := sprintf("%+-4g %+-4g", coordinate.x, coordinate.y)

  bottomLeft := th.Vf2{rectangle.x, rectangle.y+rectangle.h}
  bottomLeft.y -= editor.resources.mainFont.measure(coordinateString).y
  editor.ctx.drawText(editor.resources.mainFont, coordinateString, bottomLeft, th.white)

  editor.ctx.endScissor()

  return highlightedTileWorldPosition.div(tileSizes).floor()
}

fn putIconButton(editor: ^Editor, name: str, r: rect.Rect, img: image.Image, revert: bool = false): ButtonState {
  bs := putButtonBase(editor, r, name, revert)
  editor.ctx.drawImage(img, th.Transform{p: th.Vf2{r.x, r.y}, s: th.Vf2{1, 1}})
  return bs
}

fn putSimpleButton(editor: ^Editor, r: rect.Rect, text: str, revert: bool = false): ButtonState {
  bs := putButtonBase(editor, r, text, revert)
  editor.ctx.drawText(editor.resources.mainFont, text, centerTextWithinRect(editor.resources.mainFont, text, r), th.black)
  return bs
}

fn clamp(a, x, b: real): real {
  if x < a {
    x = a
  }
  if x > b {
    x = b
  }
  return x
}

fn isprint(c: uint32): bool {
  // Check if not first 32 reserved ASCII chars and not DEL
  return c >= 32 && c != 127
}

fn insertInputTextIntoOneLineBuffer(buffer: ^e_buffer.Buffer, cursor: ^e_buffer.Cursor, text: str) {
  runes := utf8.decode(text)

  for index, rune in runes {
    
    // Ignore non printable characters.
    if isprint(uint32(rune)) {
      e_buffer.insertAt(buffer, cursor, rune.encode())
    }
  }
}

fn getFirstLineOfBuffer(buffer: ^e_buffer.Buffer): str {
  if len(buffer.lines) == 0 {
    return ""
  }

  return buffer.lines[0]
}

type SingleLineEdit = struct {
  scrollX: real
  buffer: e_buffer.Buffer
  cursor: e_buffer.Cursor
}

fn initSingleLineEdit(): SingleLineEdit {
  return SingleLineEdit{0, e_buffer.Buffer{lines: []str{""}}, e_buffer.Cursor{}}
}

fn initBufferFromString(s: str): e_buffer.Buffer {
  return e_buffer.Buffer{lines: []str{s}}
}

fn drawSingleLineEdit(editor: ^Editor, edit: ^SingleLineEdit, r: rect.Rect, drawCursor: bool) {

  editor.ctx.beginScissorRect(r)

  firstLine := getFirstLineOfBuffer(&edit.buffer)
  precursor := e_buffer.unicodeTextSlice(firstLine, 0, edit.cursor.column)
  precursorMeasured := editor.resources.mainFont.measure(precursor)
  cursorRect := rect.mk(precursorMeasured.x, 0, 1, precursorMeasured.y)
 
  // Make sure the cursor is visible on the screen
  // NOTE: Maybe I shouldn't modify the editor state while drawing eh?
  if (cursorRect.x+cursorRect.w) > (r.w-edit.scrollX) {
    edit.scrollX = -(cursorRect.x+cursorRect.w-r.w)
  }
  if cursorRect.x < -edit.scrollX {
    edit.scrollX = -cursorRect.x
  }

  cursorRect.x += r.x+edit.scrollX
  cursorRect.y += r.y

  if drawCursor {
    editor.ctx.drawRect(th.black, cursorRect)
  }
  editor.ctx.drawText(editor.resources.mainFont, firstLine, r.getPos().add(th.Vf2{edit.scrollX, 0}), th.black)

  editor.ctx.endScissor()
}

fn putTextEditOneLine(editor: ^Editor, r: rect.Rect, name: str, value: ^str) {
  editor.beginTool(name, r)
    edit := ^SingleLineEdit(editor.getPropertyLazy("Editor", null, fn (ctx: interface{}): interface{} {return initSingleLineEdit()}))
    edit.buffer = initBufferFromString(value^)
    edit.cursor = e_buffer.sanitizeCursor(&edit.buffer, edit.cursor)

    // Handle input.
    if (editor.isCurrentToolActive()) {
      insertInputTextIntoOneLineBuffer(&edit.buffer, &edit.cursor, input.getStr())
      // TODO: Add DEL check for deleting the character in front. 
      //       I currently can't do that because tophat doesn't support DEL.
      if input.isJustPressed(input.key_backspace) {
        e_buffer.erase(&edit.buffer, &edit.cursor)
      }
      if input.isJustPressed(input.key_left) {
        edit.cursor = e_buffer.moveCursor(&edit.buffer, edit.cursor, -1, 0)
      }
      if input.isJustPressed(input.key_right) {
        edit.cursor = e_buffer.moveCursor(&edit.buffer, edit.cursor, 1, 0)
      }
    }

    // Draw.
    {
      drawBevelRect(editor, r, true)
      // Draw the inside white
      editor.ctx.drawRect(th.white, d_util.rectShrink(r, 2))

      fontHeight := editor.resources.mainFont.measure(" ").y
      textRect := rect.mk(r.x+5, r.y+(r.h-fontHeight)/2.0, r.w-10, fontHeight)
      drawSingleLineEdit(editor, edit, textRect, editor.isCurrentToolActive())
    }

    // Sync buffer up with the value.
    value ^= getFirstLineOfBuffer(&edit.buffer)
  editor.endTool()
}

fn beginScrollArea(editor: ^Editor, areaRect: rect.Rect, contentSize: th.Vf2): (bool, ScrollAreaInfo) {
  const (
    handleSize = 18
  )

  editor.beginTool("ScrollArea", areaRect)

  scroll := ^real(editor.getProperty("ScrollAreaScroll", 0.0))
  overflow := clamp(contentSize.y-areaRect.h, 0, contentSize.y)
  scrollValue := clamp(scroll^, 0, overflow)
  yScrollOverflowFactor := 0.0
  if areaRect.h != 0 {
    yScrollOverflowFactor = contentSize.y/areaRect.h
  }
  doNotTruncateScroll := false

  editor.ctx.drawRect(0x777777FF, areaRect)
  rightHandleRect := d_util.rectCutRight(areaRect, handleSize)

  // If there's yknow, some overflow..
  if yScrollOverflowFactor > 1 {
    thumbHeight := rightHandleRect.h/yScrollOverflowFactor
    thumbGap := (rightHandleRect.h-thumbHeight)
    thumbOffset := thumbGap*(scrollValue/overflow)
    thumbRect := rightHandleRect
    thumbRect.h = thumbHeight
    thumbRect.y += thumbOffset

    thumbState := putButtonBase(editor, d_util.rectShrink(thumbRect, 2), "ScrollbarThumb")
    if thumbState.isDown {
      doNotTruncateScroll = true
      scroll ^+= editor.mouseState.delta.y*yScrollOverflowFactor
    }

  }

  if editor.isDebugOverlayShown {
    // Show where the content ends.
    editor.ctx.moveLayer(1)
    editor.ctx.drawRect(th.magenta, rect.mk(areaRect.x, areaRect.y+contentSize.y, contentSize.x, 1))
    editor.ctx.moveLayer(-1)
  }

  if !doNotTruncateScroll {
    // Clamp the scroll to the valid scroll range.
    scroll^ = clamp(scroll^, 0, overflow)
  }

  areaRect.w -= handleSize
  areaRect = d_util.rectShrink(areaRect, 1)
  areaRect.w += 1 // Account for uneven padding between content and border
  contentRect := areaRect
  contentRect.y -= scrollValue


  return true, ScrollAreaInfo{areaRect: areaRect, contentRect: contentRect}
}

fn endScrollArea(editor: ^Editor) {
  scroll := ^real(editor.getProperty("ScrollAreaScroll", 0.0))
  
  events := editor.endTool()

  scroll ^-= events.queryScroll()*20.0
}

fn portalToPath(portal: str): str {
  return "data/spiel/sc_"+portal+".csv"
}

fn createEditorEntities(): EditorEntities {
  return EditorEntities{list: []d_worlddata.EntityDesc{}, entitySelected: -1}
}

fn editorLoadWorld(editor: ^Editor, portal: str): bool {
  if ok, data := d_util.readFileStr(portalToPath(portal)); ok {
    worldData := d_worlddata.load(editor.world, data)

    editor.world = worldData.world
    editor.entities.list = worldData.entities
    return true
  } else {
    // TODO(skejeton): maybe I shouldn't initialize empty world like that??!
    editor.world = d_world.fromTileset(editor.world.tileset)
    editor.entities = createEditorEntities()
    
  }
  return false
}

fn editorSaveWorld(editor: ^Editor) {
  d_util.writeFileStr(portalToPath(editor.currentPortal), d_worlddata.save(d_worlddata.WorldData{editor.world, editor.entities.list}))
}

fn editorToggleGame(editor: ^Editor) {
  if (!editor.isPlaying) {
    d_game.start(d_worlddata.WorldData{editor.world, editor.entities.list})
    d_script.init()
  }
  editor.isPlaying = !editor.isPlaying
} 

fn putToolbarIconButton(editor: ^Editor, btnName: str, buttonRectangle: ^rect.Rect, ix, iy: int, revert: bool): bool {
  pressed := false
  editor.resources.toolbarIcons.crop(th.Vf2{ix/4.0, iy/4.0}, th.Vf2{(ix+1)/4.0, (iy+1)/4.0})
  if putIconButton(editor, btnName, buttonRectangle^, editor.resources.toolbarIcons, revert).isReleased {
    pressed = true
  }
  buttonRectangle.x += buttonRectangle.w

  return pressed
}

fn putToolbarWindowIconButton(editor: ^Editor, windowName: str, buttonRectangle: ^rect.Rect, ix, iy: int) {
  isVisible := editor.wm.isWindowVisible(windowName)
  if putToolbarIconButton(editor, windowName, buttonRectangle, ix, iy, isVisible) {
    editor.wm.setWindowVisible(windowName, !isVisible)
  }
}

// Puts window toolbar on the bottom of the screen
fn editorPutToolbar(editor: ^Editor) {
  const (
    margin = 0
    padding = 1
    rectangleHeight = 32 + margin * 2 + padding * 2
  )

  rectangle := rect.Rect{margin, d_global.screen.h - rectangleHeight + margin, d_global.screen.w - margin * 2, rectangleHeight - margin * 2}

  editor.beginTool("ToolBar", rectangle)
  {
    if !editor.isPlaying {
      drawBevelRect(editor, rectangle, false)
    }

    buttonRectangle := rect.mk(rectangle.x+padding, rectangle.y+padding, rectangle.h-padding*2, rectangle.h-padding*2)

    if putToolbarIconButton(editor, "Play", &buttonRectangle, 1, 1, editor.isPlaying) {
      editorToggleGame(editor)
    }

    if !editor.isPlaying {
      putToolbarWindowIconButton(editor, "Tile Picker", &buttonRectangle, 0, 1)
      putToolbarWindowIconButton(editor, "Player Placer", &buttonRectangle, 3, 1)
      putToolbarWindowIconButton(editor, "Entity List", &buttonRectangle, 0, 2)
      putToolbarWindowIconButton(editor, "Entity Editor", &buttonRectangle, 1, 2)
      putToolbarWindowIconButton(editor, "Portal", &buttonRectangle, 2, 2)

      // Draw Save/Load
      {
        position := rectangle.getEnd()
        position.y -= rectangle.h
        
        position.x -= 80
        if (putSimpleButton(editor, rect.mk(position.x, position.y, 80, rectangle.h), "Save").isReleased) {
          editorSaveWorld(editor)
        }

        position.x -= 80
        if (putSimpleButton(editor, rect.mk(position.x, position.y, 80, rectangle.h), "Load").isReleased) {
          editorLoadWorld(editor, editor.currentPortal)
        }

        position.x -= 120
      }
    }
  }
  editor.endTool()
}

type ToolDebugFrame = struct {
  title: str
  color: uint32
  showTitle: bool
  background: bool
  rect: rect.Rect
}

fn makeToolDebugFrameFromTool(editor: ^Editor, name: str, tool: ^ToolNode): ToolDebugFrame {
  toolState := editor.getToolState(tool)

  color := th.red
  background := false
  showTitle := false

  if toolState.active {
    background = true
  }

  if toolState.hovered || toolState.active {
    showTitle = true
    color = 0x00   

    color |= int(toolState.hovered) * th.blue
    color |= int(toolState.active) * th.green
  }

  return ToolDebugFrame{title: name, color: color, showTitle: showTitle, rect: tool.rect, background: background}
}

type RealColor = struct {
  r, g, b, a: real
}

/**
 * \brief Converts uint32 color to normalized RGBA.
 */
fn decomposeColor(color: uint32): RealColor {
  return RealColor{((color >> 24) & 0xFF) / 255.0, ((color >> 16) & 0xFF) / 255.0, ((color >> 8) & 0xFF) / 255.0, ((color >> 0) & 0xFF) / 255.0}
}

/**
 * \brief Returns true if the foreground will look good white,
 *        or black. Heuristic for things like text on a background.
 */
fn isWhiteForeground(color: uint32): bool {
  realColor := decomposeColor(color)
  sum := realColor.r * 0.7 + realColor.g * 1.5 + realColor.b * 0.8
  return sum >= 1.5
}

fn drawToolDebugFrame(ctx: ^e_drawcmd.DrawContext, frame: ToolDebugFrame, font: th_font.Font) {
  textColor := th.white
  if isWhiteForeground(frame.color) {
    textColor = th.black
  }

  if frame.showTitle {
    // Draw the title.
    planeSize := font.measure(frame.title)
    r := rect.mk(frame.rect.x, frame.rect.y-planeSize.y, planeSize.x, planeSize.y)
    r = d_util.rectKeepInBounds(r, rect.mk(0, 0, d_global.screen.w, d_global.screen.h))

    if frame.background {
      ctx.drawRect(textColor, d_util.rectShrink(r, -1))
    }
    ctx.drawRect(frame.color, r)
    ctx.drawText(font, frame.title, r.getPos(), textColor)
  }
  if frame.background {
    ctx.drawRectLines(textColor, frame.rect, 3)
  }
  ctx.drawRectLines(frame.color, frame.rect)
}

fn putEditorDebugToolFramesRecursive(editor: ^Editor, tool: ^ToolNode, prefix: str = "") {
  font := editor.resources.mainFont

  for toolName, toolChild in tool.children {
    editor.ctx.setLayer(toolChild.layer)

    drawToolDebugFrame(&editor.ctx, makeToolDebugFrameFromTool(editor, toolName, toolChild), font)
    putEditorDebugToolFramesRecursive(editor, toolChild, toolName+"::")
  }
}

fn putEditorDebugToolFrames(editor: ^Editor) {
  putEditorDebugToolFramesRecursive(editor, editor.tools)
}

fn isAnyButtonHeld(mouseState: ^d_mouseinput.MouseState): bool {
  return mouseState.lmb.isDown || mouseState.mmb.isDown || mouseState.rmb.isDown
} 

type WorldEditCmd = struct {
  showLayers: uint // 3 bits
  toolbarIcons: image.Image
  rect: rect.Rect
  offset: th.Vf2
  world: ^d_world.World
}

fn (d: ^WorldEditCmd) draw(props: e_drawcmd.DrawProperties) {
  d_background.draw(d.rect)
  if (d.showLayers & 1 > 0) {
    d.world.drawLayer(d.offset, -1)
  }
  if (d.showLayers & 2 > 0) {
    d.world.drawLayer(d.offset, 0)
  }
  if (d.showLayers & 4 > 0) {
    d.world.drawLayer(d.offset, 1)
  }

  d.toolbarIcons.crop(th.Vf2{2.0/4.0, 0.0/4.0}, th.Vf2{3.0/4.0, 1.0/4.0})
  pos := d.world.playerSpawnPos.mulf(32).add(d.offset)
  d.toolbarIcons.draw(d_util.posTrans(pos.x, pos.y))
}

fn getShownLayersBitmap(layerSelected: int, showAllLayers: bool): uint {
  return 1<<(layerSelected+1)|(int(showAllLayers)*0x7)
}

fn drawLayerIcon(ctx: ^e_drawcmd.DrawContext, position: th.Vf2, layer: int, showAllLayers: bool) {
  fills := [3]bool{layer == -1, layer == 0, layer == 1}

  // NOTE: If we choose to show all layers, the icon will show all boxes filled in
  if showAllLayers {
    fills = [3]bool{true, true, true}
  }

  position.x += 26

  for i, l in fills {
    rec := rect.Rect{position.x-20, position.y, 20, 12}
    position.x -= 2
    position.y += 4

    if l {
      ctx.drawRect(0xf0b5afFF, rec)
      ctx.drawRectLines(0xFFFFFFFF, rec)
    } else {
      ctx.drawRect(0x99a9a9a9, rec)
      ctx.drawRectLines(0xFFFFFFFF, rec)
    }
  }
}

type GameCmd = struct {}

fn (gc: ^GameCmd) draw(props: e_drawcmd.DrawProperties) {
  d_game.draw()
  d_script.draw()
}

fn putLabelY(editor: ^Editor, text: str, color: uint32, position: ^th.Vf2) {
  editor.ctx.drawText(editor.resources.mainFont, text, position^, color)
  position.y += editor.resources.mainFont.measure(text).y
}

fn putPlayerPlacer(editor: ^Editor) {
  if windowInfo, ok := uiBeginWindow(editor, "Player Placer", rect.mk(5, 5+32*7+20, 32*5, 32*7)); ok { 

    contentRect := d_util.rectShrink(windowInfo.contentRect, 5)
    position := contentRect.getPos()
    playerPos := editor.world.playerSpawnPos

    editor.ctx.beginScissorRect(contentRect)
    {
      putLabelY(editor, sprintf("Player at: %d %d", trunc(playerPos.x), trunc(playerPos.y)), th.black, &position)
      position.y += 10

      if (putSimpleButton(editor, rect.mk(position.x, position.y, contentRect.w, 30), "Relocate", editor.isRelocatingPlayer).isReleased) {
        editor.isRelocatingPlayer = !editor.isRelocatingPlayer
      }
      position.y += 30+10

      if (editor.isRelocatingPlayer) {
        putLabelY(editor, "Click on the grid\nTo place player.", th.black, &position)
      }
    }
    editor.ctx.endScissor()
    uiEndWindow(editor)
  }
}

fn putTilePicker(editor: ^Editor) {
  if windowInfo, ok := uiBeginWindow(editor, "Tile Picker", rect.mk(5, 5, 32*5, 32*7)); ok { 
    // NOTE: This is to cancel the window-body dragging thing.
    //       Probably not the best way to do it.
    contentRect := windowInfo.contentRect
    var selectedTile: th.Vf2

    editor.beginTool("Picker", contentRect)
    {
      editor.ctx.drawRect(th.black, contentRect)
      editor.ctx.moveLayer(1)
      {
        selectedTile = editor.tilemapGrid.put(editor, contentRect)

        selectedTilePos := editor.tilemapGrid.mapPos(editor.tileSelected.mulf(32))
        
        editor.ctx.beginScissorRect(contentRect)
        editor.ctx.drawRect(th_color.alpha(th.green, 0.3), rect.mk(selectedTilePos.x, selectedTilePos.y, 32, 32))
        editor.ctx.endScissor()
      }
      editor.ctx.moveLayer(-1)
      editor.ctx.beginScissorRect(contentRect)

      editor.tileset.image.crop(th.Vf2{0, 0}, th.Vf2{1, 1})
      editor.ctx.drawImage(editor.tileset.image, th.Transform{s: th.Vf2{0.5, 0.5}, p: editor.tilemapGrid.mapPos(th.Vf2{0, 0})})
      editor.ctx.endScissor()
    }
    events := editor.endTool()

    if events.queryMouse(0, d_mouseinput.down) {
      editor.tileSelected = selectedTile
    }

    uiEndWindow(editor)
  }
}

fn putEntityEntry(editor: ^Editor, ent: d_worlddata.EntityDesc, r: rect.Rect, selected: bool): EntityListAction  {
  r.w -= 30
  action := entityListActionNone

  editor.beginTool(ent.id, r)
  {
    putSimpleButton(editor, r, ent.name)
    if selected {
      editor.ctx.drawRectLines(th.yellow, d_util.rectShrink(r, 1))
    }
    r.x += r.w
    r.w = 30
    if input.isPressed(input.key_shift) {
      if putSimpleButton(editor, r, "␡").isReleased {
        action = entityListActionRemove
      }
    } else {
      if putSimpleButton(editor, r, "✎").isReleased {
        action = entityListActionEdit
      }
    }
  }
  editor.endTool()

  return action
}

fn appendEntity(editorEntities: ^EditorEntities, entity: d_worlddata.EntityDesc) {
  editorEntities.list = append(editorEntities.list, entity)
} 

fn removeEntity(editorEntities: ^EditorEntities, index: int) {
  // Unselect the entity
  if index == editorEntities.entitySelected { 
    editorEntities.entitySelected = -1
  }
  // Shift the selected entity index down if entity below to be removed
  if index < editorEntities.entitySelected { 
    editorEntities.entitySelected -= 1
  }
  editorEntities.list = delete(editorEntities.list, index)
}

/*
 * \brief Creates a random entity with a random ID and name, empty tags
 */
fn makeRandomEntity(): d_worlddata.EntityDesc {
  ident := d_hashname.random()
  return d_worlddata.EntityDesc{name: ident, id: ident, tags: ""}
}

/*
 * \brief Creates an entity with same name and id, empty tags
 */
fn makeNamedEntity(name: str): d_worlddata.EntityDesc {
  return d_worlddata.EntityDesc{name: name, id: name, tags: ""}
}

fn selectEntity(entities: ^EditorEntities, index: int) {
  entities.entitySelected = index
}

fn isEntitySelected(entities: ^EditorEntities, index: int): bool {
  return entities.entitySelected == index
}

fn initEntityAtCenter(editor: ^Editor, ent: d_worlddata.EntityDesc): d_worlddata.EntityDesc {
  ent.rect = rect.Rect{-editor.tileGrid.panning.x-16, -editor.tileGrid.panning.y-16, 32, 32}
  return ent
}

fn putEntityList(editor: ^Editor) {
  entryRemoveIndex := -1

  if windowInfo, ok := uiBeginWindow(editor, "Entity List", rect.mk(800-200-5, 5, 200, 200)); ok {
    // Apply padding.
    contentRect := d_util.rectShrink(windowInfo.contentRect, 5)

    // Put add button.
    {
      buttonRect := d_util.rectShrink(d_util.rectCutRight(windowInfo.titlebarRect, 20), 1)

      if (putSimpleButton(editor, buttonRect, "+").isReleased) {
        appendEntity(&editor.entities, initEntityAtCenter(editor, makeRandomEntity()))
      }
    }

    // Put entries.
    {
      // Get content size.
      contentSize := ^th.Vf2(editor.getProperty("ContentSize", th.Vf2{0, 0}))

      if ok, scrollAreaInfo := beginScrollArea(editor, contentRect, contentSize^); ok {
        editor.ctx.beginScissorRect(scrollAreaInfo.areaRect)
        entryRect := scrollAreaInfo.contentRect
        entryRect.h = 30
        for i, ent in editor.entities.list {
          switch putEntityEntry(editor, ent, entryRect, isEntitySelected(&editor.entities, i)) {
            case entityListActionRemove:
              entryRemoveIndex = i
            case entityListActionEdit:
              selectEntity(&editor.entities, i)
          }
          entryRect.y += 30
        }

        contentSize ^= th.Vf2{entryRect.w, entryRect.y-scrollAreaInfo.contentRect.y}
        editor.ctx.endScissor()
        endScrollArea(editor)
      }
    }

    uiEndWindow(editor)
  }

  if entryRemoveIndex != -1 {
    removeEntity(&editor.entities, entryRemoveIndex)
  }
}

fn getEntitySelectedIndex(entities: ^EditorEntities): int {
  return entities.entitySelected
}

fn getEntitySelected(entities: ^EditorEntities): ^d_worlddata.EntityDesc {
  if entities.entitySelected < 0 {
    return null
  }

  return &entities.list[entities.entitySelected]
}

fn putEntityEditor(editor: ^Editor) {
  entitySelected := getEntitySelected(&editor.entities)

  if entitySelected != null {
    if windowInfo, ok := uiBeginWindow(editor, "Entity Editor", rect.mk(800-200-5, 5+200+5, 200, 220)); ok {
      contentRect := d_util.rectShrink(windowInfo.contentRect, 5)

      editor.ctx.beginScissorRect(contentRect)
      position := contentRect.getPos()
      putLabelY(editor, "Name", th.black, &position)
      putTextEditOneLine(editor, rect.mk(position.x, position.y, contentRect.w, 30), "Name ", &entitySelected.name)
      position.y += 30
      putLabelY(editor, "Id", th.black, &position)
      putTextEditOneLine(editor, rect.mk(position.x, position.y, contentRect.w, 30), "Id ", &entitySelected.id)
      position.y += 30
      putLabelY(editor, "Tags", th.black, &position)
      putTextEditOneLine(editor, rect.mk(position.x, position.y, contentRect.w, 30), "Tags ", &entitySelected.tags)
      position.y += 30
      position.y += 10
      if putSimpleButton(editor, rect.mk(position.x, position.y, contentRect.w, 30), "Delete").isReleased {
        removeEntity(&editor.entities, getEntitySelectedIndex(&editor.entities))
      } 
      editor.ctx.endScissor()

      uiEndWindow(editor)
    }
  }
}

type RectResizeCommand = struct {
  posFactor: th.Vf2   // Factor to multiply MouseDelta by to move the rectangle
  sizeFactor: th.Vf2  // Factor to multiply MouseDelta by to resize the rectangle
}

type EditGrip = struct {
  position: th.Vf2
  resizeCommand: RectResizeCommand
}

fn putRectGrips(editor: ^Editor, r: rect.Rect): RectResizeCommand {
  // Grips positions are initialized as relative here.
  // Will be multiplied by rect.w/h and added rect.x/y to them.
  const eightGrips = [8]EditGrip{
    EditGrip{th.Vf2{0.0, 0.0}, RectResizeCommand{th.Vf2{1, 1}, th.Vf2{-1, -1}}},
    EditGrip{th.Vf2{0.5, 0.0}, RectResizeCommand{th.Vf2{0, 1}, th.Vf2{ 0, -1}}},
    EditGrip{th.Vf2{1.0, 0.0}, RectResizeCommand{th.Vf2{0, 1}, th.Vf2{ 1, -1}}},

    EditGrip{th.Vf2{0.0, 0.5}, RectResizeCommand{th.Vf2{1, 0}, th.Vf2{-1,  0}}},
    EditGrip{th.Vf2{1.0, 0.5}, RectResizeCommand{th.Vf2{0, 0}, th.Vf2{ 1,  0}}},

    EditGrip{th.Vf2{0.0, 1.0}, RectResizeCommand{th.Vf2{1, 0}, th.Vf2{-1,  1}}},
    EditGrip{th.Vf2{0.5, 1.0}, RectResizeCommand{th.Vf2{0, 0}, th.Vf2{ 0,  1}}},
    EditGrip{th.Vf2{1.0, 1.0}, RectResizeCommand{th.Vf2{0, 0}, th.Vf2{ 1,  1}}}}

  activeGrip := -1

  for i, grip in eightGrips {
    gripPos := r.getDims().mul(grip.position).add(r.getPos())
    gripRect := rect.mk(gripPos.x-6, gripPos.y-6, 12, 12)
    gripDrawRect := d_util.rectShrink(gripRect, 2)

    editor.beginTool(sprintf("Grip%d", i), gripRect)
 
    color := th.blue

    if editor.isCurrentToolActive() {
      color = th.cyan
    }

    editor.ctx.drawRect(color, gripDrawRect)
    editor.ctx.drawRectLines(th.black, gripDrawRect)

    events := editor.endTool()

    if events.queryMouse(0, d_mouseinput.down) {
      activeGrip = i
    }
  }

  if activeGrip == -1 {
    return RectResizeCommand{}
  }

  return eightGrips[activeGrip].resizeCommand
}

fn applyRectResizeCommand(resizeCommand: RectResizeCommand, r: rect.Rect, delta: th.Vf2): rect.Rect {
  r.x += delta.x * resizeCommand.posFactor.x
  r.y += delta.y * resizeCommand.posFactor.y
  r.w += delta.x * resizeCommand.sizeFactor.x
  r.h += delta.y * resizeCommand.sizeFactor.y
  return r
}

fn drawTaggedEntityRect(editor: ^Editor, entity: ^d_worlddata.EntityDesc, r: rect.Rect, tags: ^d_game.TagSet) {
  if tags.isSet("Guide") {
    editor.ctx.drawRectLines(th.yellow, r)
  } else {
    editor.ctx.drawRect(th.red, r)
  }

  if tags.isSet("Comment") {
    editor.ctx.drawText(editor.resources.mainFont, entity.name, th.Vf2{r.x, r.y}, th.white)
  }
}

fn putWorldEntities(editor: ^Editor) {
  for i in editor.entities.list {
    ent := &editor.entities.list[i]

    entVisRect := d_util.rectMove(ent.rect, editor.tileGrid.mapPos(th.Vf2{0, 0}))

    // FIXME: Initializing tag set every time we render an entity is not efficent at all.
    tags := d_game.initTagSetFromString(ent.tags)
    ignore := tags.isSet("Guide") && editor.isIgnoringGuides && !isEntitySelected(&editor.entities, i);

    drawTaggedEntityRect(editor, ent, entVisRect, &tags)

    if !ignore {
      editor.beginTool("Ent"+ent.name, entVisRect)

      if editor.isCurrentToolActive() {
        editor.ctx.drawRectLines(th.blue, d_util.rectShrink(entVisRect, -1))
      }

      if isEntitySelected(&editor.entities, i) {
        editor.ctx.drawRectLines(th.yellow, d_util.rectShrink(entVisRect, 0))

        ent.rect = applyRectResizeCommand(putRectGrips(editor, entVisRect), ent.rect, editor.mouseState.delta)

        if ent.rect.w < 10 {
          ent.rect.w = 10
        }
        if ent.rect.h < 10 {
          ent.rect.h = 10
        }
      }

      events := editor.endTool()

      if events.queryMouse(0, d_mouseinput.pressed) {
        selectEntity(&editor.entities, i)
      }
      if events.queryMouse(0, d_mouseinput.down) {
        ent.rect.x += events.mouseState.delta.x
        ent.rect.y += events.mouseState.delta.y
      }
    }
  }
}

fn deselectEntity(entities: ^EditorEntities) {
  entities.entitySelected = -1
}

fn loadPortal(editor: ^Editor, portal: str) {
  editor.currentPortal = portal
  editor.potentialPortal = portal
  editorLoadWorld(editor, portal)
  editor.tileGrid.panning = editor.world.playerSpawnPos.mulf(-32)
}

fn putPortalEditor(editor: ^Editor) {
  if windowInfo, ok := uiBeginWindow(editor, "Portal", rect.mk(30, 30, 200, 300)); ok {
    contentRect := d_util.rectShrink(windowInfo.contentRect, 5)
    position := contentRect.getPos()

    putTextEditOneLine(editor, rect.mk(position.x, position.y, contentRect.w, 30), "Portal name", &editor.potentialPortal)

    position.y += 40
    if input.isPressed(input.key_shift) {
      if putSimpleButton(editor, rect.mk(position.x, position.y, contentRect.w, 30), "Load").isReleased {
        loadPortal(editor, editor.potentialPortal)
      }
    } else {
      drawButtonInactive(editor, rect.mk(position.x, position.y, contentRect.w, 30), "Hold shift!")
    }

    uiEndWindow(editor)
  }
}

fn loadEditorResources(rl: ^d_resources.ResourceLoader): EditorResources

fn showErrorScreenIfResourcesFailedToLoad(rl: ^d_resources.ResourceLoader) {
  if d_resources.hasErrors(rl) {
    d_problem_screen.showResourceLoadingError(rl)
  }
}

fn editorPutUi(editor: ^Editor) {
  // Clear the input sink.
  editor.inputSink = InputSink{}

  if input.isPressed(input.key_ctrl) {
    if input.isJustPressed(input.key_escape) {
      input.clear(input.key_escape)
      editor.isDebugOverlayShown = !editor.isDebugOverlayShown
    }
  } 

  if (input.isJustPressed(input.key_escape)) {
    deselectEntity(&editor.entities)
  }

  if (input.isJustPressed(input.key_delete)) {
    input.clear(input.key_delete)
    if editor.entities.entitySelected > 0 {
      removeEntity(&editor.entities, editor.entities.entitySelected)
    }
  }

  editor.mouseState = editor.mouseState.updated()

  editor.frameNumber += 1;

  // put ui
  if editor.isPlaying {
    d_game.update()
    d_script.update()

    editor.ctx.drawCustom(GameCmd{})
  } else {
    tool := editor.beginTool("TileEditor", rect.mk(0, 0, d_global.screen.w, d_global.screen.h-34))

    selectedTile := editor.tileGrid.put(editor, tool.rect)

    putWorldEntities(editor)

    // Draw ToggleAll/FG/MG/BG buttons.
    {
      const padding = 10
      const elementSize = 30

      position := tool.rect.getEnd().subf(padding).subf(elementSize)



      if (putSimpleButton(editor, rect.mk(position.x, position.y, elementSize, elementSize), "BG", editor.tilemapLayer == -1).isReleased) {
        editor.tilemapLayer = -1
      }
      position.x -= elementSize

      if (putSimpleButton(editor, rect.mk(position.x, position.y, elementSize, elementSize), "MG", editor.tilemapLayer == 0).isReleased) {
        editor.tilemapLayer = 0
      }
      position.x -= elementSize

      if (putSimpleButton(editor, rect.mk(position.x, position.y, elementSize, elementSize), "FG", editor.tilemapLayer == 1).isReleased) {
        editor.tilemapLayer = 1
      }
      position.x -= elementSize

      if (putSimpleButton(editor, rect.mk(position.x, position.y, elementSize, elementSize), "", editor.tilemapShowAllLayers).isReleased) {
        editor.tilemapShowAllLayers = !editor.tilemapShowAllLayers
      }

      drawLayerIcon(&editor.ctx, position.add(th.Vf2{1, 5}), editor.tilemapLayer, editor.tilemapShowAllLayers)
      position.x -= elementSize

      if (putSimpleButton(editor, rect.mk(position.x, position.y, elementSize, elementSize), "✋", editor.isIgnoringGuides).isReleased) {
        editor.isIgnoringGuides = !editor.isIgnoringGuides;
      }
    }

    editor.ctx.moveLayer(-1)
    editor.ctx.drawCustom(WorldEditCmd{getShownLayersBitmap(editor.tilemapLayer, editor.tilemapShowAllLayers), editor.resources.toolbarIcons, tool.rect, editor.tileGrid.mapPos(th.Vf2{0, 0}), &editor.world})
    editor.ctx.moveLayer(1)

    events := editor.endTool()

    if editor.isRelocatingPlayer {
      if (events.queryMouse(0, d_mouseinput.down)) {
        editor.world.playerSpawnPos = selectedTile
      }
      if (events.queryMouse(0, d_mouseinput.released)) {
        editor.isRelocatingPlayer = false
      }
    } else {
      if events.queryMouse(0, d_mouseinput.down) {
        editor.world.setTile(editor.tilemapLayer, trunc(selectedTile.x), trunc(selectedTile.y), editor.tileset.tileToPos(trunc(editor.tileSelected.x), trunc(editor.tileSelected.y)))
      }
      if events.queryMouse(2, d_mouseinput.down) {
        editor.world.setTile(editor.tilemapLayer, trunc(selectedTile.x), trunc(selectedTile.y), 0)
      }
    }

  }
  editorPutToolbar(editor)

  if !editor.isPlaying {
    putTilePicker(editor)
    putPlayerPlacer(editor)
    putEntityList(editor)
    putEntityEditor(editor)
    putPortalEditor(editor)
  }

  if editor.isRelocatingPlayer {
    editor.ctx.moveLayer(10000000)
    editor.resources.toolbarIcons.crop(th.Vf2{2.0/4.0, 0.0/4.0}, th.Vf2{3.0/4.0, 1.0/4.0})
    editor.ctx.drawImage(editor.resources.toolbarIcons, d_util.posTrans(editor.mouseState.pos.x, editor.mouseState.pos.y))
    editor.ctx.moveLayer(-10000000)
  }
 
  // put debug overlays
  if (editor.isDebugOverlayShown) {
    putEditorDebugToolFrames(editor)
  }

  // flush render context
  editor.ctx.flush()

  // swap frame census
  if !isAnyButtonHeld(&editor.mouseState) {
    editor.activeTool = editor.maybeActiveTool
  }
  editor.hoveredTool = editor.maybeActiveTool
  editor.maybeActiveTool = null
  editor.pruneToolsRecursive(editor.tools)
}

// Disconnects all nodes in the editor from their parents.
// Due to how the Umka GC currently works, it's not able to collect
//   circular references, so I must do it myself.
fn editorDisconnectAllNodes(editor: ^Editor, node: ^ToolNode) {
  if node == null {
    node = editor.tools
  }

  node.parent = null
  for _, child in node.children {
    editorDisconnectAllNodes(editor, child)
  }
}

fn loadEditorResources(rl: ^d_resources.ResourceLoader): EditorResources {

  editorResources := EditorResources {
    bevelImage: d_resources.loadImage(rl, "data/img/ui_bevelbutton.png"),
    tilesetImage: d_resources.loadImage(rl, "data/img/ts_sky.png"),
    toolbarIcons: d_resources.loadImage(rl, "data/img/ui_trayicons.png"),
    mainFont: d_resources.loadFont(rl, "data/font/monospace.ttf", 16, 0)}
 
  editorResources.tilesetImage.setfilter(0)

  return editorResources
}

fn editorInit(resources: EditorResources): Editor {
  rootNode := new(ToolNode)
  rootNode ^= ToolNode{children: map[str]^ToolNode{}}

  tileset := d_tileset.fromImage(resources.tilesetImage, 32, 32, 0.5)
  world := d_world.fromTileset(tileset)

  return Editor{
    ctx: e_drawcmd.init(),
    tileGrid: EditorGrid{scaling: 1.0},
    tilemapGrid: EditorGrid{scaling: 1.0},
    tilemapShowAllLayers: true,
    isIgnoringGuides: true,
    tileset: tileset,
    world: world,
    resources: resources,
    entities: createEditorEntities(),
    wm: initWindowManager(),
    tools: rootNode}
}

type PushText = struct {
  font: th_font.Font
  initPos: th.Vf2
  pos: th.Vf2
  indents: int
  lineHeight: real
}

fn mkPushText(font: th_font.Font, pos: th.Vf2): PushText {
  return PushText{font, pos, pos, 0, font.measure(" ").y}
}

fn (pushy: ^PushText) push(txt: str, color: uint32 = 0xFFFFFFFF): rect.Rect {
  pushy.font.draw(txt, pushy.pos, color)
  size := pushy.font.measure(txt)
  if size.y > pushy.lineHeight {
    pushy.lineHeight = size.y
  }

  if len(e_buffer.textSplitBy(txt, '\n')) > 1 {
    canvas.drawRect(color&0xFFFFFF7F, rect.mk(pushy.pos.x-1, pushy.pos.y, 1, size.y))
  }

  pushy.pos.x += size.x
  return rect.mk(pushy.pos.x-size.x, pushy.pos.y, size.x, size.y)
}


fn (pushy: ^PushText) shouldWrap(): bool {
  return pushy.pos.x - pushy.initPos.x > 200
}

fn (pushy: ^PushText) newLine() {
  pushy.pos.y += pushy.lineHeight
  pushy.lineHeight = pushy.font.measure(" ").y
  pushy.pos.x = pushy.indents*30+pushy.initPos.x
}

fn (pushy: ^PushText) indent(by: int) {
  pushy.indents += by
}

fn valueTypeName(value: interface{}): str {
  if ^[]interface{}(value) != null {
    return "array"
  } 
  if ^map[str]interface{}(value) != null {
    return "map"
  }
  if ^int(value) != null {
    return "int"
  }
  if ^str(value) != null {
    return "str"
  }
  if ^real(value) != null {
    return "real"
  }
  if ^bool(value) != null {
    return "bool"
  }
  return ""
}

fn representString(s: str): str {
  result := ""
  split := e_buffer.textSplitBy(s, '\n')
  for i, item in split {
    result += item
    if i != len(split)-1 {
      result += '\n'
    }
  }

  if len(split) == 1 {
    return "\""+result+"\""
  }

  return "\"\"\""+result+"\"\"\""
}

fn drawEnv(pushy: ^PushText, hover: ^str, env: interface{}) {
  if arrValue := ^[]interface{}(env); arrValue != null {
    pushy.push(sprintf("["))
    pushy.indent(1)
    pushy.newLine()

    for i in arrValue {
      drawEnv(pushy, hover, arrValue[i])
      if i != len(arrValue^)-1 {
        pushy.push(", ")
        if pushy.shouldWrap() {
          pushy.newLine()
        }
      }
    }

    pushy.indent(-1)
    pushy.newLine()
    pushy.push("]")
  } else if mapValue := ^map[str]interface{}(env); mapValue != null {
    pushy.push(sprintf("{"))
    pushy.indent(1)
    pushy.newLine()

    i := 0
    keyCount := len(keys(mapValue^))
    for k in mapValue {
      if d_util.isMouseInRect(pushy.push(k, 0xFF007FFF)) {
        hover ^= valueTypeName(mapValue[k])
      }
      pushy.push(sprintf(" = "))
      drawEnv(pushy, hover, mapValue[k])
      if i != keyCount-1 {
        pushy.push(", ")
        pushy.newLine()
      }
      i++
    }

    pushy.indent(-1)
    pushy.newLine()
    pushy.push("}")
  } else if boolValue := ^bool(env); boolValue != null {
    represented := repr(env)

    color := 0xFF0040FF
    if boolValue^ {
      color = 0x00FF40FF
    }

    if d_util.isMouseInRect(pushy.push(slice(represented, 0, len(represented)-1), color)) {
      hover ^= valueTypeName(env)
    }
  } else if strValue := ^str(env); strValue != null {

    if d_util.isMouseInRect(pushy.push(representString(strValue^), 0x007FFFFF)) {
      hover ^= valueTypeName(env)
    }
  } else {
    represented := repr(env)

    if d_util.isMouseInRect(pushy.push(slice(represented, 0, len(represented)-1), 0xFFFF00FF)) {
      hover ^= valueTypeName(env)
    }
  }
}

fn getFps*(): int {
  fps := 0
  
  // FIXME: Currently toml only supports strings so I have to call atoi
  if fpsProp := ^int(d_config.getProperty("fps")); fpsProp != null {
    fps = fpsProp^
  }

  if fps <= 0 {
    return 60
  }
  
  return fps;
}

fn drawTooltip(font: th_font.Font, pos: th.Vf2, tooltip: str) {
  size := font.measure(tooltip)
  r := rect.mk(pos.x, pos.y, size.x, size.y)

  canvas.drawRect(th.white, d_util.rectShrink(r, -1))
  canvas.drawRect(th.black, d_util.rectShrink(r, 0))
  font.draw(tooltip, pos, th.white)
}

fn editorMain*() {
  std.srand(std.time())

  d_global.screen = rect.mk(0, 0, 800, 600)
  window.setup("Editor", trunc(d_global.screen.w), trunc(d_global.screen.h))

  // init data
  rl := d_resources.initResourceLoader()
  d_background.init(&rl)
  d_game.init(&rl)

  editor := editorInit(loadEditorResources(&rl))
  loadPortal(&editor, "genesis")
  showErrorScreenIfResourcesFailedToLoad(&rl)

  // cycle
  for window.cycle(d_global.screen) {
    d_fps.limit(60)
    d_fps.update()

    // NOTE(skejeton): Clamping delta to 50 gives generally consistent physics and reduces jitter.
    // TODO(skejeton): I may change this at some point, since the physics are likely to be re written. 
    if th.delta > 50 {
      th.delta = 50
    }
    
    d_global.screen = rect.mk(0, 0, window.w, window.h)

    editorPutUi(&editor)

    editor.resources.mainFont.draw(sprintf("%dfps", trunc(d_fps.getFps())), th.Vf2{0, 1}, th.black)
    editor.resources.mainFont.draw(sprintf("%dfps", trunc(d_fps.getFps())), th.Vf2{0, 0}, th.white)

    if d_config.checkFlag(d_config.flagDebugOverlays) {
      canvas.drawRect(th.black, rect.mk(50, 50, 500, 500))
      hover := ""
      drawEnv(&mkPushText(editor.resources.mainFont, th.Vf2{50, 50}), &hover, d_config.getTree())
      if hover != "" {
        drawTooltip(editor.resources.mainFont, editor.mouseState.pos.addf(10), hover)
      }
    }
  }

  editorDisconnectAllNodes(&editor, null)
}
