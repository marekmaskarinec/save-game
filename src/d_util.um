import (
  "image.um"; "std.um"; "th.um"; "rect.um"; "input.um"; "canvas.um"; "utf8.um"
)

fn posTrans*(x, y: th.fu): th.Transform {
  return th.Transform{p: th.Vf2{x, y}, s: th.Vf2{1, 1}}
}

fn isMouseInRect*(r: rect.Rect): bool {
  p := input.getMousePos()
  return p.x >= r.x && p.y >= r.y && p.x <= (r.x+r.w) && p.y <= (r.y+r.h)
}

fn readFileStr*(path: str): str {
  file := std.fopen(path, "r")
  if file == null {
    error("Failed to open file")
  }
  std.fseek(file, 0, std.seekEnd)
  datasiz := std.ftell(file)
  std.fseek(file, 0, std.seekBegin)
  buffer := make([]uint8, datasiz)
  std.fread(file, buffer)
  data := ""
  
  for i in buffer {
    data += char(buffer[i])
  }
  
  return data
}

fn writeFileStr*(path: str, dataStr: str): bool {
  file := std.fopen(path, "w")
  if file == null {
    error("Failed to open file")
  }
  data := make([]uint8, 0)
  for i in dataStr {
    data = append(data, uint8(dataStr[i]))
  }
  std.fwrite(file, data)
  std.fclose(file)

  return true
}

fn drawRectLines*(color: uint32, r: rect.Rect) {
  // top
  canvas.drawRect(color, rect.Rect{r.x, r.y, r.w, 1})
  // bottom
  canvas.drawRect(color, rect.Rect{r.x, r.y+r.h-1, r.w, 1})
  // left
  canvas.drawRect(color, rect.Rect{r.x, r.y+1, 1, r.h-1})
  // right
  canvas.drawRect(color, rect.Rect{r.x+r.w-1, r.y+1, 1, r.h-1})
}

fn rectChopRight*(r: ^rect.Rect, by: int): rect.Rect {
  r.w -= by
  return rect.Rect{r.x+r.w, r.y, by, r.h}
}

// Crops the input image by specified rectangle in pixels
// 
// img: Input image
// rec: Cropping rectangle, in pixels
//
fn imageCropRect*(img: image.Image, rec: rect.Rect) {
  size := img.getDims()
  img.crop(th.Vf2{rec.x/size.x, rec.y/size.y}, th.Vf2{(rec.x + rec.w)/size.x, (rec.y + rec.h)/size.y})
}

//
// Returns lowest number among a, b
//
fn fmin*(a, b: real): real {
  if a < b {
    return a
  }
  return b
}

//
// Returns highest number among a, b
//
fn fmax*(a, b: real): real {
  if a > b {
    return a
  }
  return b
}

//
// Fmod(
//   Divident
//   Divisor
// )
// 
// floating point modulo
//
fn fmod*(a, b: real): real {
  rem := a / b
  return (rem-floor(rem)) * b
}

// 
// Takes `size` characters (Runes) out of UTF-8 string `s` and returns the slice
// 
// s: Input UTF-8 encoded string
// size: Amount of UTF-8 encoded runes to take
//
fn chopUtf8*(s: str, size: int): str {
  ofs := 0
  for size > 0 && ofs < len(s) {
    rune := utf8.getNextRune(s, ofs)
    ofs += rune.size()
    size -= 1
  }
  return slice(s, 0, ofs)
}

// Rect vs rect(
//   First rect
//   Second rect
// )
//
// Returns true if both rects collide
fn rectVsRect*(r1, r2: rect.Rect): bool {
  return (r1.x + r1.w) > (r2.x) && (r1.y + r1.h) > (r2.y) && (r1.x) < (r2.x + r2.w) && (r1.y) < (r2.y + r2.h)
}

// Rect vs point(
//   Rect
//   Point
// )
//
// Returns true if point p is in rectangle r
fn rectVsPoint*(r: rect.Rect, p: th.Vf2): bool {
  return p.x > r.x && p.y > r.y && p.x < (r.x + r.w) && p.y < (r.y + r.h)
}

// Rect shrink(
//   Rect,
//   Shrink by
// )
// 
// Returns rectangle shrinked by amount `by` from all left, right, top, bottom sides
fn rectShrink*(r: rect.Rect, by: real): rect.Rect {
  return rect.mk(r.x+by, r.y+by, r.w-by*2, r.h-by*2)
}

// Rect move(
//   Rect,
//   Move by
// ) 
//
// Returns rectangle moved by amount `by`
fn rectMove*(r: rect.Rect, by: th.Vf2): rect.Rect {
  return rect.Rect{r.x+by.x, r.y+by.y, r.w, r.h}
}