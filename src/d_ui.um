import (
  "std.um"
  "th.um"; "rect.um"; "canvas.um"; "input.um"; "window.um"; "image.um"
  "d_font.um"; "d_fps.um"
)

type (
  Scrolling = struct {
    scroll: real
    limit: real
    targetScroll: real
  }

  Window = struct {
    title: str
    rect: rect.Rect
    scroll: Scrolling
    visibilityStatus: int // 0 = hidden, 1 = shown last frame, 2 = shown this frame
  }

  Group = struct {
    index: int
    windows: []Window
    current: uint
    rect: rect.Rect
    tabWidth: real //width of tabs total
    tabScroll: Scrolling
  }

  GroupZone = struct {
    /* base */
    groups: map[str]^Group // Window name to group
    stack: []^Group 
    join: bool
    firstJoin: bool
    dockGroups: bool
    canDock: bool
    undockGroups: bool

    undockWindow: str
    currentDockingGroup: ^Group
    currentDockingCandidate: ^Group
    currentActiveGroup: ^Group
    currentActiveCandidateGroup: ^Group
    currentDraggingGroup: ^Group
    currentGroup: ^Group
    currentWindow: str
  }

  ButtonState = struct {
    over: bool
    down: bool
    pressed: bool
    released: bool       
  }

  InputState = struct {
    mousePos: th.Vf2
    mouseDelta: th.Vf2
    mouseScroll: int

    mouseMiddle: ButtonState
    mouseLeft: ButtonState
    mouseRight: ButtonState
  }

  DrawCommand = struct {
    color: uint32
    rect: rect.Rect
    text: str
    img: image.Image
  }

  DrawLayer = struct {
    commands: []DrawCommand
    index: int // Layer ordering for sorting
  }

  DrawCtx = struct {
    layers: []DrawLayer 
  }

  SequenceLayout = struct {
    start: th.Vf2
    end: th.Vf2
    lineHeight: th.fu
    maxX: th.fu
  }

  UiLayoutType = int

  UiLayout = struct {
    position: th.Vf2 
    elementsPerRow: int
    rowHeight: real
    layoutType: UiLayoutType
    bounds: rect.Rect
    elementRef: int
    scroll: th.Vf2
    auto: bool
  }

  UiState = struct {
    groupIndex: int
    drawCtx: ^DrawCtx
    inputState: InputState
    elements: []rect.Rect
    cropRects: []rect.Rect
    layouts: []UiLayout
  }
)

const (
  uiLayoutTypeColumn = UiLayoutType(0)
  uiLayoutTypeFixedRow = UiLayoutType(1)
  uiLayoutTypeDynamicRow = UiLayoutType(2)
  uiLayoutTypeScreen = UiLayoutType(4)

  c_shadow = 0x00000022
  c_decor = 0x752f29FF
  c_item = 0x993333FF
  c_held = 0xC24444FF
  c_over = 0xAD4545FF
  c_fore = 0x000000FF
  c_body = th.white

  magicColorBeginScissorRect = 0x5B248E00
  magicColorEndScissorRect = 0x896A4100
)

///////////////////////
// Utility
fn rectVsRect(r1, r2: rect.Rect): bool {
  return (r1.x + r1.w) > (r2.x) && (r1.y + r1.h) > (r2.y) && (r1.x) < (r2.x + r2.w) && (r1.y) < (r2.y + r2.h)
}

fn rectInPoint(r: rect.Rect, p: th.Vf2): bool {
  return p.x > r.x && p.y > r.y && p.x < (r.x + r.w) && p.y < (r.y + r.h)
}

fn rectInset(r: rect.Rect, by: real): rect.Rect {
  return rect.mk(r.x+by, r.y+by, r.w-by*2, r.h-by*2)
}

fn rectMove(r: rect.Rect, by: th.Vf2): rect.Rect {
  return rect.Rect{r.x+by.x, r.y+by.y, r.w, r.h}
}

////////////////////////////
// SequenceLayout

fn sequenceLayoutInit(pos: th.Vf2): SequenceLayout {
  return SequenceLayout{start: pos, end: pos}
}

fn (lay: ^SequenceLayout) newLine() {
  lay.end = th.Vf2{lay.start.x, lay.end.y + lay.lineHeight}
  lay.lineHeight = 0
}

fn (lay: ^SequenceLayout) getRect(): rect.Rect {
  return rect.mk(lay.start.x, lay.start.y, lay.maxX-lay.start.x, (lay.end.y-lay.start.y)+lay.lineHeight)
}

fn (lay: ^SequenceLayout) put(size: th.Vf2) {
  if (lay.lineHeight < size.y) {
    lay.lineHeight = size.y
  }

  lay.end.x += size.x;

  if (lay.maxX < lay.end.x) {
    lay.maxX = lay.end.x;
  }
}

fn (lay: ^SequenceLayout) padding(by: th.fu) {
  by = by - (trunc(lay.end.x-lay.start.x) % trunc(by))
  lay.put(th.Vf2{by, 0})
}

/////////////////////////////
// Scroll

fn scrollFix(scroll: ^Scrolling) {
  if scroll.targetScroll < scroll.limit {
    scroll.targetScroll = scroll.limit
  }
}

fn scrollLimit(scroll: ^Scrolling, to: real) {
  // Fix negative scroll
  if to > 0 {
    to = 0
  }
  scroll.limit = to
}

fn scrollBy(scroll: ^Scrolling, by: real) {
  scroll.targetScroll += by;
  if scroll.targetScroll > 0 {
    scroll.targetScroll = 0
  }
  scrollFix(scroll)
}

fn scrollUpdate(scroll: ^Scrolling) {
  speed := 10

  if (scroll.scroll < scroll.limit) {
    speed *= 3
  }

  scroll.scroll += (scroll.targetScroll-scroll.scroll)*(th.delta/1000.0)*speed;

  scrollFix(scroll)
}

/////////////////////////////
// Draw*

fn layerFromCommand(index: int, cmd: DrawCommand): DrawLayer {
  return DrawLayer{index: index, commands: []DrawCommand{cmd }}
}

fn drawCtxInit(): DrawCtx {
  return DrawCtx{layers: []DrawLayer{ }}
}

fn commandRect(color: uint32, r: rect.Rect): DrawCommand {
  return DrawCommand{color: color, rect: r, text: ""}
}

fn commandBeginScissorRect(r: rect.Rect): DrawCommand {
  return DrawCommand{color: magicColorBeginScissorRect, rect: r}
}

fn commandEndScissorRect(): DrawCommand {
  return DrawCommand{color: magicColorEndScissorRect}
}

fn commandText(color: uint32, r: rect.Rect, t: str): DrawCommand {
  return DrawCommand{color: color, rect: r, text: t}
}

fn commandImage(r: rect.Rect, img: image.Image, tint: uint32 = th.white): DrawCommand {
  return DrawCommand{color: tint, rect: r, img: img}
}

fn (lay: ^DrawLayer) putCommand(cmd: DrawCommand) {
  lay.commands = append(lay.commands, cmd);
}

fn (ctx: ^DrawCtx) clear() {
  ctx.layers = []DrawLayer{}
}

fn (ctx: ^DrawCtx) putCommand(index: int, cmd: DrawCommand) {
  pushIndex := 0

  for i in ctx.layers {
    if ctx.layers[i].index > index {
      break
    }
    if ctx.layers[i].index == index { // found exact layer
      ctx.layers[i].putCommand(cmd)
      return
    }
    pushIndex += 1
  }

  if pushIndex == len(ctx.layers) {
    ctx.layers = append(ctx.layers, layerFromCommand(index, cmd))
  } else {
    newLayers := make([]DrawLayer, 0)
    for i in ctx.layers {
      if i == pushIndex {
        newLayers = append(newLayers, layerFromCommand(index, cmd))
      }
      newLayers = append(newLayers, ctx.layers[i])
    }
    ctx.layers = newLayers
  }
}

fn (ctx: ^DrawCtx) render(font: d_font.Font) {
  for i in ctx.layers {
    rectStack := make([]rect.Rect, 0)
    isScissor := false
    scissorRect := rect.Rect{}

    layer := &ctx.layers[i]
    for j, cmd in layer.commands {
      // dont draw whats not visible
      if cmd.color != magicColorBeginScissorRect && cmd.color != magicColorEndScissorRect && isScissor && !rectVsRect(cmd.rect, scissorRect) {
        continue
      }

      if cmd.color == magicColorBeginScissorRect {
        if isScissor {
          rectStack = append(rectStack, scissorRect)
        }
        isScissor = true
        scissorRect = cmd.rect
        window.beginScissorRect(cmd.rect)
      } else if cmd.color == magicColorEndScissorRect {
        if len(rectStack) > 0 {
          window.beginScissorRect(rectStack[len(rectStack)-1])
          rectStack = delete(rectStack, len(rectStack)-1)
        } else {
          window.endScissor()
          isScissor = false
        }
      } else if cmd.text != "" { // draw text
        size := font.measure(cmd.text)
        canvas.drawRect(th.red, rect.mk(cmd.rect.x+(cmd.rect.w-size.x)/2, cmd.rect.y+(cmd.rect.h-size.y)/2, size.x, size.y));
        font.draw(cmd.text, th.Vf2{cmd.rect.x+(cmd.rect.w-size.x)/2, cmd.rect.y+(cmd.rect.h-size.y)/2}, cmd.color)
      } else if cmd.img.validate() {
        // TODO: Maybe separate drawing the image as a rectangle into a separate function

        size := cmd.img.getDims()
        scale := th.Vf2{1/size.x*cmd.rect.w, 1/size.y*cmd.rect.h}
        pos := cmd.rect.getPos()
        pos.x = round(pos.x)
        pos.y = round(pos.y)
        
        cmd.img.draw(th.Transform{p: pos, s: scale})
      } else { // draw rect
        canvas.drawRect(cmd.color, cmd.rect)
      }
    }

    if isScissor {
      window.endScissor()
    }

    if len(rectStack) > 0 {
      error("Umatched endScissor");
    }
  }
}

///////////////////////
// Group
fn groupCreateFromWindow(win: Window): Group {
  windows := make([]Window, 1)
  windows[0] = win
  return Group{windows: windows, current: 0, rect: win.rect}
}

fn groupGetCurrentWindow(group: ^Group): ^Window {
  return &group.windows[group.current]
}

fn groupFindWindowIndex(group: ^Group, title: str): int {
  for i in group.windows {
    if group.windows[i].title == title {
      return i
    }
  }
  return -1
}

fn groupFindWindow(group: ^Group, title: str): ^Window {
  index := groupFindWindowIndex(group, title)
  if index < 0 {
    return null
  }
  return &group.windows[index]
}

fn groupAppendWindow(group: ^Group, win: Window) {
  group.windows = append(group.windows, win) 
}

///////////////////////
// Group Zone
fn groupZoneInit(): GroupZone {
  return GroupZone{groups: map[str]^Group{}, stack: make([]^Group, 0)}
}

fn groupZoneCreate(zone: ^GroupZone, win: Window): ^Group {
  newGroup := new(Group)
  newGroup ^= groupCreateFromWindow(win)
  zone.groups[win.title] = newGroup
  newGroup.index = len(zone.stack)
  zone.stack = append(zone.stack, newGroup)

  return newGroup 
}

fn groupZoneAcquire(zone: ^GroupZone, title: str, r: rect.Rect): ^Group {
  group := zone.groups[title]

  if group == null {
    if len(zone.stack) > 0 && zone.join && !zone.firstJoin {
      zone.groups[title] = zone.stack[len(zone.stack)-1]
      group = zone.groups[title]
      groupAppendWindow(zone.stack[len(zone.stack)-1], Window{title: title, rect: r})
    } else {
      zone.firstJoin = false
      group = groupZoneCreate(zone, Window{title: title, rect: r})
    }
  }
  
  return group
}

fn groupZoneReassignIndices(zone: ^GroupZone) {
  for i in zone.stack { 
    zone.stack[i].index = i
  }
}

fn groupZoneMoveToFront(zone: ^GroupZone, groupIndex: int): int {
  group := zone.stack[groupIndex]
  zone.stack = delete(zone.stack, groupIndex)
  zone.stack = append(zone.stack, group)

  groupZoneReassignIndices(zone)

  return group.index
}

fn groupZoneSetJoin(zone: ^GroupZone, set: bool) {
  zone.join = set
  zone.firstJoin = true
}

fn groupZoneUndockWindow(zone: ^GroupZone, title: str): ^Group {
  group := zone.groups[title]
  index := groupFindWindowIndex(group, title)

  if (index < 0) {
    error("Invalid index")
  }

  if (group.current >= index && group.current > 0) {
    group.current -= 1
  }

  win := group.windows[index]
  group.windows = delete(group.windows, index)

  return groupZoneCreate(zone, win);
}

fn groupZoneDockGroups(zone: ^GroupZone, srcIdx: int, dstIdx: int) {
  dst := zone.stack[dstIdx]
  src := zone.stack[srcIdx]

  for i, win in src.windows {
    zone.groups[win.title] = dst
    dst.windows = append(dst.windows, win)
  }

  zone.stack = delete(zone.stack, srcIdx)

  groupZoneReassignIndices(zone)
}

fn groupZoneBegin(zone: ^GroupZone, title: str, r: rect.Rect): bool {
  shouldRender := false

  acquired := groupZoneAcquire(zone, title, r)
  windowIndex := groupFindWindowIndex(acquired, title)
  if windowIndex == acquired.current {
    zone.currentGroup = acquired
    zone.currentWindow = title

    shouldRender = true
  }

  acquired.windows[windowIndex].visibilityStatus = 2

  return shouldRender
} 

fn groupZoneEnd(zone: ^GroupZone): bool {
  if zone.currentGroup != null {
    zone.currentWindow = ""
    zone.currentGroup = null
    return true
  }
  return false
}

fn groupZoneUpdate(zone: ^GroupZone) {
  if zone.currentDraggingGroup != null {
    groupZoneMoveToFront(zone, zone.currentDraggingGroup.index)
  }
  if zone.dockGroups && zone.currentDockingGroup != null && zone.currentDraggingGroup != null {
    groupZoneDockGroups(zone, zone.currentDraggingGroup.index, zone.currentDockingGroup.index)
    zone.currentDraggingGroup = null
  }
  if zone.dockGroups {
    zone.currentDraggingGroup = null
  } 
  zone.dockGroups = false
  zone.currentActiveGroup = zone.currentActiveCandidateGroup
  zone.currentActiveCandidateGroup = null


  zone.currentDockingGroup = zone.currentDockingCandidate
  zone.currentDockingCandidate = null

  if zone.currentDockingGroup == zone.currentActiveGroup {
    zone.currentDockingGroup = null
  }
}

fn groupZoneBeginFrame(zone: ^GroupZone, delta: th.Vf2, mousePos: th.Vf2) {
  if zone.undockGroups && zone.undockWindow != "" {
    zone.currentDraggingGroup = groupZoneUndockWindow(zone, zone.undockWindow)
    zone.currentActiveGroup = zone.currentDraggingGroup

    // FIXME: this is really bad because it relies on certain type of visual info
    zone.currentDraggingGroup.rect.x = mousePos.x-10
    zone.currentDraggingGroup.rect.y = mousePos.y-10
  } else if zone.currentDraggingGroup != null {
    zone.currentDraggingGroup.rect.x += delta.x
    zone.currentDraggingGroup.rect.y += delta.y
  }
  zone.undockGroups = false
}

fn groupZoneReportInput(zone: ^GroupZone, overTab: str, overBody: bool, overTitlebar: bool, isDown: bool, isPressed: bool, isReleased: bool) {
  if (overTab != "" || overTitlebar) && zone.currentGroup != zone.currentActiveGroup {
    if zone.currentDockingGroup == null || zone.currentDockingGroup.index <= zone.currentGroup.index  {
      zone.currentDockingCandidate = zone.currentGroup
    }
  }

  overWindow := overTab != "" || overTitlebar  || overBody
  if overWindow {
    if zone.currentActiveCandidateGroup != null {
      // Check overlap
      if zone.currentActiveCandidateGroup.index < zone.currentGroup.index {
        zone.currentActiveCandidateGroup = zone.currentGroup
      }
    } else {
      zone.currentActiveCandidateGroup = zone.currentGroup
    }
  }

  if zone.currentActiveGroup == zone.currentGroup {
    if !overTitlebar && overTab == "" {
      zone.undockGroups = true
    }

    zone.canDock = overTitlebar
    if isPressed {
      if overTab != "" {
        zone.undockWindow = overTab
      } else if overTitlebar || overBody {
        zone.currentDraggingGroup = zone.currentGroup
      }
    } else if isReleased {
      zone.undockWindow = ""
      if overTab != "" {
        zone.currentActiveGroup.current = groupFindWindowIndex(zone.currentActiveGroup, overTab)
      } else if overTitlebar {
        zone.dockGroups = true
      } else {
        zone.currentDraggingGroup = null
      }
    } 
  }
}


///////////////////////
// UI
fn uiInit(drawCtx: ^DrawCtx): UiState {
  return UiState{cropRects: make([]rect.Rect, 0), elements: make([]rect.Rect, 0), layouts: make([]UiLayout, 0), drawCtx: drawCtx};
}

fn uiPutCommand(ui: ^UiState, command: DrawCommand) {
  ui.drawCtx.putCommand(ui.groupIndex, command)
}

fn uiBegin(ui: ^UiState, inputState: InputState) {
  // (1) Not really necessary, but good for debugging so you can immediately spot something's wrong
  ui.groupIndex = -1 // (1)

  if len(ui.layouts) > 0 {
    error("unfinished ui layouts\n")
  }

  ui.inputState = inputState
}

fn uiEnd(ui: ^UiState) {

}

fn uiBeginGroup(ui: ^UiState, zIndex: int) {
  ui.groupIndex = zIndex
}

fn uiLayoutTypeName(t: UiLayoutType): str {
  switch t {
    case uiLayoutTypeColumn: return "column"
    case uiLayoutTypeFixedRow: return "fixed row"
    case uiLayoutTypeDynamicRow: return "dynamic row"
    case uiLayoutTypeScreen: return "screen"
  }
  return "unknown layout"
}

fn uiCurrentLayout(ui: ^UiState): ^UiLayout {
  if len(ui.layouts) > 0 {
    return &ui.layouts[len(ui.layouts)-1]
  }
  return null
}

fn uiCurrentElement(ui: ^UiState): rect.Rect {
  if len(ui.elements) > 0 {
    return ui.elements[len(ui.elements)-1]
  }
  error("Element stack is empty")
  return rect.Rect{}
}

fn uiCalculateElementFromLayout(ui: ^UiState, layout: ^UiLayout, size: th.Vf2, margin: real): rect.Rect {
  if layout == null {
    return rect.mk(margin, margin, size.x-margin*2, size.y-margin*2)
  }
  // (1) NOTE: for now here the positions are relative to the base rect 
  resultRect := rect.mk(layout.position.x, layout.position.y, size.x, size.y)
  baseRect := layout.bounds

  switch layout.layoutType {
    case uiLayoutTypeColumn:
      if resultRect.w < baseRect.w {
        resultRect.w = baseRect.w
      }

      layout.position.y += resultRect.h
    case uiLayoutTypeFixedRow:
      elementsPerRow := real(layout.elementsPerRow)
      if elementsPerRow <= 0 {
        elementsPerRow = 1
      }

      resultRect.w = baseRect.w / elementsPerRow;
      
      if !layout.auto && (resultRect.x+resultRect.w-1) > baseRect.w { // wrap around
        resultRect.x = 0
        resultRect.y += layout.rowHeight
        layout.position.y += layout.rowHeight
        layout.position.x = 0
        layout.rowHeight = 0
      }

      if resultRect.h > layout.rowHeight {
        layout.rowHeight = resultRect.h
      }

      layout.position.x += baseRect.w / elementsPerRow
    case uiLayoutTypeDynamicRow:
      if !layout.auto && (resultRect.x+resultRect.w) > baseRect.w { // wrap around
        resultRect.x = 0
        resultRect.y += layout.rowHeight
        layout.position.y += layout.rowHeight
        layout.position.x = 0
        layout.rowHeight = 0
      }

      if resultRect.h > layout.rowHeight {
        layout.rowHeight = resultRect.h
      }

      layout.position.x += resultRect.w
    case uiLayoutTypeScreen:
  }

  // (1) ... Then they are transformed to the absolute position.
  resultRect.x += baseRect.x+layout.scroll.x+margin
  resultRect.y += baseRect.y+layout.scroll.y+margin

  resultRect.w -= margin*2
  resultRect.h -= margin*2

  return resultRect
}

fn uiCalculateElement(ui: ^UiState, size: th.Vf2, margin: real = 0): rect.Rect {
  currentLayout := uiCurrentLayout(ui)^

  return uiCalculateElementFromLayout(ui, &currentLayout, size, margin)
}

// Adds an element into the UI and advances the layout.
fn uiPushElement(ui: ^UiState, size: th.Vf2, margin: real = 0): rect.Rect {
  resultRect := uiCalculateElementFromLayout(ui, uiCurrentLayout(ui), size, margin)
  ui.elements = append(ui.elements, resultRect)

  return resultRect
}

fn uiPopElement(ui: ^UiState) {
  if len(ui.elements) > 0 {
    ui.elements = delete(ui.elements, len(ui.elements)-1)
    return
  }

  error("Element stack is empty")
}

fn uiPutElement(ui: ^UiState, size: th.Vf2): rect.Rect {
  r := uiPushElement(ui, size)
  uiPopElement(ui)
  return r
}

fn uiGetBounds(ui: ^UiState): rect.Rect {
  return uiCurrentElement(ui)
}

fn uiGetContentSize(ui: ^UiState): th.Vf2 {
  currentLayout := uiCurrentLayout(ui)
  return currentLayout.position.add(th.Vf2{0, currentLayout.rowHeight})
}

fn uiGetRemainingSize(ui: ^UiState): th.Vf2 {
  bounds := uiCurrentElement(ui).getDims()
  offs := uiCurrentLayout(ui).position
  bounds.y -= offs.y
  bounds.x -= offs.x
  return bounds
}

fn uiGetButtonState(ui: ^UiState): ButtonState {

  buttonState := ButtonState{}
  buttonState.over = rectInPoint(uiGetBounds(ui), ui.inputState.mousePos)
  if len(ui.cropRects) > 0 {
    buttonState.over = buttonState.over && rectInPoint(ui.cropRects[len(ui.cropRects)-1], ui.inputState.mousePos)
  }

  buttonState.down = ui.inputState.mouseLeft.down && buttonState.over;
  buttonState.pressed = ui.inputState.mouseLeft.pressed && buttonState.over;
  buttonState.released = ui.inputState.mouseLeft.released && buttonState.over;
  return buttonState
}

//
// Crops the contents of the base rectangle
// 
// ui: ui state
//
fn uiBeginCropContents(ui: ^UiState) {
  ui.cropRects = append(ui.cropRects, uiGetBounds(ui))
  uiPutCommand(ui, commandBeginScissorRect(uiGetBounds(ui)))
}

//
// Stops cropping the contents
// 
// ui: ui state
//
fn uiEndCropContents(ui: ^UiState) {
  if len(ui.cropRects) == 0 {
    error("Unmatched uiEndCropContents\n")
  }
  ui.cropRects = delete(ui.cropRects, len(ui.cropRects)-1)
  uiPutCommand(ui, commandEndScissorRect())
}

//
// Scrolls the current layout
//
// ui: ui state
// offset: x/y scroll offset
//
fn uiSetScroll(ui: ^UiState, offset: th.Vf2) {
  currentLayout := uiCurrentLayout(ui)
  currentLayout.scroll.x += offset.x
  currentLayout.scroll.y += offset.y
}

fn uiEndLayout(ui: ^UiState, expectedType: UiLayoutType) {
  currentLayout := uiCurrentLayout(ui)^
  currentType := currentLayout.layoutType

  if currentType != expectedType {
    buf := str(make([]char, 256))
    sprintf(buf, "(UI) Layout type mismatch: started with %s but ended with %s", uiLayoutTypeName(currentType), uiLayoutTypeName(expectedType))
    error(buf)
  } else {
    ui.layouts = delete(ui.layouts, len(ui.layouts)-1)
    if len(ui.layouts) > 0 {
      layout := &ui.layouts[len(ui.layouts)-1]

      if currentLayout.elementRef == layout.elementRef && currentLayout.layoutType != uiLayoutTypeScreen {
        layout.position.y = currentLayout.position.y+currentLayout.rowHeight
        layout.position.x = 0
      }
    }
  }
}

fn uiBeginLayout(ui: ^UiState, layoutType: UiLayoutType, elementsPerRow: int = 0, auto: bool = false) {
  currentLayout := uiCurrentLayout(ui)
  newLayout := UiLayout{auto: auto, layoutType: layoutType, elementsPerRow: elementsPerRow, elementRef: len(ui.elements), bounds: uiCurrentElement(ui)}

  if currentLayout != null {
    // FIXME: This is a way to identify if newLayout and currentLayout share the element
    if newLayout.elementRef == currentLayout.elementRef {
      newLayout.scroll = currentLayout.scroll
      newLayout.position.y = currentLayout.position.y
      newLayout.position.x = 0
    }
   // newLayout.position = currentLayout.position.add(currentLayout.bounds.getPos()).sub(newLayout.bounds.getPos())
  }

  ui.layouts = append(ui.layouts, newLayout)
}


fn uiSetCursor(ui: ^UiState, to: th.Vf2) {
  uiCurrentLayout(ui).position = to
}

// Begins a column layout.
// It becomes full width to the parent rectangle and moves on to next row.
fn uiBeginColumn(ui: ^UiState) {
  uiBeginLayout(ui, uiLayoutTypeColumn)
}

fn uiEndColumn(ui: ^UiState) {
  uiEndLayout(ui, uiLayoutTypeColumn)
}

// Begins a dynamic row layout.
// It uses its provided size and wraps around if needed.
// auto: true to disable wrapping
fn uiBeginDynamicRow(ui: ^UiState, auto: bool = false) {
  uiBeginLayout(ui, uiLayoutTypeDynamicRow, 0, auto)
}

fn uiEndDynamicRow(ui: ^UiState) {
  uiEndLayout(ui, uiLayoutTypeDynamicRow)
}

// Begins a fixed row layout.
// It assigns element width to parent width divided by element per row, and wraps around if needed.
// auto: true to disable wrapping
fn uiBeginFixedRow(ui: ^UiState, elementsPerRow: int, auto: bool = false) {
  uiBeginLayout(ui, uiLayoutTypeFixedRow, elementsPerRow, auto)
}

fn uiEndFixedRow(ui: ^UiState) {
  uiEndLayout(ui, uiLayoutTypeFixedRow)
}

const (
  windowFlagShadow = 0x1
)

var (
  v_font: d_font.Font
  v_drawCtx: DrawCtx
  
  v_groupZone: GroupZone
  v_uiState: UiState
  v_lastWindowFlags: uint32

  v_dbgMask: uint32 // mask for debug ui
  v_inputState: InputState
)

///////////////////////
// UI (Interface)

// Begins a column layout.
// It becomes full width to the parent rectangle and moves on to next row.
fn beginColumn*() {
  uiBeginColumn(&v_uiState)
}

fn endColumn*() {
  uiEndColumn(&v_uiState)
}

// Begins a dynamic row layout.
// It uses its provided size and wraps around if needed.
fn beginDynamicRow*(auto: bool = false) {
  uiBeginDynamicRow(&v_uiState, auto)
}

fn endDynamicRow*() {
  uiEndDynamicRow(&v_uiState)
}

// Begins a fixed row layout.
// It assigns element width to parent width divided by element per row, and wraps around if needed.
fn beginFixedRow*(elementsPerRow: int, auto: bool = false) {
  uiBeginFixedRow(&v_uiState, elementsPerRow, auto)
}

fn endFixedRow*() {
  uiEndFixedRow(&v_uiState)
}

fn init*(font: d_font.Font) {
  v_font = font
  v_groupZone = groupZoneInit()
  v_drawCtx = drawCtxInit()
  v_uiState = uiInit(&v_drawCtx)
}

fn populateMouseButton(previous: ButtonState, button: char): ButtonState {
  return ButtonState{
    down: input.isPressed(button),
    pressed: input.isJustPressed(button),
    released: previous.down && !input.isPressed(button)}
}

fn populateInputState(previous: InputState): InputState {
  var output: InputState

  output.mouseLeft = populateMouseButton(previous.mouseLeft, input.mouse1);
  output.mouseMiddle = populateMouseButton(previous.mouseMiddle, input.mouse2);
  output.mouseRight = populateMouseButton(previous.mouseRight, input.mouse3);

  output.mousePos = input.getMousePos()
  output.mouseDelta = output.mousePos.sub(previous.mousePos)
  output.mouseScroll = int(input.isJustPressed(input.mouse_up)) - int(input.isJustPressed(input.mouse_down));

  return output
}

fn dbgPrintText(lay: ^SequenceLayout, label: str, color: uint32) {
  size := v_font.measure(label)
  r := rect.mk(lay.end.x, lay.end.y, size.x, size.y)

  v_drawCtx.putCommand(99, commandText(color & v_dbgMask, r, label))
  lay.put(v_font.measure(label))
}

fn dbgPrintSect(lay: ^SequenceLayout, label: str) {
  dbgPrintText(lay, label, th.white)
  startX := lay.end.x 
  lay.padding(100)
  endX := lay.end.x
  y := lay.end.y + v_font.measure(" ").y/2;

  v_drawCtx.putCommand(99, commandRect(0xFFFFFF11 & v_dbgMask, rect.mk(startX, y, endX-startX, 1)))
}

fn dbgPrintBool(lay: ^SequenceLayout, label: str, value: bool) {
  dbgPrintText(lay, label, [2]uint32{th.white & 0xFFFFFF99, th.green}[int(value)])
}

fn dbgPrintButtonState(lay: ^SequenceLayout, label: str, state: ButtonState) {
  dbgPrintSect(lay, label);

  dbgPrintBool(lay, "down ", state.down)
  dbgPrintBool(lay, "pressed ", state.pressed)
  dbgPrintBool(lay, "released", state.released)

  lay.newLine()
}

fn dbgPrintInputState(lay: ^SequenceLayout, state: InputState) {
  dbgPrintButtonState(lay, "MouseLeft", state.mouseLeft);
  dbgPrintButtonState(lay, "MouseMiddle", state.mouseMiddle);
  dbgPrintButtonState(lay, "MouseRight", state.mouseRight);

  dbgPrintSect(lay, "MouseDelta");
  dbgPrintText(lay, "x"+std.ftoa(state.mouseDelta.x, 0), th.white & 0xFFFFFF99)
  lay.padding(150)
  dbgPrintText(lay, "y"+std.ftoa(state.mouseDelta.y, 0), th.white & 0xFFFFFF99)
  lay.newLine()

  dbgPrintSect(lay, "MousePos");
  dbgPrintText(lay, "x"+std.ftoa(state.mousePos.x, 0), th.white & 0xFFFFFF99)
  lay.padding(150)
  dbgPrintText(lay, "y"+std.ftoa(state.mousePos.y, 0), th.white & 0xFFFFFF99)
  lay.newLine()

  dbgPrintSect(lay, "MouseScroll");
  dbgPrintText(lay, std.itoa(state.mouseScroll), th.white & 0xFFFFFF99)
  lay.newLine()
}

fn dbgPrintGroup(lay: ^SequenceLayout, label: str, group: ^Group) {
  dbgPrintSect(lay, label);
  if group != null {
    dbgPrintText(lay, std.itoa(group.index), th.white & 0xFFFFFF99)
  } else {
    dbgPrintText(lay, "null", th.white & 0xFFFFFF99)
  }
  lay.newLine()
}

fn dbgMain(pos: th.Vf2) {
  lay := sequenceLayoutInit(pos)
  dbgPrintSect(&lay, "FPS")
  dbgPrintText(&lay, std.itoa(round(d_fps.getFps())), th.white & 0xFFFFFF99)
  lay.newLine()

  dbgPrintInputState(&lay, v_inputState)
  // TODO: uncomment
  dbgPrintGroup(&lay, "DraggingGroup", v_groupZone.currentDraggingGroup)
  dbgPrintGroup(&lay, "ActiveGroup", v_groupZone.currentActiveGroup)
  dbgPrintGroup(&lay, "DockingGroup", v_groupZone.currentDockingGroup)
  dbgPrintSect(&lay, "WindowScroll")
  if v_groupZone.currentActiveGroup != null {
    dbgPrintText(&lay, repr(groupGetCurrentWindow(v_groupZone.currentActiveGroup).scroll.targetScroll), th.white & 0xFFFFFF99)
  }
  lay.newLine()
  dbgPrintSect(&lay, "UndockWindow")
  dbgPrintText(&lay, v_groupZone.undockWindow, th.white & 0xFFFFFF99)
  lay.newLine()


  // make lighter on hover
  if (rectInPoint(lay.getRect(), v_inputState.mousePos)) {
    v_dbgMask = 0xFFFFFF55
    v_drawCtx.putCommand(98, commandRect(th.black&0x11, rectInset(lay.getRect(), -5)))
  } else {
    v_dbgMask = 0xFFFFFFFF
    v_drawCtx.putCommand(98, commandRect(th.black&0xBB, rectInset(lay.getRect(), -5)))
  }
}

fn handleGroups() {
  for _, group in v_groupZone.groups {
    for i in group.windows {
      scrollUpdate(&group.windows[i].scroll)
    }
    scrollUpdate(&group.tabScroll)
  }
}

fn begin*() {
  d_fps.update()
  v_inputState = populateInputState(v_inputState);
  handleGroups()
  groupZoneSetJoin(&v_groupZone, false)
  dbgMain(th.Vf2{10, 10});
  groupZoneBeginFrame(&v_groupZone, v_inputState.mouseDelta, v_inputState.mousePos)
  uiBegin(&v_uiState, v_inputState)
}

fn endWindow(group: ^Group);

fn end*() {
  for title, group in v_groupZone.groups {
    win := groupFindWindow(group, title)
    if win.visibilityStatus > 0 {
      win.visibilityStatus -= 1
    } 
  }


  group := v_groupZone.currentGroup
  if groupZoneEnd(&v_groupZone) {
    endWindow(group)
  }

  uiEnd(&v_uiState)
  groupZoneUpdate(&v_groupZone)

  v_drawCtx.render(v_font)
  v_drawCtx.clear()
}

fn setJoinWindows*(set: bool) {
  groupZoneSetJoin(&v_groupZone, set)
}

fn getButtonState(): ButtonState {
  if v_groupZone.currentActiveGroup != v_groupZone.currentGroup {
    return ButtonState{}
  }

  buttonState := uiGetButtonState(&v_uiState)
  return buttonState
}

fn invalidateClick() {
  v_groupZone.currentDraggingGroup = null
}

fn _putLabel(text: str, color: uint32 = c_fore) {
  size := v_font.measure(text) 
  size.x += 10 // padding
  size.y += 5

  labelRect := uiPutElement(&v_uiState, size)
  labelRect.w -= 1
  labelRect.h -= 1

  uiPutCommand(&v_uiState, commandText(color, labelRect, text))
}

fn _calculateImageSize(img: image.Image, size: th.Vf2 = th.Vf2{0, 0}, preserveAspect: bool = false): th.Vf2 {
  if size.x == 0 && size.y == 0 {
    size = img.getDims()
  }

  if preserveAspect {
    place := uiCalculateElement(&v_uiState, size)
    place.h = place.w * size.x/size.y
    size = place.getDims()
  }

  return size
}

fn _putImage(img: image.Image, size: th.Vf2 = th.Vf2{0, 0}, preserveAspect: bool = false) {
  uiPutCommand(&v_uiState, commandImage(uiPutElement(&v_uiState, _calculateImageSize(img, size, preserveAspect)), img))
}

fn drawButtonUi(r: rect.Rect, state: ButtonState) {
  color := c_item
  if state.over {
    color = c_over
  }
  if state.down {
    color = c_held
  }
  uiPutCommand(&v_uiState, commandRect(color, r))
}

fn _putImageButton(img: image.Image, size: th.Vf2 = th.Vf2{0, 0}, preserveAspect: bool = false): ButtonState {
  size = _calculateImageSize(img, size, preserveAspect)

  uiPushElement(&v_uiState, size)
    buttonState := getButtonState()
    if buttonState.pressed {
      invalidateClick()
    }
    buttonRect := uiGetBounds(&v_uiState)

    // create a copy so we don't report bogus button info in return
    drawButtonUi(buttonRect, buttonState)
    uiBeginColumn(&v_uiState)
      _putImage(img, size, preserveAspect)
    uiEndColumn(&v_uiState)
  uiPopElement(&v_uiState)

  return buttonState
}

fn _putButtonToggle(text: str, pressed: bool): ButtonState {
  size := v_font.measure(text) 
  size.x += 10 // padding
  size.y += 5


  uiPushElement(&v_uiState, size)
    buttonState := getButtonState()
    if buttonState.pressed {
      invalidateClick()
    }
    buttonRect := uiGetBounds(&v_uiState)

    // create a copy so we don't report bogus button info in return
    buttonStateCopy := buttonState
    buttonStateCopy.down = buttonStateCopy.down || pressed
    drawButtonUi(buttonRect, buttonStateCopy)
    uiPutCommand(&v_uiState, commandText(c_body, buttonRect, text))
  uiPopElement(&v_uiState)

  return buttonState 
}


fn _putButton(text: str): ButtonState {
  return _putButtonToggle(text, false)
}     

fn beginWindow*(title: str, r: rect.Rect): bool;

fn endWindow(group: ^Group) {
  if (v_lastWindowFlags & windowFlagShadow) == 0 {
    // (beginWindow 1)
    currentWindow := groupGetCurrentWindow(group)
                  uiEndCropContents(&v_uiState)
                  scrollLimit(&currentWindow.scroll, -(uiGetContentSize(&v_uiState).y-uiGetBounds(&v_uiState).h))
                  if currentWindow.scroll.limit < 0 {
                    contentRect := uiGetBounds(&v_uiState)
                    percentOfs := -currentWindow.scroll.scroll/(contentRect.h-currentWindow.scroll.limit)
                    percentSize := contentRect.h/(contentRect.h-currentWindow.scroll.limit)
                    uiPutCommand(&v_uiState, commandRect(c_shadow, rect.mk(contentRect.x+contentRect.w-3, contentRect.y+contentRect.h*percentOfs, 3, contentRect.h * percentSize)))
                  }
                uiEndColumn(&v_uiState)
              uiPopElement(&v_uiState)
            uiEndColumn(&v_uiState)
          uiPopElement(&v_uiState)
        uiPopElement(&v_uiState)
      uiEndLayout(&v_uiState, uiLayoutTypeScreen)
    uiPopElement(&v_uiState)
  } else {
        uiPopElement(&v_uiState)
      uiEndLayout(&v_uiState, uiLayoutTypeScreen)
    uiPopElement(&v_uiState)
  }
  v_lastWindowFlags = 0
}

fn beginWindow*(title: str, r: rect.Rect): bool {
  group := v_groupZone.currentGroup
  if groupZoneEnd(&v_groupZone) {
    endWindow(group)
  }

  began := groupZoneBegin(&v_groupZone, title, r)

  overTab := ""
  overBody := false
  overTitlebar := false
  isDown := v_inputState.mouseLeft.down
  isPressed := v_inputState.mouseLeft.pressed
  isReleased := v_inputState.mouseLeft.released

  if began {
    group := v_groupZone.currentGroup
    if  v_groupZone.currentDraggingGroup != null && v_groupZone.canDock && v_groupZone.currentDockingGroup != null && group != v_groupZone.currentDockingGroup {
      v_lastWindowFlags |= windowFlagShadow
    }

    uiBeginGroup(&v_uiState, group.index)

    if (v_lastWindowFlags & windowFlagShadow) != 0 {
      uiPushElement(&v_uiState, th.Vf2{window.w, window.h})
        uiBeginLayout(&v_uiState, uiLayoutTypeScreen)
          uiPushElement(&v_uiState, group.rect.getDims())
            uiSetCursor(&v_uiState, group.rect.getPos())
            uiPutCommand(&v_uiState, commandRect(c_shadow, uiPutElement(&v_uiState, uiGetBounds(&v_uiState).getDims())))
            // Create a fake titlebar, a hack
            uiPushElement(&v_uiState, th.Vf2{uiGetBounds(&v_uiState).w, v_font.measure(" ").y+6})
              overTitlebar = uiGetButtonState(&v_uiState).over
            uiPopElement(&v_uiState)
    } else {
      uiPushElement(&v_uiState, th.Vf2{window.w, window.h})
        uiBeginLayout(&v_uiState, uiLayoutTypeScreen)
          uiSetCursor(&v_uiState, group.rect.getPos())
          uiPushElement(&v_uiState, group.rect.getDims())
            if uiGetButtonState(&v_uiState).over {
              overBody = true
            }
            uiPutCommand(&v_uiState, commandRect(c_shadow, rectMove(rectInset(uiGetBounds(&v_uiState), -1), th.Vf2{0, 1})))
            uiPutCommand(&v_uiState, commandRect(c_decor, uiGetBounds(&v_uiState)))
            uiPushElement(&v_uiState, uiGetBounds(&v_uiState).getDims(), 1)
              uiBeginColumn(&v_uiState)
                // Titlebar
                uiPushElement(&v_uiState, th.Vf2{uiGetBounds(&v_uiState).w, v_font.measure(" ").y+5})
                  uiBeginDynamicRow(&v_uiState, true)
                    if len(group.windows) == 1 {
                      uiPutCommand(&v_uiState, commandText(c_body, uiPutElement(&v_uiState, uiGetBounds(&v_uiState).getDims()), group.windows[0].title))
                    } else {
                      _putButton("||||")
                      uiPushElement(&v_uiState, uiGetRemainingSize(&v_uiState))
                        uiBeginDynamicRow(&v_uiState, true)
                          uiBeginCropContents(&v_uiState)
                          uiSetScroll(&v_uiState, th.Vf2{group.tabScroll.scroll, 0})
                          for i, w in group.windows {
                            if w.visibilityStatus > 0 {
                              if _putButtonToggle(w.title, group.current == i).over {
                                overTab = w.title
                              }
                            }
                          }
                          scrollLimit(&group.tabScroll, -(uiCurrentLayout(&v_uiState).position.x-uiGetBounds(&v_uiState).w))
                          if uiGetButtonState(&v_uiState).over && v_groupZone.currentActiveGroup == group {
                            scrollBy(&group.tabScroll, v_inputState.mouseScroll*2000*(th.delta/1000.0))
                          }
                          uiEndCropContents(&v_uiState)
                        uiEndDynamicRow(&v_uiState)
                      uiPopElement(&v_uiState)
                    }
                    if uiGetButtonState(&v_uiState).over {
                      overTitlebar = true
                    }
                  uiEndDynamicRow(&v_uiState)
                uiPopElement(&v_uiState)
                uiPushElement(&v_uiState, uiGetRemainingSize(&v_uiState))
                  if uiGetButtonState(&v_uiState).over {
                    if v_groupZone.currentActiveGroup == group {
                      scrollBy(&groupGetCurrentWindow(group).scroll, v_inputState.mouseScroll*2000*(th.delta/1000.0))
                    }
                    overBody = true
                  }
                  uiPutCommand(&v_uiState, commandRect(c_body, uiGetBounds(&v_uiState)))
                  uiBeginColumn(&v_uiState)
                    uiBeginCropContents(&v_uiState)
                    uiSetScroll(&v_uiState, th.Vf2{0, groupGetCurrentWindow(group).scroll.scroll})
    }

    // (beginWindow 1)
    if overTab != "" {
      overTitlebar = false
    }

    if overTitlebar {
      overBody = false
    }
    groupZoneReportInput(&v_groupZone, overTab, overBody, overTitlebar, isDown, isPressed, isReleased)
  }

  return began
}

fn putImageButton*(img: image.Image, size: th.Vf2 = th.Vf2{0, 0}, preserveAspect: bool = false): ButtonState {
  if (v_lastWindowFlags & windowFlagShadow) == 0 {
    return _putImageButton(img, size, preserveAspect)
  }

  return ButtonState{}
}

fn putImage*(img: image.Image, size: th.Vf2 = th.Vf2{0, 0}, preserveAspect: bool = false) {
  if (v_lastWindowFlags & windowFlagShadow) == 0 {
    _putImage(img, size, preserveAspect)
  }
}

fn putButton*(text: str): ButtonState {
  if (v_lastWindowFlags & windowFlagShadow) == 0 {
    return _putButton(text)
  }
  return ButtonState{}
}

fn putLabel*(text: str) {
  if (v_lastWindowFlags & windowFlagShadow) == 0 {
    _putLabel(text)
  }
}


// DRAGGING
// 1. Check if left mouse button is down
// 2. Iterate through windows
// 3. Check if we intersect with the window
// 4. Initiate window dragging
// 5. Drag the dragged window by specified mouse delta in following frames
//
// JOINING TABS
// 1. Iterate through windows
// 2. Check if mouse is above another window's titlebar
// 3. Attach to that another window
//
// SPLITTING TABS
// 1. Iterate through windows
// 2. Check if mouse is pressed on any certain tab
// 3. Save it as a held tab
// 4. When held tab goes out of titlebar, move it to a new group
// 0 = hidden, 1 = shown last frame, 2 = shown this frame// 0 = hidden, 1 = shown last frame, 2 = shown this frame
