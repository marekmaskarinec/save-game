import (
        "th.um"; "rect.um"; "canvas.um"; "input.um"; "window.um"
        "d_font.um"; "d_util.um"; 
)

type (
        Window = struct {
                title: str
                rect: rect.Rect
        }

        Group = struct {
                windows: []Window
                current: uint
                rect: rect.Rect
                tabWidth: real //width of tabs total
                tabScroll: real //horizontal scroll offset 
                scrolling: bool
        }
        
        GroupHoverInfo = int

        VisibleTab = struct {
                title: str
                ghost: bool
        }

        GroupZone = struct {
                groups: map[str]^Group // Window name to group
                stack: []^Group 
                join: bool
                firstJoin: bool
        }

        InputState = struct {
                nudged: bool
                held: bool
                relased: bool
        }
)

const (
        groupHoverInfoNone = GroupHoverInfo(0)
        groupHoverInfoOnBody = GroupHoverInfo(1)
        groupHoverInfoOnTitlebar = GroupHoverInfo(2)
)

var (
        v_font: d_font.Font
        
        v_groupZone: GroupZone

        v_mousePos: th.Vf2
        v_mouseDelta: th.Vf2
        v_mouseRightDown: bool
        v_mouseRightNudged: bool
        v_mouseLeftDown: bool
        v_mouseLeftNudged: bool
        v_mouseLeftReleased: bool

        v_groupDraggingIndex: int = -1
        v_groupDockingCandidateIndex: int = -1
        v_windowDetachCandidateName: str
)

///////////////////////
// Utility
fn rectInPoint(r: rect.Rect, p: th.Vf2): bool {
        return p.x > r.x && p.y > r.y && p.x < (r.x + r.w) && p.y < (r.y + r.h)
}

fn rectInset(r: rect.Rect, by: real): rect.Rect {
        return rect.mk(r.x-by, r.y-by, r.w+by*2, r.h+by*2)
}

fn rectMove(r: rect.Rect, by: th.Vf2): rect.Rect {
        return rect.Rect{r.x+by.x, r.y+by.y, r.w, r.h}
}

///////////////////////
// Group
fn groupCreateFromWindow(win: Window): Group {
        windows := make([]Window, 1)
        windows[0] = win
        return Group{windows: windows, current: 0, rect: win.rect}
}

fn groupAppendWindow(group: ^Group, win: Window) {
        group.windows = append(group.windows, win) 
}

fn groupCreateFromScratch(r: rect.Rect): Group {
        return Group{windows: make([]Window, 0), current: 0, rect: r}
}

fn groupGetWindowIndexByName(group: ^Group, name: str): int {
        for windowIndex, win in group.windows {
                if win.title == name {
                        return windowIndex
                }
        }
        return -1
}

///////////////////////
// Group Zone
fn groupZoneInit(): GroupZone {
        return GroupZone{groups: map[str]^Group{}, stack: make([]^Group, 0)}
}

fn groupZoneAcquire(zone: ^GroupZone, title: str, r: rect.Rect): ^Group {
        group := zone.groups[title]

        if group == null {
                if len(zone.stack) > 0 && zone.join && !zone.firstJoin {
                        zone.groups[title] = zone.stack[len(zone.stack)-1]
                        group = zone.groups[title]
                        groupAppendWindow(zone.stack[len(zone.stack)-1], Window{title: title, rect: r})
                } else {
                        newGroup := new(Group)
                        newGroup ^= groupCreateFromWindow(Window{title: title, rect: r})
                        zone.groups[title] = newGroup
                        group = zone.groups[title]
                        zone.firstJoin = false
                        zone.stack = append(zone.stack, newGroup)
                }
        }
        
        return group
}

fn groupZoneSetJoin(zone: ^GroupZone, set: bool) {
        zone.join = set
        zone.firstJoin = true
}

fn groupZoneDockGroups(zone: ^GroupZone, srcIdx: int, dstIdx: int) {
        dst := zone.stack[dstIdx]
        src := zone.stack[srcIdx]

        for win in src.windows {
                zone.groups[win.title] = dst
                dst.windows = append(dst.windows, win)
        }

        zone.stack = delete(zone.stack, srcIdx)
}

///////////////////////
// UI
fn init*(font: d_font.Font) {
        v_font = font
        v_groupZone = groupZoneInit()
}

fn begin*() {
        newMousePos := input.getMousePos()
        v_mouseDelta = newMousePos.sub(v_mousePos)
        v_mousePos = newMousePos

        v_mouseRightDown = input.isPressed(input.mouse3)
        v_mouseRightNudged = input.isJustPressed(input.mouse3)

        v_mouseLeftReleased = v_mouseLeftDown && !input.isPressed(input.mouse1)
        v_mouseLeftDown = input.isPressed(input.mouse1)
        v_mouseLeftNudged = input.isJustPressed(input.mouse1)

        groupZoneSetJoin(&v_groupZone, false)
}

fn createInputState(hovered: bool): InputState {
        return InputState{relased: hovered && v_mouseLeftReleased, nudged: hovered && v_mouseLeftNudged, held: hovered && v_mouseLeftDown}
}

fn putButton(pos: ^th.Vf2, text: str, toggled: bool, canHover: bool, baseColor: uint32, padding: th.Vf2 = th.Vf2{10, 2}): InputState {
        textSize := v_font.measure(text)
        r := rect.Rect{pos.x, pos.y, textSize.x + padding.x*2, textSize.y + padding.y*2}
        hovered := rectInPoint(r, v_mousePos) && canHover
        pressed := hovered && v_mouseLeftDown
        
        if pressed {
                canvas.drawRect(baseColor | 0x44444400, r)
        } else if toggled {
                canvas.drawRect(baseColor | 0x33333300, r)
        } else if hovered {
                canvas.drawRect(baseColor | 0x22222200, r)
        } else {
                canvas.drawRect(baseColor, r)
        }


        v_font.draw(text, pos.add(padding), th.white)

        pos.x += r.w+1

        return createInputState(hovered)
}

fn getActiveGroup(): int {
        for i := len(v_groupZone.stack)-1; i >= 0; i-- {
                if rectInPoint(v_groupZone.stack[i].rect, v_mousePos) {
                        return i
                }
        }
        return -1
}

fn getGroupHoverInfo(group: ^Group): GroupHoverInfo {
        r := group.rect 
        titlebarRect := rect.mk(r.x, r.y, r.w, v_font.height + 4)
        
        if rectInPoint(titlebarRect, input.getMousePos()) {
                return groupHoverInfoOnTitlebar
        } else if rectInPoint(r, input.getMousePos()) {
                return groupHoverInfoOnBody
        } 
        return groupHoverInfoNone
}

fn isValidGroupDocking(group_a: ^Group, group_b: ^Group): bool {
        return getGroupHoverInfo(group_a) == groupHoverInfoOnTitlebar && getGroupHoverInfo(group_b) == groupHoverInfoOnTitlebar       
}

fn isDocking(): bool {
        return v_groupDraggingIndex >= 0 && v_groupDockingCandidateIndex >= 0 && isValidGroupDocking(v_groupZone.stack[v_groupDraggingIndex], v_groupZone.stack[v_groupDockingCandidateIndex])
}

fn convertWindowListToVisibleTabs(list: []Window, ghost: bool): []VisibleTab {
        result := make([]VisibleTab, len(list))
        for i, win in list {
                result[i].title = win.title
                result[i].ghost = ghost
        }
        return result
}

fn getGroupVisibleTabs(groupIndex: int): []VisibleTab {
        tabs := convertWindowListToVisibleTabs(v_groupZone.stack[groupIndex].windows, false)

        if v_groupDraggingIndex >= 0 && v_groupDockingCandidateIndex == groupIndex && isDocking() {
                tabs = append(tabs, convertWindowListToVisibleTabs(v_groupZone.stack[v_groupDraggingIndex].windows, true))
        }
        
        return tabs
}

fn end*() {
        // Move windows
        if !v_mouseLeftDown {
                // Finalize docking
                if isDocking() {
                        groupZoneDockGroups(&v_groupZone, v_groupDraggingIndex, v_groupDockingCandidateIndex)
                }
                v_windowDetachCandidateName = ""
                v_groupDraggingIndex = -1
        }
 
        if v_windowDetachCandidateName != "" {
                v_groupDraggingIndex = -1
        }

        if v_groupDraggingIndex >= 0 {
                // Apply drag
                group := v_groupZone.stack[v_groupDraggingIndex]

                group.rect.x += v_mouseDelta.x
                group.rect.y += v_mouseDelta.y
        }

        if v_windowDetachCandidateName != "" && (getActiveGroup() == -1 || getGroupHoverInfo(v_groupZone.stack[getActiveGroup()]) != groupHoverInfoOnTitlebar) {
                group := v_groupZone.groups[v_windowDetachCandidateName]
                if group != null {
                        removalIndex := groupGetWindowIndexByName(group, v_windowDetachCandidateName)

                        // Move selected tab index accordingly
                        if removalIndex == group.current {
                                group.current = 0
                        } else if removalIndex < group.current {
                                group.current -= 1
                        }

                        if removalIndex >= 0 {
                                removalRect := group.windows[removalIndex].rect
                                destPos := v_mousePos.sub(th.Vf2{10, 10})
                                removalRect.x = destPos.x
                                removalRect.y = destPos.y

                                group.windows = delete(group.windows, removalIndex)
                                v_groupZone.groups[v_windowDetachCandidateName] = null;
                                groupZoneAcquire(&v_groupZone, v_windowDetachCandidateName, removalRect)
                                v_groupDraggingIndex = len(v_groupZone.stack)-1
                                v_windowDetachCandidateName = ""
                        }
                }
        }

        if v_mouseLeftNudged {
                groupIndex := getActiveGroup()
                if groupIndex >= 0 { 
                        group := v_groupZone.stack[groupIndex]
                        if !group.scrolling {
                                v_groupZone.stack = delete(v_groupZone.stack, groupIndex)
                                v_groupZone.stack = append(v_groupZone.stack, group)
                                        
                                v_groupDraggingIndex = len(v_groupZone.stack)-1
                        }
                }
        }

        v_groupDockingCandidateIndex = -1
        if v_groupDraggingIndex >= 0 {
                // Find other docking candidates
                for i := len(v_groupZone.stack)-1; i >= 0; i-- {
                        if i != v_groupDraggingIndex && rectInPoint(v_groupZone.stack[i].rect, v_mousePos) {
                                v_groupDockingCandidateIndex = i
                                break
                        }
                }
        }



        // Draw windows
        for groupIndex, group in v_groupZone.stack {
                r := group.rect 

                titlebarRect := rect.mk(r.x, r.y, r.w, v_font.height + 4)
                pos := th.Vf2{r.x+20, r.y}
                newCurrent := group.current

                tabs := getGroupVisibleTabs(groupIndex)

                if v_groupDockingCandidateIndex < groupIndex && isDocking() {
                        canvas.drawRect(th.black&0x22, r)
                } else {
                        // Scroll tab bar
                        if groupIndex == getActiveGroup() && v_mouseRightNudged && rectInPoint(titlebarRect, input.getMousePos()) {
                                group.scrolling = true
                        }
                        if !v_mouseRightDown {
                                group.scrolling = false
                        }
                        if group.scrolling {
                                group.tabScroll += v_mouseDelta.x
                        }
                        if -group.tabScroll < 0 {
                                group.tabScroll = 0
                        }
                        if -group.tabScroll > group.tabWidth-titlebarRect.w {
                                if group.tabWidth-titlebarRect.w > 0 {
                                        group.tabScroll = -(group.tabWidth-titlebarRect.w)
                                } else {
                                        group.tabScroll = 0
                                }
                        }

                        canvas.drawRect(0x00000022, rectMove(rectInset(r, 2), th.Vf2{0, 1}))
                        canvas.drawRect(0xAA5555FF, rectInset(r, 1))
                        window.beginScissorRect(rectInset(r, 1))
                        canvas.drawRect(th.white, rect.mk(r.x    , r.y    , r.w    , r.h    ))
                        canvas.drawRect(0xAA5555FF, titlebarRect);
                                
                        pos.x += group.tabScroll

                        if len(tabs) > 1 {
                                for i, tab in tabs {
                                        baseColor := 0xCC555555
                                        if tab.ghost {
                                                baseColor = 0x00000055
                                        }
                                        state := putButton(&pos, tab.title, group.current == i, groupIndex == getActiveGroup(), baseColor)

                                        // Deny drag (because button press)
                                        if !group.scrolling && state.nudged && rectInPoint(rectMove(titlebarRect, th.Vf2{20, 0}), input.getMousePos()) {
                                                v_windowDetachCandidateName = tab.title
                                        }
                                        if state.relased {
                                                newCurrent = i
                                        }
                                }
                        } else if len(tabs) == 1 {
                                v_font.draw(tabs[0].title, pos.add(th.Vf2{10, 2}), th.white)
                        }

                        group.tabWidth = pos.x-r.x-group.tabScroll
  
                        
                        pos = th.Vf2{trunc(r.x-1), trunc(r.y)}
                        putButton(&pos, " |||||", false, false, 0xAA5555FF, th.Vf2{0, 2})
                        v_font.draw("Contents of "+tabs[group.current].title, th.Vf2{r.x+10, r.y+30}, th.black)

                        window.endScissor()
                }

                group.current = newCurrent
        }
}

fn setJoinWindows*(set: bool) {
        groupZoneSetJoin(&v_groupZone, set)
}

fn beginWindow*(title: str, r: rect.Rect) {
        groupZoneAcquire(&v_groupZone, title, r)
}


// DRAGGING
// 1. Check if left mouse button is down
// 2. Iterate through windows
// 3. Check if we intersect with the window
// 4. Initiate window dragging
// 5. Drag the dragged window by specified mouse delta in following frames
//
// JOINING TABS
// 1. Iterate through windows
// 2. Check if mouse is above another window's titlebar
// 3. Attach to that another window
//
// SPLITTING TABS
// 1. Iterate through windows
// 2. Check if mouse is pressed on any certain tab
// 3. Save it as a held tab
// 4. When held tab goes out of titlebar, move it to a new group
