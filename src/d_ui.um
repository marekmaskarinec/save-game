import (
        "std.um"
        "th.um"; "rect.um"; "canvas.um"; "input.um"; "window.um"
        "d_font.um"; "d_util.um"; 
)

type (
        Window = struct {
                title: str
                rect: rect.Rect
        }

        Group = struct {
                index: int
                windows: []Window
                current: uint
                rect: rect.Rect
                tabWidth: real //width of tabs total
                tabScroll: real //horizontal scroll offset 
                scrolling: bool
        }

        Cutting = int

        GroupHoverInfo = int

        VisibleTab = struct {
                title: str
                ghost: bool
        }

        GroupZone = struct {
                /* base */
                groups: map[str]^Group // Window name to group
                stack: []^Group 
                join: bool
                firstJoin: bool

                /* ux */
                draggingIndex: int // window currently dragging, -1 for none
                activeIndex: int // window currently focused on, -1 for none
        }

        ButtonState = struct {
                down: bool
                pressed: bool
                released: bool       
        }

        InputState = struct {
                mousePos: th.Vf2
                mouseDelta: th.Vf2
                mouseScroll: int

                mouseMiddle: ButtonState
                mouseLeft: ButtonState
                mouseRight: ButtonState
        }

        DrawCommand = struct {
                color: uint32
                rect: rect.Rect
                text: str
        }

        DrawLayer = struct {
                commands: []DrawCommand
                index: int // Layer ordering for sorting
        }

        DrawCtx = struct {
                layers: []DrawLayer 
        }

        Layout = struct {
                index: int
                rect: rect.Rect
                cutter: Cutting
                ctx: ^DrawCtx
        }

        SequenceLayout = struct {
                start: th.Vf2
                end: th.Vf2
                lineHeight: th.fu
                maxX: th.fu
        }
)

const (
        cuttingLeft = Cutting(0)
        cuttingRight = Cutting(1)
        cuttingTop = Cutting(2)
        cuttingBottom = Cutting(3)
)

////////////////////////////
// SequenceLayotu

fn sequenceLayoutInit(pos: th.Vf2): SequenceLayout {
        return SequenceLayout{start: pos, end: pos}
}

fn (lay: ^SequenceLayout) newLine() {
        lay.end = th.Vf2{lay.start.x, lay.end.y + lay.lineHeight}
        lay.lineHeight = 0
}

fn (lay: ^SequenceLayout) getRect(): rect.Rect {
        return rect.mk(lay.start.x, lay.start.y, lay.maxX-lay.start.x, (lay.end.y-lay.start.y)+lay.lineHeight)
}

fn (lay: ^SequenceLayout) put(size: th.Vf2) {
        if (lay.lineHeight < size.y) {
                lay.lineHeight = size.y
        }

        lay.end.x += size.x;

        if (lay.maxX < lay.end.x) {
                lay.maxX = lay.end.x;
        }
}

fn (lay: ^SequenceLayout) padding(by: th.fu) {
        by = by - (trunc(lay.end.x-lay.start.x) % trunc(by))
        lay.put(th.Vf2{by, 0})
}

/////////////////////////////
// Draw*

fn layerFromCommand(index: int, cmd: DrawCommand): DrawLayer {
        return DrawLayer{index: index, commands: []DrawCommand{cmd}}
}

fn drawCtxInit(): DrawCtx {
        return DrawCtx{layers: []DrawLayer{}}
}

fn commandRect(color: uint32, r: rect.Rect): DrawCommand {
        return DrawCommand{color: color, rect: r, text: ""}
}

fn commandText(color: uint32, r: rect.Rect, t: str): DrawCommand {
        return DrawCommand{color: color, rect: r, text: t}
}

fn (lay: ^DrawLayer) putCommand(cmd: DrawCommand) {
        lay.commands = append(lay.commands, cmd);
}

fn (ctx: ^DrawCtx) clear() {
        ctx.layers = []DrawLayer{}
}

fn (ctx: ^DrawCtx) putCommand(index: int, cmd: DrawCommand) {
        pushIndex := 0

        for i in ctx.layers {
                if ctx.layers[i].index > index {
                        break
                }
                if ctx.layers[i].index == index { // found exact layer
                        ctx.layers[i].putCommand(cmd)
                        return
                }
                pushIndex += 1
        }

        if pushIndex == len(ctx.layers) {
                ctx.layers = append(ctx.layers, layerFromCommand(index, cmd))
        } else {
                newLayers := make([]DrawLayer, 0)
                for i in ctx.layers {
                        if i == pushIndex {
                                newLayers = append(newLayers, layerFromCommand(index, cmd))
                        }
                        newLayers = append(newLayers, ctx.layers[i])
                }
                ctx.layers = newLayers
        }
}

fn (ctx: ^DrawCtx) render(font: d_font.Font) {
        for i in ctx.layers {
                layer := &ctx.layers[i]
                for j, cmd in layer.commands {
                        if cmd.text != "" { // draw text
                                size := font.measure(cmd.text)
                                font.draw(cmd.text, th.Vf2{cmd.rect.x+(cmd.rect.w-size.x)/2, cmd.rect.y+(cmd.rect.h-size.y)/2}, cmd.color)
                        } else { // draw rect
                                canvas.drawRect(cmd.color, cmd.rect)
                        }
                }
        }
}

///////////////////////
// Utility
fn rectInPoint(r: rect.Rect, p: th.Vf2): bool {
        return p.x > r.x && p.y > r.y && p.x < (r.x + r.w) && p.y < (r.y + r.h)
}

fn rectInset(r: rect.Rect, by: real): rect.Rect {
        return rect.mk(r.x+by, r.y+by, r.w-by*2, r.h-by*2)
}

fn rectMove(r: rect.Rect, by: th.Vf2): rect.Rect {
        return rect.Rect{r.x+by.x, r.y+by.y, r.w, r.h}
}

///////////////////////
// Cutting
fn cuttingCut(c: Cutting, r: ^rect.Rect, req: th.Vf2): rect.Rect {
        result := rect.Rect{-1e7, -1e7, 0, 0}
        switch c {
        case cuttingLeft:
                result = rect.mk(r.x, r.y, req.x, r.h)
                r.x += req.x;
                r.w -= req.x;
        case cuttingRight:
                result = rect.mk(r.x+r.w-req.x, r.y, req.x, r.h)
                r.w -= req.x;
        case cuttingTop:
                result = rect.mk(r.x, r.y, r.w, req.y)
                r.y += req.y;
                r.h -= req.y;
        case cuttingBottom:
                result = rect.mk(r.x, r.y+r.h-req.y, r.w, req.y)
                r.h -= req.y;
        }
        return result

}

///////////////////////
// Group
fn groupCreateFromWindow(win: Window): Group {
        windows := make([]Window, 1)
        windows[0] = win
        return Group{windows: windows, current: 0, rect: win.rect}
}

fn groupAppendWindow(group: ^Group, win: Window) {
        group.windows = append(group.windows, win) 
}

fn groupCreateFromScratch(r: rect.Rect): Group {
        return Group{windows: make([]Window, 0), current: 0, rect: r}
}

fn groupGetWindowIndexByName(group: ^Group, name: str): int {
        for windowIndex, win in group.windows {
                if win.title == name {
                        return windowIndex
                }
        }
        return -1
}

///////////////////////
// Group Zone
fn groupZoneInit(): GroupZone {
        return GroupZone{groups: map[str]^Group{}, stack: make([]^Group, 0)}
}

fn groupZoneAcquire(zone: ^GroupZone, title: str, r: rect.Rect): ^Group {
        group := zone.groups[title]

        if group == null {
                if len(zone.stack) > 0 && zone.join && !zone.firstJoin {
                        zone.groups[title] = zone.stack[len(zone.stack)-1]
                        group = zone.groups[title]
                        groupAppendWindow(zone.stack[len(zone.stack)-1], Window{title: title, rect: r})
                } else {
                        newGroup := new(Group)
                        newGroup ^= groupCreateFromWindow(Window{title: title, rect: r})
                        zone.groups[title] = newGroup
                        group = zone.groups[title]
                        zone.firstJoin = false
                        newGroup.index = len(zone.stack)
                        zone.stack = append(zone.stack, newGroup)
                }
        }
        
        return group
}

fn groupZoneMoveToFront(zone: ^GroupZone, groupIndex: int): int {
        group := zone.stack[groupIndex]
        zone.stack = delete(zone.stack, groupIndex)
        zone.stack = append(zone.stack, group)

        for i in zone.stack { // reassign correct window indices
                zone.stack[i].index = i
        }

        // TODO: Do a better job at updating the indexes, or have them static instead,
        //       Alter natively, use pointers instead.
        if zone.activeIndex == groupIndex {
                zone.activeIndex = group.index
        } else if zone.activeIndex > groupIndex {
                zone.activeIndex -= 1
        }

        if zone.draggingIndex == groupIndex {
                zone.draggingIndex = group.index
        } else if zone.draggingIndex > groupIndex {
                zone.draggingIndex -= 1
        }

        return group.index
}

fn groupZoneSetJoin(zone: ^GroupZone, set: bool) {
        zone.join = set
        zone.firstJoin = true
}

fn groupZoneDockGroups(zone: ^GroupZone, srcIdx: int, dstIdx: int) {
        dst := zone.stack[dstIdx]
        src := zone.stack[srcIdx]

        for i, win in src.windows {
                zone.groups[win.title] = dst
                dst.windows = append(dst.windows, win)
        }

        zone.stack = delete(zone.stack, srcIdx)
}

fn groupZoneLocateActiveWindow(zone: ^GroupZone, at: th.Vf2): int {
        id := -1
        for i in zone.stack {
                if rectInPoint(zone.stack[i].rect, at) {
                        id = i
                }
        }
        return id
}

fn groupZoneHandleInput(zone: ^GroupZone, inputState: InputState) {
        zone.activeIndex = groupZoneLocateActiveWindow(zone, inputState.mousePos)

        if inputState.mouseLeft.down == false  {
                zone.draggingIndex = -1
        }

        if zone.activeIndex >= 0 {
                if inputState.mouseLeft.pressed {
                        zone.draggingIndex = zone.activeIndex
                        groupZoneMoveToFront(zone, zone.draggingIndex)
                }
        }

        // apply drag
        if zone.draggingIndex >= 0 {
                zone.stack[zone.draggingIndex].rect = rectMove(zone.stack[zone.draggingIndex].rect, inputState.mouseDelta)
        }
}

///////////////////////
// Layout
fn layoutInit(ctx: ^DrawCtx, index: int, cutter: Cutting = cuttingLeft, r: rect.Rect = rect.Rect{0, 0, 0, 0}): Layout {
        return Layout{ctx: ctx, cutter: cutter, rect: r, index: index}
}

fn (lay: ^Layout) getRect(reqSize: th.Vf2): rect.Rect {
        return cuttingCut(lay.cutter, &lay.rect, reqSize)
}

fn (lay: ^Layout) putCommand(cmd: DrawCommand) {
        lay.ctx.putCommand(lay.index, cmd)
}


const (
        c_shadow = 0x00000022
        c_decor = 0xAA5555FF
        c_item = 0x993333FF
        c_body = th.white

        groupHoverInfoNone = GroupHoverInfo(0)
        groupHoverInfoOnBody = GroupHoverInfo(1)
        groupHoverInfoOnTitlebar = GroupHoverInfo(2)
)

var (
        v_font: d_font.Font
        v_drawCtx: DrawCtx
        
        v_groupZone: GroupZone
        v_lastGroup: ^Group
        v_lastWindow: str

        v_inputState: InputState
)


///////////////////////
// UI
fn init*(font: d_font.Font) {
        v_font = font
        v_groupZone = groupZoneInit()
        v_drawCtx = drawCtxInit()
}

fn populateMouseButton(previous: ButtonState, button: char): ButtonState {
        return ButtonState{
                down: input.isPressed(button),
                pressed: input.isJustPressed(button),
                released: previous.down && !input.isPressed(button)}
}

fn populateInputState(previous: InputState): InputState {
        var output: InputState

        output.mouseLeft = populateMouseButton(previous.mouseLeft, input.mouse1);
        output.mouseMiddle = populateMouseButton(previous.mouseMiddle, input.mouse2);
        output.mouseRight = populateMouseButton(previous.mouseRight, input.mouse3);

        output.mousePos = input.getMousePos()
        output.mouseDelta = output.mousePos.sub(previous.mousePos)
        output.mouseScroll = int(input.isJustPressed(input.mouse_up)) - int(input.isJustPressed(input.mouse_down));

        return output
}

fn dbgPrintText(lay: ^SequenceLayout, label: str, color: uint32) {
        size := v_font.measure(label)
        r := rect.mk(lay.end.x, lay.end.y, size.x, size.y)

        v_drawCtx.putCommand(99, commandText(color, r, label))
        lay.put(v_font.measure(label))
}

fn dbgPrintBool(lay: ^SequenceLayout, label: str, value: bool) {
        dbgPrintText(lay, label, [2]uint32{th.white & 0xFFFFFF99, th.green}[int(value)])
}

fn dbgPrintButtonState(lay: ^SequenceLayout, label: str, state: ButtonState) {
        size := th.Vf2{0, 0}

        dbgPrintText(lay, label, th.white);

        dbgPrintBool(lay, " down ", state.down)
        dbgPrintBool(lay, "pressed ", state.pressed)
        dbgPrintBool(lay, "released", state.released)

        lay.newLine()
}

fn dbgPrintInputState(pos: th.Vf2, state: InputState) {
        lay := sequenceLayoutInit(pos)
        dbgPrintButtonState(&lay, "MouseLeft", state.mouseLeft);
        dbgPrintButtonState(&lay, "MouseMiddle", state.mouseMiddle);
        dbgPrintButtonState(&lay, "MouseRight", state.mouseRight);

        dbgPrintText(&lay, "MouseDelta", th.white);
        dbgPrintText(&lay, "x"+std.ftoa(state.mouseDelta.x, 0), th.white & 0xFFFFFF99)
        lay.padding(150)
        dbgPrintText(&lay, "y"+std.ftoa(state.mouseDelta.y, 0), th.white & 0xFFFFFF99)
        lay.newLine()

        dbgPrintText(&lay, "MousePos", th.white);
        dbgPrintText(&lay, "x"+std.ftoa(state.mousePos.x, 0), th.white & 0xFFFFFF99)
        lay.padding(150)
        dbgPrintText(&lay, "y"+std.ftoa(state.mousePos.y, 0), th.white & 0xFFFFFF99)
        lay.newLine()

        dbgPrintText(&lay, "MouseScroll", th.white);
        dbgPrintText(&lay, std.itoa(state.mouseScroll), th.white & 0xFFFFFF99)
        lay.newLine()

        // make lighter on hover
        if (rectInPoint(lay.getRect(), state.mousePos)) {
                v_drawCtx.putCommand(98, commandRect(th.black&0x11, lay.getRect()))
        } else {
                v_drawCtx.putCommand(98, commandRect(th.black&0xBB, lay.getRect()))
        }
}

fn begin*() {
        v_inputState = populateInputState(v_inputState);
        groupZoneHandleInput(&v_groupZone, v_inputState)
        dbgPrintInputState(th.Vf2{10, 10}, v_inputState);
        groupZoneSetJoin(&v_groupZone, false)
}

fn getWindowDecorationRectFromRect(r: rect.Rect): rect.Rect {
        return rect.mk(r.x, r.y, r.w, v_font.height + 4)
}

fn getWindowContentRectFromRect(r: rect.Rect): rect.Rect {
        deco := getWindowDecorationRectFromRect(r)
        r.y += deco.h
        r.h -= deco.h
        return rectInset(r, 1)
}

fn end*() {
        v_drawCtx.render(v_font)
        v_drawCtx.clear()
}

fn setJoinWindows*(set: bool) {
        groupZoneSetJoin(&v_groupZone, set)
}

fn isLastWindowVisible(): bool {
        if (v_lastGroup == null) {
                return false
        }

        if (v_lastWindow != v_lastGroup.windows[v_lastGroup.current].title) {
                return false
        }  

        return true
}

fn getLastWindowContentRect(): rect.Rect {
        if isLastWindowVisible() {
                return getWindowContentRectFromRect(v_lastGroup.rect);
        }

        error("Last window wasn't visible");
        return rect.mk(0, 0, 0, 0)
}

fn _putButton(lay: ^Layout, text: str) {
        size := v_font.measure(text) 
        size.x += 10 // padding
        buttonRect := lay.getRect(size)
        lay.putCommand(commandRect(c_item, buttonRect))
        lay.putCommand(commandText(c_body, buttonRect, text))
        lay.getRect(th.Vf2{1, 1}) // padding
}

fn drawGroup(ctx: ^DrawCtx, group: ^Group) {

        windowRect := group.rect
        contentRect := getWindowContentRectFromRect(group.rect)
        titlebarRect := getWindowDecorationRectFromRect(group.rect)

        lay := layoutInit(ctx, group.index)

        lay.putCommand(commandRect(c_shadow, rectMove(rectInset(windowRect, -1), th.Vf2{0, 1})))
        lay.putCommand(commandRect(c_decor, windowRect))
        lay.putCommand(commandRect(c_body, contentRect))

        lay.rect = titlebarRect

        for i, w in group.windows {
                _putButton(&lay, w.title)
        }
}

fn beginWindow*(title: str, r: rect.Rect) {
        v_lastWindow = title
        v_lastGroup = groupZoneAcquire(&v_groupZone, title, r)

        // Prevent drawing the group multiple times by checking if
        // the current window is the one displayed in the group.
        if isLastWindowVisible() {
                drawGroup(&v_drawCtx, v_lastGroup);
        }
}

fn putButton*(text: str) {
        if isLastWindowVisible() {
                _putButton(&layoutInit(&v_drawCtx, v_lastGroup.index, cuttingTop, getLastWindowContentRect()), text)
        }
}

// DRAGGING
// 1. Check if left mouse button is down
// 2. Iterate through windows
// 3. Check if we intersect with the window
// 4. Initiate window dragging
// 5. Drag the dragged window by specified mouse delta in following frames
//
// JOINING TABS
// 1. Iterate through windows
// 2. Check if mouse is above another window's titlebar
// 3. Attach to that another window
//
// SPLITTING TABS
// 1. Iterate through windows
// 2. Check if mouse is pressed on any certain tab
// 3. Save it as a held tab
// 4. When held tab goes out of titlebar, move it to a new group
