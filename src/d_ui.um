import (
  "std.um"
  "th.um"; "rect.um"; "canvas.um"; "input.um"; "window.um"; "image.um"
  "d_font.um"; "d_fps.um"
)


type (
  Scrolling = struct {
    scroll: real
    limit: real
    targetScroll: real
  }

  Window = struct {
    title: str
    rect: rect.Rect
    scroll: Scrolling
  }

  Group = struct {
    index: int
    windows: []Window
    current: uint
    rect: rect.Rect
    tabWidth: real //width of tabs total
    tabScroll: Scrolling
  }

  Cutting = int

  GroupZone = struct {
    /* base */
    groups: map[str]^Group // Window name to group
    stack: []^Group 
    join: bool
    firstJoin: bool

    /* ux */
    draggingGroup: ^Group // group currently dragging
    activeGroup: ^Group // group currently focused on
    dockingGroup:  ^Group // group we may attach to
    undockingWindow: str // window we may undock from the group
  }

  ButtonState = struct {
    down: bool
    pressed: bool
    released: bool       
  }

  InputState = struct {
    mousePos: th.Vf2
    mouseDelta: th.Vf2
    mouseScroll: int

    mouseMiddle: ButtonState
    mouseLeft: ButtonState
    mouseRight: ButtonState
  }

  DrawCommand = struct {
    color: uint32
    rect: rect.Rect
    text: str
    img: image.Image
  }

  DrawLayer = struct {
    commands: []DrawCommand
    index: int // Layer ordering for sorting
  }

  DrawCtx = struct {
    layers: []DrawLayer 
  }

  Layout = struct {
    index: int
    hasBounds: bool
    bounds: rect.Rect
    rect: rect.Rect
    cutter: Cutting
    ctx: ^DrawCtx
  }

  SequenceLayout = struct {
    start: th.Vf2
    end: th.Vf2
    lineHeight: th.fu
    maxX: th.fu
  }

  // Dictates where you should place your element.
  //  focused: whether the element should accept input or not
  //  rect: the rectangle where you should render your element
  UiElementPlace = struct {
    focused: bool
    rect: rect.Rect
  }

  UiLayoutType = int

  UiLayout = struct {
    position: th.Vf2 
    elementsPerRow: int
    rowHeight: real
    layoutType: UiLayoutType
    scroll: th.Vf2
  }

  UiState = struct {
    isCropped: bool
    groupIndex: int
    drawCtx: ^DrawCtx
    inputState: InputState
    baseRect: rect.Rect
    layouts: []UiLayout
  }
)

const (
  cuttingLeft = Cutting(0)
  cuttingRight = Cutting(1)
  cuttingTop = Cutting(2)
  cuttingBottom = Cutting(3)

  uiLayoutTypeColumn = UiLayoutType(0)
  uiLayoutTypeFixedRow = UiLayoutType(1)
  uiLayoutTypeDynamicRow = UiLayoutType(2)

  c_shadow = 0x00000022
  c_decor = 0x752f29FF
  c_item = 0x993333FF
  c_held = 0xC24444FF
  c_over = 0xAD4545FF
  c_fore = 0x000000FF
  c_body = th.white

  magicColorBeginScissorRect = 0x5B248E00
  magicColorEndScissorRect = 0x896A4100
)

////////////////////////////
// SequenceLayout

fn sequenceLayoutInit(pos: th.Vf2): SequenceLayout {
  return SequenceLayout{start: pos, end: pos}
}

fn (lay: ^SequenceLayout) newLine() {
  lay.end = th.Vf2{lay.start.x, lay.end.y + lay.lineHeight}
  lay.lineHeight = 0
}

fn (lay: ^SequenceLayout) getRect(): rect.Rect {
  return rect.mk(lay.start.x, lay.start.y, lay.maxX-lay.start.x, (lay.end.y-lay.start.y)+lay.lineHeight)
}

fn (lay: ^SequenceLayout) put(size: th.Vf2) {
  if (lay.lineHeight < size.y) {
    lay.lineHeight = size.y
  }

  lay.end.x += size.x;

  if (lay.maxX < lay.end.x) {
    lay.maxX = lay.end.x;
  }
}

fn (lay: ^SequenceLayout) padding(by: th.fu) {
  by = by - (trunc(lay.end.x-lay.start.x) % trunc(by))
  lay.put(th.Vf2{by, 0})
}

/////////////////////////////
// Scroll

fn scrollFix(scroll: ^Scrolling) {
  if scroll.targetScroll < scroll.limit {
    scroll.targetScroll = scroll.limit
  }
}

fn scrollLimit(scroll: ^Scrolling, to: real) {
  // Fix negative scroll
  if to > 0 {
    to = 0
  }
  scroll.limit = to
}

fn scrollBy(scroll: ^Scrolling, by: real) {
  scroll.targetScroll += by;
  if scroll.targetScroll > 0 {
    scroll.targetScroll = 0
  }
  scrollFix(scroll)
}

fn scrollUpdate(scroll: ^Scrolling) {
  speed := 10

  if (scroll.scroll < scroll.limit) {
    speed *= 3
  }

  scroll.scroll += (scroll.targetScroll-scroll.scroll)*(th.delta/1000.0)*speed;

  scrollFix(scroll)
}

/////////////////////////////
// Draw*

fn layerFromCommand(index: int, cmd: DrawCommand): DrawLayer {
  return DrawLayer{index: index, commands: []DrawCommand{cmd}}
}

fn drawCtxInit(): DrawCtx {
  return DrawCtx{layers: []DrawLayer{}}
}

fn commandRect(color: uint32, r: rect.Rect): DrawCommand {
  return DrawCommand{color: color, rect: r, text: ""}
}

fn commandBeginScissorRect(r: rect.Rect): DrawCommand {
  return DrawCommand{color: magicColorBeginScissorRect, rect: r}
}

fn commandEndScissorRect(): DrawCommand {
  return DrawCommand{color: magicColorEndScissorRect}
}

fn commandText(color: uint32, r: rect.Rect, t: str): DrawCommand {
  return DrawCommand{color: color, rect: r, text: t}
}

fn commandImage(r: rect.Rect, img: image.Image, tint: uint32 = th.white): DrawCommand {
  return DrawCommand{color: tint, rect: r, img: img}
}

fn (lay: ^DrawLayer) putCommand(cmd: DrawCommand) {
  lay.commands = append(lay.commands, cmd);
}

fn (ctx: ^DrawCtx) clear() {
  ctx.layers = []DrawLayer{}
}

fn (ctx: ^DrawCtx) putCommand(index: int, cmd: DrawCommand) {
  pushIndex := 0

  for i in ctx.layers {
    if ctx.layers[i].index > index {
      break
    }
    if ctx.layers[i].index == index { // found exact layer
      ctx.layers[i].putCommand(cmd)
      return
    }
    pushIndex += 1
  }

  if pushIndex == len(ctx.layers) {
    ctx.layers = append(ctx.layers, layerFromCommand(index, cmd))
  } else {
    newLayers := make([]DrawLayer, 0)
    for i in ctx.layers {
      if i == pushIndex {
        newLayers = append(newLayers, layerFromCommand(index, cmd))
      }
      newLayers = append(newLayers, ctx.layers[i])
    }
    ctx.layers = newLayers
  }
}

fn (ctx: ^DrawCtx) render(font: d_font.Font) {
  for i in ctx.layers {
    rectStack := make([]rect.Rect, 0)
    isScissor := false
    scissorRect := rect.Rect{}

    layer := &ctx.layers[i]
    for j, cmd in layer.commands {
      if cmd.color == magicColorBeginScissorRect {
        if isScissor {
          rectStack = append(rectStack, scissorRect)
        }
        isScissor = true
        scissorRect = cmd.rect
        window.beginScissorRect(cmd.rect)
      } else if cmd.color == magicColorEndScissorRect {
        if len(rectStack) > 0 {
          window.beginScissorRect(rectStack[len(rectStack)-1])
          rectStack = delete(rectStack, len(rectStack)-1)
        } else {
          window.endScissor()
          isScissor = false
        }
      } else if cmd.text != "" { // draw text
        size := font.measure(cmd.text)
        font.draw(cmd.text, th.Vf2{cmd.rect.x+(cmd.rect.w-size.x)/2, cmd.rect.y+(cmd.rect.h-size.y)/2}, cmd.color)
      } else if cmd.img.handle != 0 {
        // TODO: Maybe separate drawing the image as a rectangle into a separate function

        size := cmd.img.getDims()
        scale := th.Vf2{1/size.x*cmd.rect.w, 1/size.y*cmd.rect.h}
        pos := cmd.rect.getPos()
        pos.x = round(pos.x)
        pos.y = round(pos.y)

        cmd.img.draw(th.Transform{p: pos, s: scale})
      } else { // draw rect
        canvas.drawRect(cmd.color, cmd.rect)
      }
    }

    if isScissor {
      window.endScissor()
    }

    if len(rectStack) > 0 {
      error("Umatched endScissor");
    }
  }
}

///////////////////////
// Utility
fn rectInPoint(r: rect.Rect, p: th.Vf2): bool {
  return p.x > r.x && p.y > r.y && p.x < (r.x + r.w) && p.y < (r.y + r.h)
}

fn rectInset(r: rect.Rect, by: real): rect.Rect {
  return rect.mk(r.x+by, r.y+by, r.w-by*2, r.h-by*2)
}

fn rectMove(r: rect.Rect, by: th.Vf2): rect.Rect {
  return rect.Rect{r.x+by.x, r.y+by.y, r.w, r.h}
}

///////////////////////
// Cutting
fn cuttingCut(c: Cutting, r: ^rect.Rect, req: th.Vf2): rect.Rect {
  result := rect.Rect{-1e7, -1e7, 0, 0}
  switch c {
  case cuttingLeft:
    result = rect.mk(r.x, r.y, req.x, r.h)
    r.x += req.x;
    r.w -= req.x;
  case cuttingRight:
    result = rect.mk(r.x+r.w-req.x, r.y, req.x, r.h)
    r.w -= req.x;
  case cuttingTop:
    result = rect.mk(r.x, r.y, r.w, req.y)
    r.y += req.y;
    r.h -= req.y;
  case cuttingBottom:
    result = rect.mk(r.x, r.y+r.h-req.y, r.w, req.y)
    r.h -= req.y;
  }
  return result

}

///////////////////////
// Group
fn groupCreateFromWindow(win: Window): Group {
  windows := make([]Window, 1)
  windows[0] = win
  return Group{windows: windows, current: 0, rect: win.rect}
}

fn groupGetCurrentWindow(group: ^Group): ^Window {
  return &group.windows[group.current]
}

fn groupFindWindowIndex(group: ^Group, title: str): int {
  for i in group.windows {
    if group.windows[i].title == title {
      return i
    }
  }
  return -1
}

fn groupFindWindow(group: ^Group, title: str): ^Window {
  index := groupFindWindowIndex(group, title)
  if index < 0 {
    return null
  }
  return &group.windows[index]
}

fn groupAppendWindow(group: ^Group, win: Window) {
  group.windows = append(group.windows, win) 
}

///////////////////////
// Group Zone
fn groupZoneInit(): GroupZone {
  return GroupZone{groups: map[str]^Group{}, stack: make([]^Group, 0)}
}

fn groupZoneCreate(zone: ^GroupZone, win: Window): ^Group {
  newGroup := new(Group)
  newGroup ^= groupCreateFromWindow(win)
  zone.groups[win.title] = newGroup
  newGroup.index = len(zone.stack)
  zone.stack = append(zone.stack, newGroup)

  return newGroup 
}

fn groupZoneAcquire(zone: ^GroupZone, title: str, r: rect.Rect): ^Group {
  group := zone.groups[title]

  if group == null {
    if len(zone.stack) > 0 && zone.join && !zone.firstJoin {
      zone.groups[title] = zone.stack[len(zone.stack)-1]
      group = zone.groups[title]
      groupAppendWindow(zone.stack[len(zone.stack)-1], Window{title: title, rect: r})
    } else {
      zone.firstJoin = false
      group = groupZoneCreate(zone, Window{title: title, rect: r})
    }
  }
  
  return group
}

fn groupZoneReassignIndices(zone: ^GroupZone) {
  for i in zone.stack { 
    zone.stack[i].index = i
  }
}

fn groupZoneMoveToFront(zone: ^GroupZone, groupIndex: int): int {
  group := zone.stack[groupIndex]
  zone.stack = delete(zone.stack, groupIndex)
  zone.stack = append(zone.stack, group)

  groupZoneReassignIndices(zone)

  return group.index
}

fn groupZoneSetJoin(zone: ^GroupZone, set: bool) {
  zone.join = set
  zone.firstJoin = true
}

fn groupZoneUndockWindow(zone: ^GroupZone, title: str): ^Group {
  group := zone.groups[title]
  index := groupFindWindowIndex(group, title)

  if (index < 0) {
    error("Invalid index")
  }

  if (group.current >= index && group.current > 0) {
    group.current -= 1
  }

  win := group.windows[index]
  group.windows = delete(group.windows, index)

  return groupZoneCreate(zone, win);
}

fn groupZoneDockGroups(zone: ^GroupZone, srcIdx: int, dstIdx: int) {
  dst := zone.stack[dstIdx]
  src := zone.stack[srcIdx]

  for i, win in src.windows {
    zone.groups[win.title] = dst
    dst.windows = append(dst.windows, win)
  }

  zone.stack = delete(zone.stack, srcIdx)

  groupZoneReassignIndices(zone)
}

fn groupZoneLocateActiveGroup(zone: ^GroupZone, at: th.Vf2): ^Group {
  var group: ^Group = null
  for i in zone.stack {
    if rectInPoint(zone.stack[i].rect, at) {
      group = zone.stack[i]
    }
  }
  return group
}

///////////////////////
// Layout
fn layoutInit(ctx: ^DrawCtx, index: int, cutter: Cutting = cuttingLeft, r: rect.Rect = rect.Rect{0, 0, 0, 0}): Layout {
  return Layout{ctx: ctx, cutter: cutter, rect: r, index: index}
}

fn (lay: ^Layout) startRecord(): real {
  if lay.cutter == cuttingLeft || lay.cutter == cuttingRight {
    return lay.rect.x
  }
  return lay.rect.y
}

fn (lay: ^Layout) stopRecord(record: real): real {
  switch lay.cutter {
    case cuttingLeft:   return lay.rect.x-record;
    case cuttingRight:  return -(lay.rect.x-record);
    case cuttingTop:    return lay.rect.y-record;
    case cuttingBottom: return -(lay.rect.y-record);
    default: error("Unreachable");
  }
  return 0;
}

fn (lay: ^Layout) getRect(reqSize: th.Vf2): rect.Rect {
  return cuttingCut(lay.cutter, &lay.rect, reqSize)
}

fn isMouseOver(r: rect.Rect): bool {
  return rectInPoint(r, input.getMousePos())
}

fn (lay: ^Layout) isActive(): bool {
  if lay.hasBounds {
    // fix need for isMouseOver
    return isMouseOver(lay.bounds);
  }
  return true;
}

fn (lay: ^Layout) setBounds(r: rect.Rect) {
  lay.bounds = r;
  lay.hasBounds = true;
}

fn (lay: ^Layout) putCommand(cmd: DrawCommand) {
  lay.ctx.putCommand(lay.index, cmd)
}

///////////////////////
// UI
fn uiInit(drawCtx: ^DrawCtx): UiState {
  return UiState{layouts: make([]UiLayout, 0), drawCtx: drawCtx};
}

fn uiPutCommand(ui: ^UiState, command: DrawCommand) {
  ui.drawCtx.putCommand(ui.groupIndex, command)
}

fn uiBegin(ui: ^UiState, inputState: InputState) {
  // (1) Not really necessary, but good for debugging so you can immediately spot something's wrong
  ui.groupIndex = -1 // (1)
  ui.baseRect = rect.mk(0, 0, 0, 0) // (1)

  if ui.isCropped {
    error("ui is still cropped (have you called uiEnd?)\n")
  }

  if len(ui.layouts) > 0 {
    error("unfinished ui layouts\n")
  }

  ui.inputState = inputState
}

fn uiEnd(ui: ^UiState) {
  if ui.isCropped {
    uiPutCommand(ui, commandEndScissorRect())
    ui.isCropped = false
  }
}

fn uiBeginGroup(ui: ^UiState, baseRect: rect.Rect, zIndex: int) {
  if ui.isCropped {
    uiPutCommand(ui, commandEndScissorRect())
    ui.isCropped = false
  }

  ui.groupIndex = zIndex
  ui.baseRect = baseRect
}

fn uiLayoutTypeName(t: UiLayoutType): str {
  switch t {
    case uiLayoutTypeColumn: return "column"
    case uiLayoutTypeFixedRow: return "fixed row"
    case uiLayoutTypeDynamicRow: return "dynamic row"
  }
  return "unknown layout"
}

fn uiCurrentLayout(ui: ^UiState): ^UiLayout {
  if len(ui.layouts) > 0 {
    return &ui.layouts[len(ui.layouts)-1]
  }
  return null
}

// Adds an element into the UI and advances the layout.
fn uiPushElement(ui: ^UiState, size: th.Vf2): UiElementPlace {
  currentLayout := uiCurrentLayout(ui) 

  // (1) NOTE: for now here the positions are relative to the base rect 
  resultRect := rect.mk(currentLayout.position.x, currentLayout.position.y, size.x, size.y)

  switch currentLayout.layoutType {
    case uiLayoutTypeColumn:
      resultRect.w = ui.baseRect.w

      currentLayout.position.y += resultRect.h
    case uiLayoutTypeFixedRow:
      resultRect.w = ui.baseRect.w / real(currentLayout.elementsPerRow);
      
      if (resultRect.x+resultRect.w-1) > ui.baseRect.w { // wrap around
        resultRect.x = 0
        resultRect.y += currentLayout.rowHeight
        currentLayout.position.y += currentLayout.rowHeight
        currentLayout.position.x = 0
        currentLayout.rowHeight = 0
      }

      if resultRect.h > currentLayout.rowHeight {
        currentLayout.rowHeight = resultRect.h
      }

      currentLayout.position.x += ui.baseRect.w / real(currentLayout.elementsPerRow)
    case uiLayoutTypeDynamicRow:
      if (resultRect.x+resultRect.w) > ui.baseRect.w { // wrap around
        resultRect.x = 0
        resultRect.y += currentLayout.rowHeight
        currentLayout.position.y += currentLayout.rowHeight
        currentLayout.position.x = 0
        currentLayout.rowHeight = 0
      }

      if resultRect.h > currentLayout.rowHeight {
        currentLayout.rowHeight = resultRect.h
      }

      currentLayout.position.x += resultRect.w
  }

  // (1) ... Then they are transformed to the absolute position.
  resultRect.x += ui.baseRect.x+currentLayout.scroll.x
  resultRect.y += ui.baseRect.y+currentLayout.scroll.y

  return UiElementPlace{rectInPoint(resultRect, ui.inputState.mousePos), resultRect}
}

fn uiGetBounds(ui: ^UiState): th.Vf2 {
  currentLayout := uiCurrentLayout(ui)
  bounds := th.Vf2{ui.baseRect.w, ui.baseRect.h}
  addendum := currentLayout.position.add(th.Vf2{0, currentLayout.rowHeight})

  if addendum.x > bounds.x {
    bounds.x = addendum.x
  }

  if addendum.y > bounds.y {
    bounds.y = addendum.y
  }

  return bounds
}

//
// Crops the contents of the base rectangle
// 
// ui: ui state
//
fn uiCropContents(ui: ^UiState) {
  ui.isCropped = true
  uiPutCommand(ui, commandBeginScissorRect(ui.baseRect))
}

//
// Scrolls the current layout
//
// ui: ui state
// offset: x/y scroll offset
//
fn uiSetScroll(ui: ^UiState, offset: th.Vf2) {
  currentLayout := uiCurrentLayout(ui)
  currentLayout.scroll.x += offset.x
  currentLayout.scroll.y += offset.y
}

fn uiPopLayout(ui: ^UiState, expectedType: UiLayoutType) {
  currentLayout := uiCurrentLayout(ui)
  currentType := uiCurrentLayout(ui).layoutType

  if currentType != expectedType {
    buf := str(make([]char, 256))
    sprintf(buf, "(UI) Layout type mismatch: started with %s but ended with %s", uiLayoutTypeName(currentType), uiLayoutTypeName(expectedType))
    error(buf)
  } else {
    ui.layouts = delete(ui.layouts, len(ui.layouts)-1)
    if len(ui.layouts) > 0 {
      // FIXME: BAD
      ui.layouts[len(ui.layouts)-1].position.y = currentLayout.position.y+currentLayout.rowHeight
      ui.layouts[len(ui.layouts)-1].position.x = 0
    }
  }
}

fn uiBeginLayout(ui: ^UiState, layoutType: UiLayoutType, elementsPerRow: int = 0) {
  currentLayout := uiCurrentLayout(ui)
  newLayout := UiLayout{layoutType: layoutType, elementsPerRow: elementsPerRow}

  if currentLayout != null {
    newLayout.scroll = currentLayout.scroll
    newLayout.position = currentLayout.position
  }

  ui.layouts = append(ui.layouts, newLayout)
}

// Begins a column layout.
// It becomes full width to the parent rectangle and moves on to next row.
fn uiBeginColumn(ui: ^UiState) {
  uiBeginLayout(ui, uiLayoutTypeColumn)
}

fn uiEndColumn(ui: ^UiState) {
  uiPopLayout(ui, uiLayoutTypeColumn)
}

// Begins a dynamic row layout.
// It uses its provided size and wraps around if needed.
fn uiBeginDynamicRow(ui: ^UiState) {
  uiBeginLayout(ui, uiLayoutTypeDynamicRow)
}

fn uiEndDynamicRow(ui: ^UiState) {
  uiPopLayout(ui, uiLayoutTypeDynamicRow)
}

// Begins a fixed row layout.
// It assigns element width to parent width divided by element per row, and wraps around if needed.
fn uiBeginFixedRow(ui: ^UiState, elementsPerRow: int) {
  uiBeginLayout(ui, uiLayoutTypeFixedRow, elementsPerRow)
}

fn uiEndFixedRow(ui: ^UiState) {
  uiPopLayout(ui, uiLayoutTypeFixedRow)
}

var (
  v_font: d_font.Font
  v_drawCtx: DrawCtx
  
  v_groupZone: GroupZone
  v_lastGroup: ^Group
  v_lastWindow: str
  v_uiState: UiState

  v_dbgMask: uint32 // mask for debug ui
  v_inputState: InputState
)

///////////////////////
// UI (Interface)

// Begins a column layout.
// It becomes full width to the parent rectangle and moves on to next row.
fn beginColumn*() {
  uiBeginColumn(&v_uiState)
}

fn endColumn*() {
  uiEndColumn(&v_uiState)
}

// Begins a dynamic row layout.
// It uses its provided size and wraps around if needed.
fn beginDynamicRow*() {
  uiBeginDynamicRow(&v_uiState)
}

fn endDynamicRow*() {
  uiEndDynamicRow(&v_uiState)
}

// Begins a fixed row layout.
// It assigns element width to parent width divided by element per row, and wraps around if needed.
fn beginFixedRow*(elementsPerRow: int) {
  uiBeginFixedRow(&v_uiState, elementsPerRow)
}

fn endFixedRow*() {
  uiEndFixedRow(&v_uiState)
}

fn init*(font: d_font.Font) {
  v_font = font
  v_groupZone = groupZoneInit()
  v_drawCtx = drawCtxInit()
  v_uiState = uiInit(&v_drawCtx)
}

fn populateMouseButton(previous: ButtonState, button: char): ButtonState {
  return ButtonState{
    down: input.isPressed(button),
    pressed: input.isJustPressed(button),
    released: previous.down && !input.isPressed(button)}
}

fn populateInputState(previous: InputState): InputState {
  var output: InputState

  output.mouseLeft = populateMouseButton(previous.mouseLeft, input.mouse1);
  output.mouseMiddle = populateMouseButton(previous.mouseMiddle, input.mouse2);
  output.mouseRight = populateMouseButton(previous.mouseRight, input.mouse3);

  output.mousePos = input.getMousePos()
  output.mouseDelta = output.mousePos.sub(previous.mousePos)
  output.mouseScroll = int(input.isJustPressed(input.mouse_up)) - int(input.isJustPressed(input.mouse_down));

  return output
}

fn dbgPrintText(lay: ^SequenceLayout, label: str, color: uint32) {
  size := v_font.measure(label)
  r := rect.mk(lay.end.x, lay.end.y, size.x, size.y)

  v_drawCtx.putCommand(99, commandText(color & v_dbgMask, r, label))
  lay.put(v_font.measure(label))
}

fn dbgPrintSect(lay: ^SequenceLayout, label: str) {
  dbgPrintText(lay, label, th.white)
  startX := lay.end.x 
  lay.padding(100)
  endX := lay.end.x
  y := lay.end.y + v_font.height/2;

  v_drawCtx.putCommand(99, commandRect(0xFFFFFF11 & v_dbgMask, rect.mk(startX, y, endX-startX, 1)))
}

fn dbgPrintBool(lay: ^SequenceLayout, label: str, value: bool) {
  dbgPrintText(lay, label, [2]uint32{th.white & 0xFFFFFF99, th.green}[int(value)])
}

fn dbgPrintButtonState(lay: ^SequenceLayout, label: str, state: ButtonState) {
  dbgPrintSect(lay, label);

  dbgPrintBool(lay, "down ", state.down)
  dbgPrintBool(lay, "pressed ", state.pressed)
  dbgPrintBool(lay, "released", state.released)

  lay.newLine()
}

fn dbgPrintInputState(lay: ^SequenceLayout, state: InputState) {
  dbgPrintButtonState(lay, "MouseLeft", state.mouseLeft);
  dbgPrintButtonState(lay, "MouseMiddle", state.mouseMiddle);
  dbgPrintButtonState(lay, "MouseRight", state.mouseRight);

  dbgPrintSect(lay, "MouseDelta");
  dbgPrintText(lay, "x"+std.ftoa(state.mouseDelta.x, 0), th.white & 0xFFFFFF99)
  lay.padding(150)
  dbgPrintText(lay, "y"+std.ftoa(state.mouseDelta.y, 0), th.white & 0xFFFFFF99)
  lay.newLine()

  dbgPrintSect(lay, "MousePos");
  dbgPrintText(lay, "x"+std.ftoa(state.mousePos.x, 0), th.white & 0xFFFFFF99)
  lay.padding(150)
  dbgPrintText(lay, "y"+std.ftoa(state.mousePos.y, 0), th.white & 0xFFFFFF99)
  lay.newLine()

  dbgPrintSect(lay, "MouseScroll");
  dbgPrintText(lay, std.itoa(state.mouseScroll), th.white & 0xFFFFFF99)
  lay.newLine()
}

fn dbgPrintGroup(lay: ^SequenceLayout, label: str, group: ^Group) {
  dbgPrintSect(lay, label);
  if group != null {
    dbgPrintText(lay, std.itoa(group.index), th.white & 0xFFFFFF99)
  } else {
    dbgPrintText(lay, "null", th.white & 0xFFFFFF99)
  }
  lay.newLine()
}

fn dbgMain(pos: th.Vf2) {
  lay := sequenceLayoutInit(pos)
  dbgPrintSect(&lay, "FPS")
  dbgPrintText(&lay, std.itoa(round(d_fps.getFps())), th.white & 0xFFFFFF99)
  lay.newLine()

  dbgPrintInputState(&lay, v_inputState)
  dbgPrintGroup(&lay, "DockingGroup", v_groupZone.dockingGroup)
  dbgPrintGroup(&lay, "DraggingGroup", v_groupZone.draggingGroup)
  dbgPrintGroup(&lay, "ActiveGroup", v_groupZone.activeGroup)
  dbgPrintSect(&lay, "WindowScroll")
  if v_groupZone.activeGroup != null {
    dbgPrintText(&lay, repr(groupGetCurrentWindow(v_groupZone.activeGroup).scroll.targetScroll), th.white & 0xFFFFFF99)
  }
  lay.newLine()
  dbgPrintSect(&lay, "UndockWindow")
  dbgPrintText(&lay, v_groupZone.undockingWindow, th.white & 0xFFFFFF99)
  lay.newLine()

  // make lighter on hover
  if (rectInPoint(lay.getRect(), v_inputState.mousePos)) {
    v_dbgMask = 0xFFFFFF55
    v_drawCtx.putCommand(98, commandRect(th.black&0x11, rectInset(lay.getRect(), -5)))
  } else {
    v_dbgMask = 0xFFFFFFFF
    v_drawCtx.putCommand(98, commandRect(th.black&0xBB, rectInset(lay.getRect(), -5)))
  }
}

fn getWindowDecorationRectFromRect(r: rect.Rect): rect.Rect {
  return rect.mk(r.x, r.y, r.w, v_font.height + 4)
}

fn getWindowContentRectFromRect(r: rect.Rect): rect.Rect {
  deco := getWindowDecorationRectFromRect(r)
  r.y += deco.h
  r.h -= deco.h
  return rectInset(r, 1)
}

fn locateDockingCandidate(zone: ^GroupZone, at: th.Vf2): ^Group {
  var group: ^Group = null
  for i in zone.stack {
    if zone.draggingGroup != null && i == zone.draggingGroup.index {
      continue 
    }

    if rectInPoint(zone.stack[i].rect, at) {
      group = zone.stack[i]
    }
  }

  if group != null && rectInPoint(getWindowDecorationRectFromRect(group.rect), at) {
    return group
  }

  return null
}

fn isOnTitlebar(): bool {
  if (v_groupZone.activeGroup != null) {
    return rectInPoint(getWindowDecorationRectFromRect(v_groupZone.activeGroup.rect), v_inputState.mousePos)
  }
  return false;
}

fn handleInput() {
  inputState := v_inputState
  zone := &v_groupZone

  zone.dockingGroup = null
  if zone.draggingGroup != null {
    zone.draggingGroup.rect = rectMove(zone.draggingGroup.rect, inputState.mouseDelta)
    if rectInPoint(getWindowDecorationRectFromRect(zone.draggingGroup.rect), inputState.mousePos) {
      zone.dockingGroup = locateDockingCandidate(zone, inputState.mousePos)
    }
  }

  zone.activeGroup = groupZoneLocateActiveGroup(zone, inputState.mousePos)

  if inputState.mouseLeft.released && zone.draggingGroup != null && zone.dockingGroup != null {
    groupZoneDockGroups(zone, zone.draggingGroup.index, zone.dockingGroup.index)
  }

  if inputState.mouseLeft.down == false  {
    zone.undockingWindow = ""
    zone.draggingGroup = null
  }

  if zone.activeGroup != null {
    if inputState.mouseLeft.pressed {
      zone.draggingGroup = zone.activeGroup
      groupZoneMoveToFront(zone, zone.draggingGroup.index)
    }
  }

  if zone.undockingWindow != "" && !isOnTitlebar() {
    group := groupZoneUndockWindow(zone, zone.undockingWindow)
    group.rect.x = inputState.mousePos.x - 10;
    group.rect.y = inputState.mousePos.y - 10;
    zone.activeGroup = group
    zone.draggingGroup = group
    zone.undockingWindow = ""
  }
}

fn handleGroups() {
  for _, group in v_groupZone.groups {
    for i in group.windows {
      scrollUpdate(&group.windows[i].scroll)
    }
    scrollUpdate(&group.tabScroll)
  }
}

fn begin*() {
  d_fps.update()
  v_inputState = populateInputState(v_inputState);
  handleInput()
  handleGroups()
  groupZoneSetJoin(&v_groupZone, false)
  dbgMain(th.Vf2{10, 10});
  uiBegin(&v_uiState, v_inputState)
}

fn getLastWindow(): ^Window {
  return groupFindWindow(v_lastGroup, v_lastWindow)
}

fn getLastWindowContentRect(): rect.Rect {
  return rectInset(getWindowContentRectFromRect(v_lastGroup.rect), 5);
}

fn endWindow();

fn end*() {
  uiEnd(&v_uiState)
  if v_lastGroup != null {
    endWindow()
  }
  v_lastGroup = null

  v_drawCtx.render(v_font)
  v_drawCtx.clear()
}

fn setJoinWindows*(set: bool) {
  groupZoneSetJoin(&v_groupZone, set)
}

fn isGroupVisible(group: ^Group): bool {
  if (group == null) {
    return false
  }

  if (v_lastWindow != group.windows[group.current].title) {
    return false
  }  

  return true
}

fn isGroupRendered(group: ^Group): bool {
  return isGroupVisible(group) && (group == v_groupZone.dockingGroup || v_groupZone.dockingGroup == null)
}

fn invalidateClick() {
  v_groupZone.draggingGroup = null
}

fn getTextWidgetRect(lay: ^Layout, text: str): rect.Rect {
  size := v_font.measure(text) 
  size.x += 10 // padding
  size.y += 5
  return lay.getRect(size)
}

fn _putLabel(lay: ^Layout, text: str) {
  lay.putCommand(commandText(c_fore, getTextWidgetRect(lay, text), text))    
}

fn _putLabelNeo(text: str) {
  size := v_font.measure(text) 
  size.x += 10 // padding
  size.y += 5

  labelRect := uiPushElement(&v_uiState, size).rect
  labelRect.w -= 1
  labelRect.h -= 1
  uiPutCommand(&v_uiState, commandText(c_fore, labelRect, text))
}

fn _putImage(img: image.Image, size: th.Vf2 = th.Vf2{0, 0}) {
  if size.x == 0 && size.y == 0 {
    size = img.getDims()
  }
  place := uiPushElement(&v_uiState, size)

  uiPutCommand(&v_uiState, commandImage(place.rect, img))
}

fn _putButtonNeo(text: str): ButtonState {
  size := v_font.measure(text) 
  size.x += 10 // padding
  size.y += 5

  buttonPlace := uiPushElement(&v_uiState, size)
  buttonPlace.rect.w -= 1
  buttonPlace.rect.h -= 1

  pressed := false
  released := false
  down := false

  color := c_item

  if v_groupZone.activeGroup == v_lastGroup && buttonPlace.focused {
    color = c_over
    if v_inputState.mouseLeft.released {
      released = true
    }
    if v_inputState.mouseLeft.pressed {
      invalidateClick()
      pressed = true
    }
    if v_inputState.mouseLeft.down {
      down = true
      color = c_held
    }   
  }

  uiPutCommand(&v_uiState, commandRect(color, buttonPlace.rect))
  uiPutCommand(&v_uiState, commandText(c_body, buttonPlace.rect, text))

  return ButtonState{pressed: pressed, released: released, down: down}
}     

fn _putButtonToggle(lay: ^Layout, text: str, out: bool): ButtonState {
  buttonRect := getTextWidgetRect(lay, text)
  
  pressed := false
  released := false
  down := false

  color := c_item

  if out {
    color = c_held
  }

  // FIXME: using static variables
  if v_groupZone.activeGroup == v_lastGroup && lay.isActive() && isMouseOver(buttonRect) {
    color = c_over
    if v_inputState.mouseLeft.released {
      released = true
    }
    if v_inputState.mouseLeft.pressed {
      invalidateClick()
      pressed = true
    }
    if v_inputState.mouseLeft.down {
      down = true
      color = c_held
    }
  }

  lay.putCommand(commandRect(color, buttonRect))
  lay.putCommand(commandText(c_body, buttonRect, text))
  lay.getRect(th.Vf2{1, 1}) // padding
  return ButtonState{pressed: pressed, released: released, down: down}
}

fn _putButton(lay: ^Layout, text: str): ButtonState {
  return _putButtonToggle(lay, text, false)
}

fn beginWindow*(title: str, r: rect.Rect);

// FIXME: this relies on groupZone which is external
fn drawGroup(ctx: ^DrawCtx, group: ^Group) {
  // Render the window & handle undocking
  if isGroupRendered(group) {
    win := groupGetCurrentWindow(group)
    windowRect := group.rect
    contentRect := getWindowContentRectFromRect(group.rect)
    titlebarRect := getWindowDecorationRectFromRect(group.rect)

    // Scroll
    if v_groupZone.activeGroup == group && isMouseOver(titlebarRect) {
      scrollBy(&group.tabScroll, v_inputState.mouseScroll * 20);
    }

    if v_groupZone.activeGroup == group && isMouseOver(contentRect) {
      scrollBy(&win.scroll, v_inputState.mouseScroll * 20)
    }


    lay := layoutInit(ctx, group.index)

    // Draw shadow
    lay.putCommand(commandRect(c_shadow, rectMove(rectInset(windowRect, -1), th.Vf2{0, 1})))
    lay.putCommand(commandRect(c_decor, windowRect))
    lay.putCommand(commandRect(c_body, contentRect))

    // Draw scroll bar
    if win.scroll.limit < 0 {
      innerH := contentRect.h - 10
      innerRect := contentRect
      bar := cuttingCut(cuttingRight, &innerRect, th.Vf2{3, 0})
      percentOfs := -win.scroll.scroll/(innerH-win.scroll.limit)
      percentSize := contentRect.h/(contentRect.h-win.scroll.limit)
      if percentOfs + percentSize > 1.0 {
        percentSize = 1.0-percentOfs
      }

      bar.y += percentOfs*contentRect.h
      bar.h = percentSize*contentRect.h
      lay.putCommand(commandRect(c_shadow, bar))
    }

    lay.rect = titlebarRect

    if len(group.windows) == 1 { // One tab, render only the title
      lay.putCommand(commandText(c_body, titlebarRect, group.windows[0].title))
    } else { // Two or more tabs, render the tab menu
      if _putButton(&lay, "||||").pressed {
        v_groupZone.draggingGroup = group
      }
      titlebarWidth := lay.rect.w

      // Begin scissor
      lay.putCommand(commandBeginScissorRect(lay.rect))
      lay.setBounds(lay.rect)
      lay.getRect(th.Vf2{group.tabScroll.scroll, 0})
      rec := lay.startRecord()

      for i, w in group.windows {
        button := _putButtonToggle(&lay, w.title, group.current == i)

        if button.pressed {
          v_groupZone.undockingWindow = w.title
        }

        if button.released && group.current != i {
          // FIXME: maybe less hacky eh?
          group.current = i
          beginWindow(group.windows[group.current].title, rect.mk(0, 0, 1, 1))
        }
      }

      scrollLimit(&group.tabScroll, -(lay.stopRecord(rec)-titlebarWidth))
      // End scissor
      lay.putCommand(commandEndScissorRect())
    }
  } else {
    ctx.putCommand(group.index, commandRect(c_shadow, group.rect))
  }
}

fn endWindow() {
  scrollLimit(&getLastWindow().scroll, -(uiGetBounds(&v_uiState).y-v_uiState.baseRect.h))
  uiEndColumn(&v_uiState)
}

fn beginWindow*(title: str, r: rect.Rect) {
  if v_lastGroup != null {
    endWindow()
  }
 
  v_lastGroup = groupZoneAcquire(&v_groupZone, title, r)
  v_lastWindow = title

  {
    r := getLastWindowContentRect()

    uiBeginGroup(&v_uiState, r, v_lastGroup.index)
    uiBeginColumn(&v_uiState)

    if isGroupVisible(v_lastGroup) {
      drawGroup(&v_drawCtx, v_lastGroup)
    }

    uiCropContents(&v_uiState)
    
    // TODO: Store the scroll in the widget instead of manually
    win := groupGetCurrentWindow(v_lastGroup)
    uiSetScroll(&v_uiState, th.Vf2{0, win.scroll.scroll})
  }
}

// TODO: get rid of these functions as they are only needed for checking if the group is rendered,
// we can instead just disable UI rendering and input in the UiState.

fn putImage*(img: image.Image, size: th.Vf2 = th.Vf2{0, 0}) {
  if isGroupRendered(v_lastGroup) {
    _putImage(img, size)
  }
}

fn putButton*(text: str): ButtonState {
  if isGroupRendered(v_lastGroup) {
    output := _putButtonNeo(text)
    return output;
  }
  return ButtonState{}
}

fn putLabel*(text: str) {
  if isGroupRendered(v_lastGroup) {
    _putLabelNeo(text)
  }
}


// DRAGGING
// 1. Check if left mouse button is down
// 2. Iterate through windows
// 3. Check if we intersect with the window
// 4. Initiate window dragging
// 5. Drag the dragged window by specified mouse delta in following frames
//
// JOINING TABS
// 1. Iterate through windows
// 2. Check if mouse is above another window's titlebar
// 3. Attach to that another window
//
// SPLITTING TABS
// 1. Iterate through windows
// 2. Check if mouse is pressed on any certain tab
// 3. Save it as a held tab
// 4. When held tab goes out of titlebar, move it to a new group
