import (
  "std.um"
  "th.um"; "rect.um"; "canvas.um"; "input.um"; "window.um"; "image.um"
  "d_font.um"; "d_fps.um"
)

type (
  Scrolling = struct {
    scroll: real
    limit: real
    targetScroll: real
  }

  Window = struct {
    title: str
    rect: rect.Rect
    scroll: Scrolling
    visibilityStatus: int // 0 = hidden, 1 = shown last frame, 2 = shown this frame
  }

  Group = struct {
    index: int
    windows: []Window
    current: uint
    rect: rect.Rect
    tabWidth: real //width of tabs total
    tabScroll: Scrolling
  }

  GroupZone = struct {
    /* base */
    groups: map[str]^Group // Window name to group
    stack: []^Group 
    join: bool
    firstJoin: bool
    dockGroups: bool

    currentDockingCandidate: ^Group
    currentActiveGroup: ^Group
    currentActiveCandidateGroup: ^Group
    currentDraggingGroup: ^Group
    currentGroup: ^Group
    currentWindow: str
  }

  ButtonState = struct {
    over: bool
    down: bool
    pressed: bool
    released: bool       
  }

  InputState = struct {
    mousePos: th.Vf2
    mouseDelta: th.Vf2
    mouseScroll: int

    mouseMiddle: ButtonState
    mouseLeft: ButtonState
    mouseRight: ButtonState
  }

  DrawCommand = struct {
    color: uint32
    rect: rect.Rect
    text: str
    img: image.Image
  }

  DrawLayer = struct {
    commands: []DrawCommand
    index: int // Layer ordering for sorting
  }

  DrawCtx = struct {
    layers: []DrawLayer 
  }

  SequenceLayout = struct {
    start: th.Vf2
    end: th.Vf2
    lineHeight: th.fu
    maxX: th.fu
  }

  UiLayoutType = int

  UiLayout = struct {
    position: th.Vf2 
    elementsPerRow: int
    rowHeight: real
    layoutType: UiLayoutType
    bounds: rect.Rect
    scroll: th.Vf2
  }

  UiState = struct {
    isCropped: bool
    groupIndex: int
    drawCtx: ^DrawCtx
    inputState: InputState
    elements: []rect.Rect
    layouts: []UiLayout
  }
)

const (
  uiLayoutTypeColumn = UiLayoutType(0)
  uiLayoutTypeFixedRow = UiLayoutType(1)
  uiLayoutTypeDynamicRow = UiLayoutType(2)
  uiLayoutTypeScreen = UiLayoutType(4)

  c_shadow = 0x00000022
  c_decor = 0x752f29FF
  c_item = 0x993333FF
  c_held = 0xC24444FF
  c_over = 0xAD4545FF
  c_fore = 0x000000FF
  c_body = th.white

  magicColorBeginScissorRect = 0x5B248E00
  magicColorEndScissorRect = 0x896A4100
)

////////////////////////////
// SequenceLayout

fn sequenceLayoutInit(pos: th.Vf2): SequenceLayout {
  return SequenceLayout{start: pos, end: pos}
}

fn (lay: ^SequenceLayout) newLine() {
  lay.end = th.Vf2{lay.start.x, lay.end.y + lay.lineHeight}
  lay.lineHeight = 0
}

fn (lay: ^SequenceLayout) getRect(): rect.Rect {
  return rect.mk(lay.start.x, lay.start.y, lay.maxX-lay.start.x, (lay.end.y-lay.start.y)+lay.lineHeight)
}

fn (lay: ^SequenceLayout) put(size: th.Vf2) {
  if (lay.lineHeight < size.y) {
    lay.lineHeight = size.y
  }

  lay.end.x += size.x;

  if (lay.maxX < lay.end.x) {
    lay.maxX = lay.end.x;
  }
}

fn (lay: ^SequenceLayout) padding(by: th.fu) {
  by = by - (trunc(lay.end.x-lay.start.x) % trunc(by))
  lay.put(th.Vf2{by, 0})
}

/////////////////////////////
// Scroll

fn scrollFix(scroll: ^Scrolling) {
  if scroll.targetScroll < scroll.limit {
    scroll.targetScroll = scroll.limit
  }
}

fn scrollLimit(scroll: ^Scrolling, to: real) {
  // Fix negative scroll
  if to > 0 {
    to = 0
  }
  scroll.limit = to
}

fn scrollBy(scroll: ^Scrolling, by: real) {
  scroll.targetScroll += by;
  if scroll.targetScroll > 0 {
    scroll.targetScroll = 0
  }
  scrollFix(scroll)
}

fn scrollUpdate(scroll: ^Scrolling) {
  speed := 10

  if (scroll.scroll < scroll.limit) {
    speed *= 3
  }

  scroll.scroll += (scroll.targetScroll-scroll.scroll)*(th.delta/1000.0)*speed;

  scrollFix(scroll)
}

/////////////////////////////
// Draw*

fn layerFromCommand(index: int, cmd: DrawCommand): DrawLayer {
  return DrawLayer{index: index, commands: []DrawCommand{cmd}}
}

fn drawCtxInit(): DrawCtx {
  return DrawCtx{layers: []DrawLayer{}}
}

fn commandRect(color: uint32, r: rect.Rect): DrawCommand {
  return DrawCommand{color: color, rect: r, text: ""}
}

fn commandBeginScissorRect(r: rect.Rect): DrawCommand {
  return DrawCommand{color: magicColorBeginScissorRect, rect: r}
}

fn commandEndScissorRect(): DrawCommand {
  return DrawCommand{color: magicColorEndScissorRect}
}

fn commandText(color: uint32, r: rect.Rect, t: str): DrawCommand {
  return DrawCommand{color: color, rect: r, text: t}
}

fn commandImage(r: rect.Rect, img: image.Image, tint: uint32 = th.white): DrawCommand {
  return DrawCommand{color: tint, rect: r, img: img}
}

fn (lay: ^DrawLayer) putCommand(cmd: DrawCommand) {
  lay.commands = append(lay.commands, cmd);
}

fn (ctx: ^DrawCtx) clear() {
  ctx.layers = []DrawLayer{}
}

fn (ctx: ^DrawCtx) putCommand(index: int, cmd: DrawCommand) {
  pushIndex := 0

  for i in ctx.layers {
    if ctx.layers[i].index > index {
      break
    }
    if ctx.layers[i].index == index { // found exact layer
      ctx.layers[i].putCommand(cmd)
      return
    }
    pushIndex += 1
  }

  if pushIndex == len(ctx.layers) {
    ctx.layers = append(ctx.layers, layerFromCommand(index, cmd))
  } else {
    newLayers := make([]DrawLayer, 0)
    for i in ctx.layers {
      if i == pushIndex {
        newLayers = append(newLayers, layerFromCommand(index, cmd))
      }
      newLayers = append(newLayers, ctx.layers[i])
    }
    ctx.layers = newLayers
  }
}

fn (ctx: ^DrawCtx) render(font: d_font.Font) {
  for i in ctx.layers {
    rectStack := make([]rect.Rect, 0)
    isScissor := false
    scissorRect := rect.Rect{}

    layer := &ctx.layers[i]
    for j, cmd in layer.commands {
      if cmd.color == magicColorBeginScissorRect {
        if isScissor {
          rectStack = append(rectStack, scissorRect)
        }
        isScissor = true
        scissorRect = cmd.rect
        window.beginScissorRect(cmd.rect)
      } else if cmd.color == magicColorEndScissorRect {
        if len(rectStack) > 0 {
          window.beginScissorRect(rectStack[len(rectStack)-1])
          rectStack = delete(rectStack, len(rectStack)-1)
        } else {
          window.endScissor()
          isScissor = false
        }
      } else if cmd.text != "" { // draw text
        size := font.measure(cmd.text)
        font.draw(cmd.text, th.Vf2{cmd.rect.x+(cmd.rect.w-size.x)/2, cmd.rect.y+(cmd.rect.h-size.y)/2}, cmd.color)
      } else if cmd.img.handle != 0 {
        // TODO: Maybe separate drawing the image as a rectangle into a separate function

        size := cmd.img.getDims()
        scale := th.Vf2{1/size.x*cmd.rect.w, 1/size.y*cmd.rect.h}
        pos := cmd.rect.getPos()
        pos.x = round(pos.x)
        pos.y = round(pos.y)

        cmd.img.draw(th.Transform{p: pos, s: scale})
      } else { // draw rect
        canvas.drawRect(cmd.color, cmd.rect)
      }
    }

    if isScissor {
      window.endScissor()
    }

    if len(rectStack) > 0 {
      error("Umatched endScissor");
    }
  }
}

///////////////////////
// Utility
fn rectInPoint(r: rect.Rect, p: th.Vf2): bool {
  return p.x > r.x && p.y > r.y && p.x < (r.x + r.w) && p.y < (r.y + r.h)
}

fn rectInset(r: rect.Rect, by: real): rect.Rect {
  return rect.mk(r.x+by, r.y+by, r.w-by*2, r.h-by*2)
}

fn rectMove(r: rect.Rect, by: th.Vf2): rect.Rect {
  return rect.Rect{r.x+by.x, r.y+by.y, r.w, r.h}
}

///////////////////////
// Group
fn groupCreateFromWindow(win: Window): Group {
  windows := make([]Window, 1)
  windows[0] = win
  return Group{windows: windows, current: 0, rect: win.rect}
}

fn groupGetCurrentWindow(group: ^Group): ^Window {
  return &group.windows[group.current]
}

fn groupFindWindowIndex(group: ^Group, title: str): int {
  for i in group.windows {
    if group.windows[i].title == title {
      return i
    }
  }
  return -1
}

fn groupFindWindow(group: ^Group, title: str): ^Window {
  index := groupFindWindowIndex(group, title)
  if index < 0 {
    return null
  }
  return &group.windows[index]
}

fn groupAppendWindow(group: ^Group, win: Window) {
  group.windows = append(group.windows, win) 
}

///////////////////////
// Group Zone
fn groupZoneInit(): GroupZone {
  return GroupZone{groups: map[str]^Group{}, stack: make([]^Group, 0)}
}

fn groupZoneCreate(zone: ^GroupZone, win: Window): ^Group {
  newGroup := new(Group)
  newGroup ^= groupCreateFromWindow(win)
  zone.groups[win.title] = newGroup
  newGroup.index = len(zone.stack)
  zone.stack = append(zone.stack, newGroup)

  return newGroup 
}

fn groupZoneAcquire(zone: ^GroupZone, title: str, r: rect.Rect): ^Group {
  group := zone.groups[title]

  if group == null {
    if len(zone.stack) > 0 && zone.join && !zone.firstJoin {
      zone.groups[title] = zone.stack[len(zone.stack)-1]
      group = zone.groups[title]
      groupAppendWindow(zone.stack[len(zone.stack)-1], Window{title: title, rect: r})
    } else {
      zone.firstJoin = false
      group = groupZoneCreate(zone, Window{title: title, rect: r})
    }
  }
  
  return group
}

fn groupZoneReassignIndices(zone: ^GroupZone) {
  for i in zone.stack { 
    zone.stack[i].index = i
  }
}

fn groupZoneMoveToFront(zone: ^GroupZone, groupIndex: int): int {
  group := zone.stack[groupIndex]
  zone.stack = delete(zone.stack, groupIndex)
  zone.stack = append(zone.stack, group)

  groupZoneReassignIndices(zone)

  return group.index
}

fn groupZoneSetJoin(zone: ^GroupZone, set: bool) {
  zone.join = set
  zone.firstJoin = true
}

fn groupZoneUndockWindow(zone: ^GroupZone, title: str): ^Group {
  group := zone.groups[title]
  index := groupFindWindowIndex(group, title)

  if (index < 0) {
    error("Invalid index")
  }

  if (group.current >= index && group.current > 0) {
    group.current -= 1
  }

  win := group.windows[index]
  group.windows = delete(group.windows, index)

  return groupZoneCreate(zone, win);
}

fn groupZoneDockGroups(zone: ^GroupZone, srcIdx: int, dstIdx: int) {
  printf("Indices %d %d\n", srcIdx, dstIdx)
  dst := zone.stack[dstIdx]
  src := zone.stack[srcIdx]

  for i, win in src.windows {
    zone.groups[win.title] = dst
    dst.windows = append(dst.windows, win)
  }

  zone.stack = delete(zone.stack, srcIdx)

  groupZoneReassignIndices(zone)
}

fn groupZoneLocateActiveGroup(zone: ^GroupZone, at: th.Vf2): ^Group {
  var group: ^Group = null
  for i in zone.stack {
    if rectInPoint(zone.stack[i].rect, at) {
      group = zone.stack[i]
    }
  }
  return group
}

fn groupZoneBegin(zone: ^GroupZone, title: str, r: rect.Rect): bool {
  acquired := groupZoneAcquire(zone, title, r)
  zone.currentGroup = acquired
  zone.currentWindow = title

  return groupFindWindow(acquired, title) != null
} 

fn groupZoneEnd(zone: ^GroupZone): bool {
  if zone.currentGroup != null {
    zone.currentWindow = ""
    zone.currentGroup = null
    return true
  }
  return false
}

fn groupZoneUpdate(zone: ^GroupZone) {
  if zone.dockGroups {
    groupZoneDockGroups(zone,
      zone.currentActiveGroup.index,
      zone.currentDockingCandidate.index)
    zone.dockGroups = false
  }
  if zone.currentDraggingGroup == null {
    zone.currentDockingCandidate = null
  } else {
    groupZoneMoveToFront(zone, zone.currentDraggingGroup.index)
  }
  zone.currentActiveGroup = zone.currentActiveCandidateGroup
  zone.currentActiveCandidateGroup = null
}

fn groupZoneReportInput(zone: ^GroupZone, overTab: str, overBody: bool, overTitlebar: bool, isPressed: bool, mouseDelta: th.Vf2) {
  overWindow := overTab != "" || overTitlebar  || overBody

  if overTitlebar && zone.currentDraggingGroup != null && zone.currentGroup != zone.currentActiveGroup {
    zone.currentDockingCandidate = zone.currentGroup
  }

  if overWindow {
    if zone.currentActiveCandidateGroup != null {
      // Check overlap
      if zone.currentActiveCandidateGroup.index < zone.currentGroup.index {
        zone.currentActiveCandidateGroup = zone.currentGroup
      }
    } else {
      zone.currentActiveCandidateGroup = zone.currentGroup
    }
  }

  if zone.currentActiveGroup == zone.currentGroup {
    if !isPressed {
      zone.dockGroups = !isPressed && zone.currentDockingCandidate != null
      zone.currentDraggingGroup = null
    }

    canDrag := (overTitlebar || overBody) && isPressed
    if canDrag {
      if zone.currentDraggingGroup == null {
        zone.currentDraggingGroup = zone.currentGroup
      }

      zone.currentDraggingGroup.rect.x += mouseDelta.x
      zone.currentDraggingGroup.rect.y += mouseDelta.y
    }
  }
}


///////////////////////
// UI
fn uiInit(drawCtx: ^DrawCtx): UiState {
  return UiState{elements: make([]rect.Rect, 0), layouts: make([]UiLayout, 0), drawCtx: drawCtx};
}

fn uiPutCommand(ui: ^UiState, command: DrawCommand) {
  ui.drawCtx.putCommand(ui.groupIndex, command)
}

fn uiBegin(ui: ^UiState, inputState: InputState) {
  // (1) Not really necessary, but good for debugging so you can immediately spot something's wrong
  ui.groupIndex = -1 // (1)

  if ui.isCropped {
    error("ui is still cropped (have you called uiEnd?)\n")
  }

  if len(ui.layouts) > 0 {
    error("unfinished ui layouts\n")
  }

  ui.inputState = inputState
}

fn uiEnd(ui: ^UiState) {
  if ui.isCropped {
    uiPutCommand(ui, commandEndScissorRect())
    ui.isCropped = false
  }
}

fn uiBeginGroup(ui: ^UiState, zIndex: int) {
  if ui.isCropped {
    uiPutCommand(ui, commandEndScissorRect())
    ui.isCropped = false
  }

  ui.groupIndex = zIndex
}

fn uiLayoutTypeName(t: UiLayoutType): str {
  switch t {
    case uiLayoutTypeColumn: return "column"
    case uiLayoutTypeFixedRow: return "fixed row"
    case uiLayoutTypeDynamicRow: return "dynamic row"
    case uiLayoutTypeScreen: return "screen"
  }
  return "unknown layout"
}

fn uiCurrentLayout(ui: ^UiState): ^UiLayout {
  if len(ui.layouts) > 0 {
    return &ui.layouts[len(ui.layouts)-1]
  }
  return null
}

fn uiCurrentElement(ui: ^UiState): rect.Rect {
  if len(ui.elements) > 0 {
    return ui.elements[len(ui.elements)-1]
  }
  error("Element stack is empty")
  return rect.Rect{}
}

// Adds an element into the UI and advances the layout.
fn uiPushElement(ui: ^UiState, size: th.Vf2, margin: real = 0): rect.Rect {
  currentLayout := uiCurrentLayout(ui) 
  if currentLayout == null {
    ui.elements = append(ui.elements, rect.mk(margin, margin, size.x-margin*2, size.y-margin*2))

    return rect.mk(margin, margin, size.x-margin*2, size.y-margin*2)
  }
  baseRect := currentLayout.bounds

  // (1) NOTE: for now here the positions are relative to the base rect 
  resultRect := rect.mk(currentLayout.position.x, currentLayout.position.y, size.x, size.y)

  switch currentLayout.layoutType {
    case uiLayoutTypeColumn:
      resultRect.w = baseRect.w

      currentLayout.position.y += resultRect.h
    case uiLayoutTypeFixedRow:
      elementsPerRow := real(currentLayout.elementsPerRow)
      if elementsPerRow <= 0 {
        elementsPerRow = 1
      }

      resultRect.w = baseRect.w / elementsPerRow;
      
      if (resultRect.x+resultRect.w-1) > baseRect.w { // wrap around
        resultRect.x = 0
        resultRect.y += currentLayout.rowHeight
        currentLayout.position.y += currentLayout.rowHeight
        currentLayout.position.x = 0
        currentLayout.rowHeight = 0
      }

      if resultRect.h > currentLayout.rowHeight {
        currentLayout.rowHeight = resultRect.h
      }

      currentLayout.position.x += baseRect.w / elementsPerRow
    case uiLayoutTypeDynamicRow:
      if (resultRect.x+resultRect.w) > baseRect.w { // wrap around
        resultRect.x = 0
        resultRect.y += currentLayout.rowHeight
        currentLayout.position.y += currentLayout.rowHeight
        currentLayout.position.x = 0
        currentLayout.rowHeight = 0
      }

      if resultRect.h > currentLayout.rowHeight {
        currentLayout.rowHeight = resultRect.h
      }

      currentLayout.position.x += resultRect.w
    case uiLayoutTypeScreen:

  }

  // (1) ... Then they are transformed to the absolute position.
  resultRect.x += baseRect.x+currentLayout.scroll.x+margin
  resultRect.y += baseRect.y+currentLayout.scroll.y+margin

  resultRect.w -= margin*2
  resultRect.h -= margin*2

  ui.elements = append(ui.elements, resultRect)

  return resultRect
}

fn uiPopElement(ui: ^UiState) {
  if len(ui.elements) > 0 {
    ui.elements = delete(ui.elements, len(ui.elements)-1)
    return
  }

  error("Element stack is empty")
}

fn uiPutElement(ui: ^UiState, size: th.Vf2): rect.Rect {
  r := uiPushElement(ui, size)
  uiPopElement(ui)
  return r
}

fn uiGetBounds(ui: ^UiState): rect.Rect {
  return uiCurrentElement(ui)
}

fn uiGetContentSize(ui: ^UiState): th.Vf2 {
  currentLayout := uiCurrentLayout(ui)
  return currentLayout.position.add(th.Vf2{0, currentLayout.rowHeight})
}

fn uiGetRemainingSize(ui: ^UiState): th.Vf2 {
  bounds := uiCurrentElement(ui).getDims()
  offs := uiGetContentSize(ui).y
  bounds.y -= offs
  return bounds
}

fn uiGetButtonState(ui: ^UiState): ButtonState {
  buttonState := ButtonState{}
  buttonState.over = rectInPoint(uiGetBounds(ui), ui.inputState.mousePos)
  buttonState.down = ui.inputState.mouseLeft.down && buttonState.over;
  buttonState.pressed = ui.inputState.mouseLeft.pressed && buttonState.over;
  buttonState.released = ui.inputState.mouseLeft.released && buttonState.over;
  return buttonState
}

//
// Crops the contents of the base rectangle
// 
// ui: ui state
//
fn uiCropContents(ui: ^UiState) {
  ui.isCropped = true
  uiPutCommand(ui, commandBeginScissorRect(uiGetBounds(ui)))
}

//
// Scrolls the current layout
//
// ui: ui state
// offset: x/y scroll offset
//
fn uiSetScroll(ui: ^UiState, offset: th.Vf2) {
  currentLayout := uiCurrentLayout(ui)
  currentLayout.scroll.x += offset.x
  currentLayout.scroll.y += offset.y
}

fn uiEndLayout(ui: ^UiState, expectedType: UiLayoutType) {
  currentLayout := uiCurrentLayout(ui)
  currentType := currentLayout.layoutType

  if currentType != expectedType {
    buf := str(make([]char, 256))
    sprintf(buf, "(UI) Layout type mismatch: started with %s but ended with %s", uiLayoutTypeName(currentType), uiLayoutTypeName(expectedType))
    error(buf)
  } else {
    ui.layouts = delete(ui.layouts, len(ui.layouts)-1)
    if currentLayout.layoutType != uiLayoutTypeScreen && len(ui.layouts) > 0 {
      ui.layouts[len(ui.layouts)-1].position.y = currentLayout.position.y+currentLayout.rowHeight
      ui.layouts[len(ui.layouts)-1].position.x = 0
    }
  }
}

fn uiBeginLayout(ui: ^UiState, layoutType: UiLayoutType, elementsPerRow: int = 0) {
  currentLayout := uiCurrentLayout(ui)
  newLayout := UiLayout{layoutType: layoutType, elementsPerRow: elementsPerRow, bounds: uiCurrentElement(ui)}

  if currentLayout != null {
    newLayout.scroll = currentLayout.scroll

    // FIXME: This is a way to identify if newLayout and currentLayout share the element
    if currentLayout.bounds.x == newLayout.bounds.x && currentLayout.bounds.y == newLayout.bounds.y && currentLayout.bounds.w == newLayout.bounds.w && currentLayout.bounds.h == newLayout.bounds.h {
      newLayout.position.y = currentLayout.position.y
      newLayout.position.x = 0
    }
   // newLayout.position = currentLayout.position.add(currentLayout.bounds.getPos()).sub(newLayout.bounds.getPos())
  }

  ui.layouts = append(ui.layouts, newLayout)
}


fn uiSetCursor(ui: ^UiState, to: th.Vf2) {
  uiCurrentLayout(ui).position = to
}

// Begins a column layout.
// It becomes full width to the parent rectangle and moves on to next row.
fn uiBeginColumn(ui: ^UiState) {
  uiBeginLayout(ui, uiLayoutTypeColumn)
}

fn uiEndColumn(ui: ^UiState) {
  uiEndLayout(ui, uiLayoutTypeColumn)
}

// Begins a dynamic row layout.
// It uses its provided size and wraps around if needed.
fn uiBeginDynamicRow(ui: ^UiState) {
  uiBeginLayout(ui, uiLayoutTypeDynamicRow)
}

fn uiEndDynamicRow(ui: ^UiState) {
  uiEndLayout(ui, uiLayoutTypeDynamicRow)
}

// Begins a fixed row layout.
// It assigns element width to parent width divided by element per row, and wraps around if needed.
fn uiBeginFixedRow(ui: ^UiState, elementsPerRow: int) {
  uiBeginLayout(ui, uiLayoutTypeFixedRow, elementsPerRow)
}

fn uiEndFixedRow(ui: ^UiState) {
  uiEndLayout(ui, uiLayoutTypeFixedRow)
}

var (
  v_font: d_font.Font
  v_drawCtx: DrawCtx
  
  v_groupZone: GroupZone
  v_uiState: UiState

  v_dbgMask: uint32 // mask for debug ui
  v_inputState: InputState
)

///////////////////////
// UI (Interface)

// Begins a column layout.
// It becomes full width to the parent rectangle and moves on to next row.
fn beginColumn*() {
  uiBeginColumn(&v_uiState)
}

fn endColumn*() {
  uiEndColumn(&v_uiState)
}

// Begins a dynamic row layout.
// It uses its provided size and wraps around if needed.
fn beginDynamicRow*() {
  uiBeginDynamicRow(&v_uiState)
}

fn endDynamicRow*() {
  uiEndDynamicRow(&v_uiState)
}

// Begins a fixed row layout.
// It assigns element width to parent width divided by element per row, and wraps around if needed.
fn beginFixedRow*(elementsPerRow: int) {
  uiBeginFixedRow(&v_uiState, elementsPerRow)
}

fn endFixedRow*() {
  uiEndFixedRow(&v_uiState)
}

fn init*(font: d_font.Font) {
  v_font = font
  v_groupZone = groupZoneInit()
  v_drawCtx = drawCtxInit()
  v_uiState = uiInit(&v_drawCtx)
}

fn populateMouseButton(previous: ButtonState, button: char): ButtonState {
  return ButtonState{
    down: input.isPressed(button),
    pressed: input.isJustPressed(button),
    released: previous.down && !input.isPressed(button)}
}

fn populateInputState(previous: InputState): InputState {
  // FIXME: This looks stupid, but this is to prevent NaN's from happening, since NaN != NaN
  if input.getMousePos().x != input.getMousePos().x {
    return previous
  }

  var output: InputState

  output.mouseLeft = populateMouseButton(previous.mouseLeft, input.mouse1);
  output.mouseMiddle = populateMouseButton(previous.mouseMiddle, input.mouse2);
  output.mouseRight = populateMouseButton(previous.mouseRight, input.mouse3);

  output.mousePos = previous.mousePos.add(previous.mouseDelta)
  output.mouseDelta = input.getMousePos().sub(output.mousePos)
  output.mouseScroll = int(input.isJustPressed(input.mouse_up)) - int(input.isJustPressed(input.mouse_down));

  return output
}

fn dbgPrintText(lay: ^SequenceLayout, label: str, color: uint32) {
  size := v_font.measure(label)
  r := rect.mk(lay.end.x, lay.end.y, size.x, size.y)

  v_drawCtx.putCommand(99, commandText(color & v_dbgMask, r, label))
  lay.put(v_font.measure(label))
}

fn dbgPrintSect(lay: ^SequenceLayout, label: str) {
  dbgPrintText(lay, label, th.white)
  startX := lay.end.x 
  lay.padding(100)
  endX := lay.end.x
  y := lay.end.y + v_font.height/2;

  v_drawCtx.putCommand(99, commandRect(0xFFFFFF11 & v_dbgMask, rect.mk(startX, y, endX-startX, 1)))
}

fn dbgPrintBool(lay: ^SequenceLayout, label: str, value: bool) {
  dbgPrintText(lay, label, [2]uint32{th.white & 0xFFFFFF99, th.green}[int(value)])
}

fn dbgPrintButtonState(lay: ^SequenceLayout, label: str, state: ButtonState) {
  dbgPrintSect(lay, label);

  dbgPrintBool(lay, "down ", state.down)
  dbgPrintBool(lay, "pressed ", state.pressed)
  dbgPrintBool(lay, "released", state.released)

  lay.newLine()
}

fn dbgPrintInputState(lay: ^SequenceLayout, state: InputState) {
  dbgPrintButtonState(lay, "MouseLeft", state.mouseLeft);
  dbgPrintButtonState(lay, "MouseMiddle", state.mouseMiddle);
  dbgPrintButtonState(lay, "MouseRight", state.mouseRight);

  dbgPrintSect(lay, "MouseDelta");
  dbgPrintText(lay, "x"+std.ftoa(state.mouseDelta.x, 0), th.white & 0xFFFFFF99)
  lay.padding(150)
  dbgPrintText(lay, "y"+std.ftoa(state.mouseDelta.y, 0), th.white & 0xFFFFFF99)
  lay.newLine()

  dbgPrintSect(lay, "MousePos");
  dbgPrintText(lay, "x"+std.ftoa(state.mousePos.x, 0), th.white & 0xFFFFFF99)
  lay.padding(150)
  dbgPrintText(lay, "y"+std.ftoa(state.mousePos.y, 0), th.white & 0xFFFFFF99)
  lay.newLine()

  dbgPrintSect(lay, "MouseScroll");
  dbgPrintText(lay, std.itoa(state.mouseScroll), th.white & 0xFFFFFF99)
  lay.newLine()
}

fn dbgPrintGroup(lay: ^SequenceLayout, label: str, group: ^Group) {
  dbgPrintSect(lay, label);
  if group != null {
    dbgPrintText(lay, std.itoa(group.index), th.white & 0xFFFFFF99)
  } else {
    dbgPrintText(lay, "null", th.white & 0xFFFFFF99)
  }
  lay.newLine()
}

fn dbgMain(pos: th.Vf2) {
  lay := sequenceLayoutInit(pos)
  dbgPrintSect(&lay, "FPS")
  dbgPrintText(&lay, std.itoa(round(d_fps.getFps())), th.white & 0xFFFFFF99)
  lay.newLine()

  dbgPrintInputState(&lay, v_inputState)
  // TODO: uncomment
  dbgPrintGroup(&lay, "DraggingGroup", v_groupZone.currentDraggingGroup)
  dbgPrintGroup(&lay, "ActiveGroup", v_groupZone.currentActiveGroup)
  dbgPrintGroup(&lay, "DockingGroup", v_groupZone.currentDockingCandidate)
  /*
  dbgPrintSect(&lay, "WindowScroll")
  if v_groupZone.activeGroup != null {
    dbgPrintText(&lay, repr(groupGetCurrentWindow(v_groupZone.activeGroup).scroll.targetScroll), th.white & 0xFFFFFF99)
  }
  lay.newLine()
  dbgPrintSect(&lay, "UndockWindow")
  dbgPrintText(&lay, v_groupZone.undockingWindow, th.white & 0xFFFFFF99)
  lay.newLine()
  */



  // make lighter on hover
  if (rectInPoint(lay.getRect(), v_inputState.mousePos)) {
    v_dbgMask = 0xFFFFFF55
    v_drawCtx.putCommand(98, commandRect(th.black&0x11, rectInset(lay.getRect(), -5)))
  } else {
    v_dbgMask = 0xFFFFFFFF
    v_drawCtx.putCommand(98, commandRect(th.black&0xBB, rectInset(lay.getRect(), -5)))
  }
}

fn handleGroups() {
  for _, group in v_groupZone.groups {
    for i in group.windows {
      scrollUpdate(&group.windows[i].scroll)
    }
    scrollUpdate(&group.tabScroll)
  }
}

fn begin*() {
  d_fps.update()
  v_inputState = populateInputState(v_inputState);
  handleGroups()
  groupZoneSetJoin(&v_groupZone, false)
  dbgMain(th.Vf2{10, 10});
  uiBegin(&v_uiState, v_inputState)
}

fn endWindow();

fn end*() {
  for title, group in v_groupZone.groups {
    win := groupFindWindow(group, title)
    if win.visibilityStatus > 0 {
      win.visibilityStatus -= 1
    } 
  }

  if groupZoneEnd(&v_groupZone) {
    endWindow()
  }

  uiEnd(&v_uiState)
  groupZoneUpdate(&v_groupZone)

  v_drawCtx.render(v_font)
  v_drawCtx.clear()
}

fn setJoinWindows*(set: bool) {
  groupZoneSetJoin(&v_groupZone, set)
}

fn getButtonState(): ButtonState {
  buttonState := uiGetButtonState(&v_uiState)
  return buttonState
}

fn _putLabel(text: str) {
  size := v_font.measure(text) 
  size.x += 10 // padding
  size.y += 5

  labelRect := uiPutElement(&v_uiState, size)
  labelRect.w -= 1
  labelRect.h -= 1

  uiPutCommand(&v_uiState, commandText(c_fore, labelRect, text))
}

fn _putImage(img: image.Image, size: th.Vf2 = th.Vf2{0, 0}) {
  if size.x == 0 && size.y == 0 {
    size = img.getDims()
  }
  place := uiPutElement(&v_uiState, size)

  uiPutCommand(&v_uiState, commandImage(place, img))
}

fn drawButtonUi(r: rect.Rect, state: ButtonState) {
  color := c_item
  if state.over {
    color = c_over
  }
  if state.down {
    color = c_held
  }
  uiPutCommand(&v_uiState, commandRect(color, r))
}

fn _putButton(text: str): ButtonState {
  size := v_font.measure(text) 
  size.x += 10 // padding
  size.y += 5


  uiPushElement(&v_uiState, size)
    buttonState := getButtonState()
    buttonRect := uiGetBounds(&v_uiState)
    buttonRect.w -= 1
    buttonRect.h -= 1
    drawButtonUi(buttonRect, buttonState)
    uiPutCommand(&v_uiState, commandText(c_body, buttonRect, text))
  uiPopElement(&v_uiState)

  return buttonState
}     

fn beginWindow*(title: str, r: rect.Rect): bool;

fn endWindow() {
  // (beginWindow 1)
              uiEndColumn(&v_uiState)
            uiPopElement(&v_uiState)
          uiEndColumn(&v_uiState)
        uiPopElement(&v_uiState)
      uiPopElement(&v_uiState)
    uiEndLayout(&v_uiState, uiLayoutTypeScreen)
  uiPopElement(&v_uiState)
}

fn beginWindow*(title: str, r: rect.Rect): bool {
  if groupZoneEnd(&v_groupZone) {
    endWindow()
  }

  began := groupZoneBegin(&v_groupZone, title, r)

  overTab := ""
  overBody := false
  overTitlebar := false
  isPressed := v_inputState.mouseLeft.down
  mouseDelta := v_inputState.mouseDelta

  if began {
    group := v_groupZone.currentGroup
    uiBeginGroup(&v_uiState, group.index)

    uiPushElement(&v_uiState, th.Vf2{window.w, window.h})
      uiBeginLayout(&v_uiState, uiLayoutTypeScreen)
        uiSetCursor(&v_uiState, group.rect.getPos())
        uiPushElement(&v_uiState, group.rect.getDims())
          uiPutCommand(&v_uiState, commandRect(c_decor, uiGetBounds(&v_uiState)))
          uiPushElement(&v_uiState, uiGetBounds(&v_uiState).getDims(), 1)
            uiBeginColumn(&v_uiState)
              uiCropContents(&v_uiState)

              // Titlebar
              uiPushElement(&v_uiState, th.Vf2{uiGetBounds(&v_uiState).w, v_font.height+5})
                if uiGetButtonState(&v_uiState).over {
                  overTitlebar = true
                }
                uiBeginDynamicRow(&v_uiState)
                  _putButton("||||")
                  for i, w in group.windows {
                    if _putButton(w.title).over {
                      overTab = w.title
                    }
                  }
                uiEndDynamicRow(&v_uiState)
              uiPopElement(&v_uiState)
              uiPushElement(&v_uiState, uiGetRemainingSize(&v_uiState))
                if uiGetButtonState(&v_uiState).over {
                  overBody = true
                }
                uiPutCommand(&v_uiState, commandRect(c_body, uiGetBounds(&v_uiState)))
                uiBeginColumn(&v_uiState)

     //       scrollLimit(&getLastWindow().scroll, -(uiGetContentSize(&v_uiState).y-uiGetBounds(&v_uiState).h))
    // (beginWindow 1)
  }

  if overTab != "" {
    overTitlebar = false
  }
  groupZoneReportInput(&v_groupZone, overTab, overBody, overTitlebar, isPressed, mouseDelta)

  return began
}

fn putImage*(img: image.Image, size: th.Vf2 = th.Vf2{0, 0}) {
  _putImage(img, size)
}

fn putButton*(text: str): ButtonState {
  return _putButton(text)
}

fn putLabel*(text: str) {
  _putLabel(text)
}


// DRAGGING
// 1. Check if left mouse button is down
// 2. Iterate through windows
// 3. Check if we intersect with the window
// 4. Initiate window dragging
// 5. Drag the dragged window by specified mouse delta in following frames
//
// JOINING TABS
// 1. Iterate through windows
// 2. Check if mouse is above another window's titlebar
// 3. Attach to that another window
//
// SPLITTING TABS
// 1. Iterate through windows
// 2. Check if mouse is pressed on any certain tab
// 3. Save it as a held tab
// 4. When held tab goes out of titlebar, move it to a new group
