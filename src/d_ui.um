import (
        "std.um"
        "th.um"; "rect.um"; "canvas.um"; "input.um"; "window.um"
        "d_font.um"; "d_util.um"; 
)

type (
        Window = struct {
                title: str
                rect: rect.Rect
        }

        Group = struct {
                index: int
                windows: []Window
                current: uint
                rect: rect.Rect
                tabWidth: real //width of tabs total
                tabScroll: real //horizontal scroll offset 
                scrolling: bool
        }

        Cutting = int

        GroupHoverInfo = int

        VisibleTab = struct {
                title: str
                ghost: bool
        }

        GroupZone = struct {
                groups: map[str]^Group // Window name to group
                stack: []^Group 
                join: bool
                firstJoin: bool
        }

        InputState = struct {
                nudged: bool
                held: bool
                relased: bool
        }

        DrawCommand = struct {
                color: uint32
                rect: rect.Rect
                text: str
        }

        DrawLayer = struct {
                commands: []DrawCommand
                index: int // Layer ordering for sorting
        }

        DrawCtx = struct {
                layers: []DrawLayer 
        }

        Layout = struct {
                index: int
                rect: rect.Rect
                cutter: Cutting
                ctx: ^DrawCtx
        }
)

const (
        cuttingLeft = Cutting(0)
        cuttingRight = Cutting(1)
        cuttingTop = Cutting(2)
        cuttingBottom = Cutting(3)
)

fn layerFromCommand(index: int, cmd: DrawCommand): DrawLayer {
        return DrawLayer{index: index, commands: []DrawCommand{cmd}}
}

fn drawCtxInit(): DrawCtx {
        return DrawCtx{layers: []DrawLayer{}}
}

fn commandRect(color: uint32, r: rect.Rect): DrawCommand {
        return DrawCommand{color: color, rect: r, text: ""}
}

fn commandText(color: uint32, r: rect.Rect, t: str): DrawCommand {
        return DrawCommand{color: color, rect: r, text: t}
}

fn (lay: ^DrawLayer) putCommand(cmd: DrawCommand) {
        lay.commands = append(lay.commands, cmd);
}

fn (ctx: ^DrawCtx) clear() {
        ctx.layers = []DrawLayer{}
}

fn (ctx: ^DrawCtx) putCommand(index: int, cmd: DrawCommand) {
        pushIndex := 0

        for i in ctx.layers {
                if ctx.layers[i].index > index {
                        break
                }
                if ctx.layers[i].index == index { // found exact layer
                        ctx.layers[i].putCommand(cmd)
                        return
                }
                pushIndex += 1
        }

        if pushIndex == len(ctx.layers) {
                ctx.layers = append(ctx.layers, layerFromCommand(index, cmd))
        } else {
                newLayers := make([]DrawLayer, 0)
                for i in ctx.layers {
                        if i == pushIndex {
                                newLayers = append(newLayers, layerFromCommand(index, cmd))
                        }
                        newLayers = append(newLayers, ctx.layers[i])
                }
                ctx.layers = newLayers
        }
}

fn (ctx: ^DrawCtx) render(font: d_font.Font) {
        for i in ctx.layers {
                layer := &ctx.layers[i]
                for j, cmd in layer.commands {
                        if cmd.text != "" { // draw text
                                size := font.measure(cmd.text)
                                font.draw(cmd.text, th.Vf2{cmd.rect.x+(cmd.rect.w-size.x)/2, cmd.rect.y+(cmd.rect.h-size.y)/2}, cmd.color)
                        } else { // draw rect
                                canvas.drawRect(cmd.color, cmd.rect)
                        }
                }
        }
}

///////////////////////
// Utility
fn rectInPoint(r: rect.Rect, p: th.Vf2): bool {
        return p.x > r.x && p.y > r.y && p.x < (r.x + r.w) && p.y < (r.y + r.h)
}

fn rectInset(r: rect.Rect, by: real): rect.Rect {
        return rect.mk(r.x+by, r.y+by, r.w-by*2, r.h-by*2)
}

fn rectMove(r: rect.Rect, by: th.Vf2): rect.Rect {
        return rect.Rect{r.x+by.x, r.y+by.y, r.w, r.h}
}

///////////////////////
// Cutting
fn cuttingCut(c: Cutting, r: ^rect.Rect, req: th.Vf2): rect.Rect {
        result := rect.Rect{-1e7, -1e7, 0, 0}
        switch c {
        case cuttingLeft:
                result = rect.mk(r.x, r.y, req.x, r.h)
                r.x += req.x;
                r.w -= req.x;
        case cuttingRight:
                result = rect.mk(r.x+r.w-req.x, r.y, req.x, r.h)
                r.w -= req.x;
        case cuttingTop:
                result = rect.mk(r.x, r.y, r.w, req.y)
                r.y += req.y;
                r.h -= req.y;
        case cuttingBottom:
                result = rect.mk(r.x, r.y+r.h-req.y, r.w, req.y)
                r.h -= req.y;
        }
        return result

}

///////////////////////
// Group
fn groupCreateFromWindow(win: Window): Group {
        windows := make([]Window, 1)
        windows[0] = win
        return Group{windows: windows, current: 0, rect: win.rect}
}

fn groupAppendWindow(group: ^Group, win: Window) {
        group.windows = append(group.windows, win) 
}

fn groupCreateFromScratch(r: rect.Rect): Group {
        return Group{windows: make([]Window, 0), current: 0, rect: r}
}

fn groupGetWindowIndexByName(group: ^Group, name: str): int {
        for windowIndex, win in group.windows {
                if win.title == name {
                        return windowIndex
                }
        }
        return -1
}

///////////////////////
// Group Zone
fn groupZoneInit(): GroupZone {
        return GroupZone{groups: map[str]^Group{}, stack: make([]^Group, 0)}
}

fn groupZoneAcquire(zone: ^GroupZone, title: str, r: rect.Rect): ^Group {
        group := zone.groups[title]

        if group == null {
                if len(zone.stack) > 0 && zone.join && !zone.firstJoin {
                        zone.groups[title] = zone.stack[len(zone.stack)-1]
                        group = zone.groups[title]
                        groupAppendWindow(zone.stack[len(zone.stack)-1], Window{title: title, rect: r})
                } else {
                        newGroup := new(Group)
                        newGroup ^= groupCreateFromWindow(Window{title: title, rect: r})
                        zone.groups[title] = newGroup
                        group = zone.groups[title]
                        zone.firstJoin = false
                        newGroup.index = len(zone.stack)
                        zone.stack = append(zone.stack, newGroup)
                }
        }
        
        return group
}

fn groupZoneMoveToFront(zone: ^GroupZone, groupIndex: int): int {
        group := zone.stack[groupIndex]
        zone.stack = delete(zone.stack, groupIndex)
        zone.stack = append(zone.stack, group)

        for i in zone.stack { // reassign correct window indices
                zone.stack[i].index = i
        }

        return group.index
}

fn groupZoneSetJoin(zone: ^GroupZone, set: bool) {
        zone.join = set
        zone.firstJoin = true
}

fn groupZoneDockGroups(zone: ^GroupZone, srcIdx: int, dstIdx: int) {
        dst := zone.stack[dstIdx]
        src := zone.stack[srcIdx]

        for i, win in src.windows {
                zone.groups[win.title] = dst
                dst.windows = append(dst.windows, win)
        }

        zone.stack = delete(zone.stack, srcIdx)
}

///////////////////////
// Layout
fn layoutInit(ctx: ^DrawCtx, index: int, cutter: Cutting = cuttingLeft, r: rect.Rect = rect.Rect{0, 0, 0, 0}): Layout {
        return Layout{ctx: ctx, cutter: cutter, rect: r, index: index}
}

fn (lay: ^Layout) getRect(reqSize: th.Vf2): rect.Rect {
        return cuttingCut(lay.cutter, &lay.rect, reqSize)
}

fn (lay: ^Layout) putCommand(cmd: DrawCommand) {
        lay.ctx.putCommand(lay.index, cmd)
}


const (
        c_shadow = 0x00000022
        c_decor = 0xAA5555FF
        c_item = 0x993333FF
        c_body = th.white

        groupHoverInfoNone = GroupHoverInfo(0)
        groupHoverInfoOnBody = GroupHoverInfo(1)
        groupHoverInfoOnTitlebar = GroupHoverInfo(2)
)

var (
        v_font: d_font.Font
        v_drawCtx: DrawCtx
        
        v_groupZone: GroupZone
        v_lastGroup: ^Group
        v_lastWindow: str

        v_mousePos: th.Vf2
        v_mouseDelta: th.Vf2
        v_mouseMiddleDown: bool
        v_mouseMiddleNudged: bool
        v_mouseMiddleScroll: int
        v_mouseLeftDown: bool
        v_mouseLeftNudged: bool
        v_mouseLeftReleased: bool
)


///////////////////////
// UI
fn init*(font: d_font.Font) {
        v_font = font
        v_groupZone = groupZoneInit()
        v_drawCtx = drawCtxInit()
}

fn begin*() {
        newMousePos := input.getMousePos()
        v_mouseDelta = newMousePos.sub(v_mousePos)
        v_mousePos = newMousePos

        v_mouseMiddleDown = input.isPressed(input.mouse2)
        v_mouseMiddleNudged = input.isJustPressed(input.mouse2)
        v_mouseMiddleScroll = int(input.isJustPressed(input.mouse_up)) - int(input.isJustPressed(input.mouse_down));

        v_mouseLeftReleased = v_mouseLeftDown && !input.isPressed(input.mouse1)
        v_mouseLeftDown = input.isPressed(input.mouse1)
        v_mouseLeftNudged = input.isJustPressed(input.mouse1)

        groupZoneSetJoin(&v_groupZone, false)
}

fn getWindowDecorationRectFromRect(r: rect.Rect): rect.Rect {
        return rect.mk(r.x, r.y, r.w, v_font.height + 4)
}

fn getWindowContentRectFromRect(r: rect.Rect): rect.Rect {
        deco := getWindowDecorationRectFromRect(r)
        r.y += deco.h
        r.h -= deco.h
        return rectInset(r, 1)
}

fn end*() {
        v_drawCtx.render(v_font)
        v_drawCtx.clear()
}

fn setJoinWindows*(set: bool) {
        groupZoneSetJoin(&v_groupZone, set)
}

fn isLastWindowVisible(): bool {
        if (v_lastGroup == null) {
                return false
        }

        if (v_lastWindow != v_lastGroup.windows[v_lastGroup.current].title) {
                return false
        }  

        return true
}

fn getLastWindowContentRect(): rect.Rect {
        if isLastWindowVisible() {
                return getWindowContentRectFromRect(v_lastGroup.rect);
        }

        error("Last window wasn't visible");
        return rect.mk(0, 0, 0, 0)
}

fn _putButton(lay: ^Layout, text: str) {
        size := v_font.measure(text) 
        size.x += 10 // padding
        buttonRect := lay.getRect(size)
        lay.putCommand(commandRect(c_item, buttonRect))
        lay.putCommand(commandText(c_body, buttonRect, text))
        lay.getRect(th.Vf2{1, 1}) // padding
}

fn drawGroup(ctx: ^DrawCtx, group: ^Group) {

        windowRect := group.rect
        contentRect := getWindowContentRectFromRect(group.rect)
        titlebarRect := getWindowDecorationRectFromRect(group.rect)

        lay := layoutInit(ctx, group.index)

        lay.putCommand(commandRect(c_shadow, rectMove(rectInset(windowRect, -1), th.Vf2{0, 1})))
        lay.putCommand(commandRect(c_decor, windowRect))
        lay.putCommand(commandRect(c_body, contentRect))

        lay.rect = titlebarRect

        for i, w in group.windows {
                _putButton(&lay, w.title)
        }
}

fn beginWindow*(title: str, r: rect.Rect) {
        v_lastWindow = title
        v_lastGroup = groupZoneAcquire(&v_groupZone, title, r)

        // Prevent drawing the group multiple times by checking if
        // the current window is the one displayed in the group.
        if isLastWindowVisible() {
                drawGroup(&v_drawCtx, v_lastGroup);
        }
}

fn putButton*(text: str) {
        if isLastWindowVisible() {
                _putButton(&layoutInit(&v_drawCtx, v_lastGroup.index, cuttingTop, getLastWindowContentRect()), text)
        }
}

// DRAGGING
// 1. Check if left mouse button is down
// 2. Iterate through windows
// 3. Check if we intersect with the window
// 4. Initiate window dragging
// 5. Drag the dragged window by specified mouse delta in following frames
//
// JOINING TABS
// 1. Iterate through windows
// 2. Check if mouse is above another window's titlebar
// 3. Attach to that another window
//
// SPLITTING TABS
// 1. Iterate through windows
// 2. Check if mouse is pressed on any certain tab
// 3. Save it as a held tab
// 4. When held tab goes out of titlebar, move it to a new group
