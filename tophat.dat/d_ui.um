import (
        "map.um"
        "th.um"; "rect.um"; "canvas.um"; "input.um"
        "d_font.um"; "d_util.um"
)

type (
        Window = struct {
                title: str
                rect: rect.Rect
        }

        Group = struct {
                windows: []Window
                current: uint
                rect: rect.Rect
        }
        
        GroupHoverInfo = int

        GroupZone = struct {
                map: map.Map
                stack: []^Group 
                join: bool
                firstJoin: bool
        }
)

const (
        groupHoverInfoNone = GroupHoverInfo(0)
        groupHoverInfoOnBody = GroupHoverInfo(1)
        groupHoverInfoOnTitlebar = GroupHoverInfo(2)
)

var (
        v_font: d_font.Font
        
        v_groupZone: GroupZone
        v_groupDraggingIndex: int

        v_mousePos: th.Vf2
        v_mouseDelta: th.Vf2
        v_mouseLeftDown: bool
        v_mouseLeftNudged: bool 
)

///////////////////////
// Utility
fn rectInPoint(r: rect.Rect, p: th.Vf2): bool {
        return p.x > r.x && p.y > r.y && p.x < (r.x + r.w) && p.y < (r.y + r.h)
}

fn rectInset(r: rect.Rect, by: real): rect.Rect {
        return rect.mk(r.x-by, r.y-by, r.w+by*2, r.h+by*2)
}

///////////////////////
// Group
fn groupCreateFromWindow(window: Window): Group {
        windows := make([]Window, 1)
        windows[0] = window
        return Group{windows: windows, current: 0, rect: window.rect}
}

fn groupAppendWindow(group: ^Group, window: Window) {
        group.windows = append(group.windows, window) 
}

fn groupCreateFromScratch(r: rect.Rect): Group {
        return Group{windows: make([]Window, 0), current: 0, rect: r}
}

///////////////////////
// Group Zone
fn groupZoneInit(): GroupZone {
        return GroupZone{stack: make([]^Group, 0)}
}

fn groupZoneAcquire(zone: ^GroupZone, title: str, r: rect.Rect): ^Group {
        group := ^Group(zone.map.get(title))

        if group == null {
                zone.map.set(title, groupCreateFromWindow(Window{title: title, rect: r}))
                group = ^Group(zone.map.get(title))

                if len(zone.stack) > 0 && zone.join && !zone.firstJoin {
                        groupAppendWindow(zone.stack[len(zone.stack)-1], Window{title: title, rect: r})
                } else {
                        zone.firstJoin = false
                        zone.stack = append(zone.stack, group)
                }
        }
        
        return group
}

fn groupZoneSetJoin(zone: ^GroupZone, set: bool) {
        zone.join = set
        zone.firstJoin = true
}

///////////////////////
// UI
fn init*(font: d_font.Font) {
        v_font = font
        v_groupZone = groupZoneInit()
}

fn begin*() {
        newMousePos := input.getMousePos()
        v_mouseDelta = newMousePos.sub(v_mousePos)
        v_mousePos = newMousePos
        v_mouseLeftDown = input.isPressed(input.mouse1)
        v_mouseLeftNudged = input.isJustPressed(input.mouse1)
        groupZoneSetJoin(&v_groupZone, false)
}

fn putButton(pos: ^th.Vf2, text: str, toggled: bool, canHover: bool): bool {
        const padding = th.Vf2{10, 2}
        textSize := v_font.measure(text)
        r := rect.Rect{pos.x, pos.y, textSize.x + padding.x*2, textSize.y + padding.y*2}
        hovered := rectInPoint(r, v_mousePos) && canHover
        pressed := hovered && v_mouseLeftDown
        
        if pressed {
                canvas.drawRect(th.blue | 0xDDDDDD, r)
        } else if toggled {
                canvas.drawRect(th.blue | 0xAAAAAA, r)
        } else if hovered {
                canvas.drawRect(th.blue | 0x999999, r)
        } else {
                canvas.drawRect(th.blue | 0x666666, r)
        }


        v_font.draw(text, pos.add(padding), th.white)

        pos.x += r.w+1

        // TODO(skejeton): Return various input states instead of single boolean
        return hovered && v_mouseLeftDown
}

fn getActiveGroup(): int {
        for i := len(v_groupZone.stack)-1; i >= 0; i-- {
                if rectInPoint(v_groupZone.stack[i].rect, v_mousePos) {
                        return i
                }
        }
        return -1
}

fn getGroupHoverInfo(group: ^Group): GroupHoverInfo {
        r := group.rect 
        titlebarRect := rect.mk(r.x, r.y, r.w, v_font.height + 4)
        
        if rectInPoint(titlebarRect, input.getMousePos()) {
                return groupHoverInfoOnTitlebar
        } else if rectInPoint(r, input.getMousePos()) {
                return groupHoverInfoOnBody
        } 
        return groupHoverInfoNone
}

fn isValidGroupDocking(group_a: ^Group, group_b: ^Group): bool {
        return getGroupHoverInfo(group_a) == groupHoverInfoOnTitlebar && getGroupHoverInfo(group_b) == groupHoverInfoOnTitlebar       
}

fn end*() {
        // Move windows
        if !v_mouseLeftDown {
                v_groupDraggingIndex = -1
        }

        if v_mouseLeftNudged {
                groupIndex := getActiveGroup()
                if groupIndex >= 0 { 
                        group := v_groupZone.stack[groupIndex]
                        v_groupZone.stack = delete(v_groupZone.stack, groupIndex)
                        v_groupZone.stack = append(v_groupZone.stack, group)
                                
                        v_groupDraggingIndex = len(v_groupZone.stack)-1
                }
        }

        // Apply drag
        groupDockingCandidateIndex := -1
        if v_groupDraggingIndex >= 0 {
                group := v_groupZone.stack[v_groupDraggingIndex]

                group.rect.x += v_mouseDelta.x
                group.rect.y += v_mouseDelta.y

                for i := len(v_groupZone.stack)-1; i >= 0; i-- {
                        if i != v_groupDraggingIndex && rectInPoint(v_groupZone.stack[i].rect, v_mousePos) {
                                groupDockingCandidateIndex = i
                                break
                        }
                }
        }

        // Draw windows
        for groupIndex, group in v_groupZone.stack {
                r := group.rect 
                titlebarRect := rect.mk(r.x, r.y, r.w, v_font.height + 4)
                pos := th.Vf2{r.x, r.y}
                newCurrent := group.current

                if v_groupDraggingIndex == groupIndex && groupDockingCandidateIndex >= 0 && isValidGroupDocking(v_groupZone.stack[v_groupDraggingIndex], v_groupZone.stack[groupDockingCandidateIndex]) {
                        canvas.drawRect(th.white&0x77, r)
                } else {
                        canvas.drawRect(th.black, rect.mk(r.x - 1, r.y - 1, r.w + 2, r.h + 2))
                        canvas.drawRect(th.white, rect.mk(r.x    , r.y    , r.w    , r.h    ))
                        canvas.drawRect(th.blue & 0x999999FF, titlebarRect);

                        for i, win in group.windows {
                                if putButton(&pos, win.title, group.current == i, groupIndex == getActiveGroup()) {
                                        // Deny drag (because button press)
                                        v_groupDraggingIndex = -1
                                        newCurrent = i
                                }
                        }
                }

                if v_groupDraggingIndex >= 0 && groupDockingCandidateIndex == groupIndex && isValidGroupDocking(v_groupZone.stack[v_groupDraggingIndex], v_groupZone.stack[groupDockingCandidateIndex]) {
                        group := v_groupZone.stack[v_groupDraggingIndex]

                        for i, win in group.windows {
                                putButton(&pos, win.title, false, false);
                        }
                }

                group.current = newCurrent
        }
}

fn setJoinWindows*(set: bool) {
        groupZoneSetJoin(&v_groupZone, set)
}

fn beginWindow*(title: str, r: rect.Rect) {
        groupZoneAcquire(&v_groupZone, title, r)
}


// DRAGGING
// 1. Check if left mouse button is down
// 2. Iterate through windows
// 3. Check if we intersect with the window
// 4. Initiate window dragging
// 5. Drag the dragged window by specified mouse delta in following frames
//
// JOINING TABS
// 1. Iterate through windows
// 2. Check if mouse is above another window's titlebar
// 3. Attach to that another window
//
// SPLITTING TABS
// 1. Iterate through windows
// 2. Check if mouse is pressed on any certain tab
// 3. Save it as a held tab
// 4. When held tab goes out of titlebar, move it to a new group
