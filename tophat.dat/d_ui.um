import (
        "map.um"
        "th.um"; "rect.um"; "canvas.um"; "input.um"; "window.um"
        "d_font.um"; "d_util.um"; 
)

type (
        Window = struct {
                title: str
                rect: rect.Rect
        }

        Group = struct {
                windows: []Window
                current: uint
                rect: rect.Rect
        }
        
        GroupHoverInfo = int

        GroupZone = struct {
                map: map.Map
                stack: []^Group 
                join: bool
                firstJoin: bool
        }
)

const (
        groupHoverInfoNone = GroupHoverInfo(0)
        groupHoverInfoOnBody = GroupHoverInfo(1)
        groupHoverInfoOnTitlebar = GroupHoverInfo(2)
)

var (
        v_font: d_font.Font
        
        v_groupZone: GroupZone
        v_groupDraggingIndex: int
        v_windowDetachCandidateName: str
        v_groupDockingCandidateIndex: int

        v_mousePos: th.Vf2
        v_mouseDelta: th.Vf2
        v_mouseLeftDown: bool
        v_mouseLeftNudged: bool 
)

///////////////////////
// Utility
fn rectInPoint(r: rect.Rect, p: th.Vf2): bool {
        return p.x > r.x && p.y > r.y && p.x < (r.x + r.w) && p.y < (r.y + r.h)
}

fn rectInset(r: rect.Rect, by: real): rect.Rect {
        return rect.mk(r.x-by, r.y-by, r.w+by*2, r.h+by*2)
}

///////////////////////
// Group
fn groupCreateFromWindow(win: Window): Group {
        windows := make([]Window, 1)
        windows[0] = win
        return Group{windows: windows, current: 0, rect: win.rect}
}

fn groupAppendWindow(group: ^Group, win: Window) {
        group.windows = append(group.windows, win) 
}

fn groupCreateFromScratch(r: rect.Rect): Group {
        return Group{windows: make([]Window, 0), current: 0, rect: r}
}

///////////////////////
// Group Zone
fn groupZoneInit(): GroupZone {
        return GroupZone{stack: make([]^Group, 0)}
}

fn groupZoneAcquire(zone: ^GroupZone, title: str, r: rect.Rect): ^Group {
        group := ^Group(zone.map.get(title))

        if group == null {
                if len(zone.stack) > 0 && zone.join && !zone.firstJoin {
                        zone.map.set(title, zone.stack[len(zone.stack)-1])
                        group = ^Group(zone.map.get(title))
                        groupAppendWindow(zone.stack[len(zone.stack)-1], Window{title: title, rect: r})
                } else {
                        zone.map.set(title, groupCreateFromWindow(Window{title: title, rect: r}))
                        group = ^Group(zone.map.get(title))
                        zone.firstJoin = false
                        zone.stack = append(zone.stack, group)
                }
        }
        
        return group
}

fn groupZoneSetJoin(zone: ^GroupZone, set: bool) {
        zone.join = set
        zone.firstJoin = true
}

fn groupZoneDockGroups(zone: ^GroupZone, srcIdx: int, dstIdx: int) {
        dst := zone.stack[dstIdx]
        src := zone.stack[srcIdx]

        for win in src.windows {
                zone.map.set(win.title, dst)
                dst.windows = append(dst.windows, win)
        }

        zone.stack = delete(zone.stack, srcIdx)
}

///////////////////////
// UI
fn init*(font: d_font.Font) {
        v_font = font
        v_groupZone = groupZoneInit()
}

fn begin*() {
        newMousePos := input.getMousePos()
        v_mouseDelta = newMousePos.sub(v_mousePos)
        v_mousePos = newMousePos
        v_mouseLeftDown = input.isPressed(input.mouse1)
        v_mouseLeftNudged = input.isJustPressed(input.mouse1)
        groupZoneSetJoin(&v_groupZone, false)
}

fn putButton(pos: ^th.Vf2, text: str, toggled: bool, canHover: bool): bool {
        const padding = th.Vf2{10, 2}
        textSize := v_font.measure(text)
        r := rect.Rect{pos.x, pos.y, textSize.x + padding.x*2, textSize.y + padding.y*2}
        hovered := rectInPoint(r, v_mousePos) && canHover
        pressed := hovered && v_mouseLeftDown
        
        if pressed {
                canvas.drawRect(th.blue | 0xDDDDDD, r)
        } else if toggled {
                canvas.drawRect(th.blue | 0xAAAAAA, r)
        } else if hovered {
                canvas.drawRect(th.blue | 0x999999, r)
        } else {
                canvas.drawRect(th.blue | 0x666666, r)
        }


        v_font.draw(text, pos.add(padding), th.white)

        pos.x += r.w+1

        // TODO(skejeton): Return various input states instead of single boolean
        return hovered && v_mouseLeftNudged
}

fn getActiveGroup(): int {
        for i := len(v_groupZone.stack)-1; i >= 0; i-- {
                if rectInPoint(v_groupZone.stack[i].rect, v_mousePos) {
                        return i
                }
        }
        return -1
}

fn getGroupHoverInfo(group: ^Group): GroupHoverInfo {
        r := group.rect 
        titlebarRect := rect.mk(r.x, r.y, r.w, v_font.height + 4)
        
        if rectInPoint(titlebarRect, input.getMousePos()) {
                return groupHoverInfoOnTitlebar
        } else if rectInPoint(r, input.getMousePos()) {
                return groupHoverInfoOnBody
        } 
        return groupHoverInfoNone
}

fn isValidGroupDocking(group_a: ^Group, group_b: ^Group): bool {
        return getGroupHoverInfo(group_a) == groupHoverInfoOnTitlebar && getGroupHoverInfo(group_b) == groupHoverInfoOnTitlebar       
}

fn isDocking(): bool {
        return v_groupDraggingIndex >= 0 && v_groupDockingCandidateIndex >= 0 && isValidGroupDocking(v_groupZone.stack[v_groupDraggingIndex], v_groupZone.stack[v_groupDockingCandidateIndex])
}

fn end*() {
        // Move windows
        if !v_mouseLeftDown {
                // Finalize docking
                if isDocking() {
                        groupZoneDockGroups(&v_groupZone, v_groupDraggingIndex, v_groupDockingCandidateIndex)
                }
                v_windowDetachCandidateName = ""
                v_groupDraggingIndex = -1
        }

        if v_windowDetachCandidateName != "" && (getActiveGroup() == -1 || getGroupHoverInfo(v_groupZone.stack[getActiveGroup()]) != groupHoverInfoOnTitlebar) {
                group := ^Group(v_groupZone.map.get(v_windowDetachCandidateName))
                if group != null {
                        removalIndex := -1
                        removalRect := rect.mk(0, 0, 30, 30)

                        for windowIndex, win in group.windows {
                                if win.title == v_windowDetachCandidateName {
                                        removalIndex = windowIndex
                                        removalRect = win.rect
                                        break
                                }
                        }

                        if removalIndex >= 0 {
                                group.windows = delete(group.windows, removalIndex)
                                destPos := input.getMousePos().sub(th.Vf2{10, 10})
                                removalRect.x = destPos.x
                                removalRect.y = destPos.y
                                v_groupZone.map.set(v_windowDetachCandidateName, null);
                                groupZoneAcquire(&v_groupZone, v_windowDetachCandidateName, removalRect)
                                v_groupDraggingIndex = len(v_groupZone.stack)-1
                                v_windowDetachCandidateName = ""
                        }
                }
        }

        if v_mouseLeftNudged {
                groupIndex := getActiveGroup()
                if groupIndex >= 0 { 
                        group := v_groupZone.stack[groupIndex]
                        v_groupZone.stack = delete(v_groupZone.stack, groupIndex)
                        v_groupZone.stack = append(v_groupZone.stack, group)
                                
                        v_groupDraggingIndex = len(v_groupZone.stack)-1
                }
        }

        v_groupDockingCandidateIndex = -1
        if v_groupDraggingIndex >= 0 {
                // Find other docking candidates
                for i := len(v_groupZone.stack)-1; i >= 0; i-- {
                        if i != v_groupDraggingIndex && rectInPoint(v_groupZone.stack[i].rect, v_mousePos) {
                                v_groupDockingCandidateIndex = i
                                break
                        }
                }
        }


        // Draw windows
        for groupIndex, group in v_groupZone.stack {
                r := group.rect 
                window.beginScissorRect(rectInset(r, 1))

                titlebarRect := rect.mk(r.x, r.y, r.w, v_font.height + 4)
                pos := th.Vf2{r.x, r.y}
                newCurrent := group.current

                tabs := []Window{}
                tabs = append(tabs, group.windows)

                if v_groupDraggingIndex >= 0 && v_groupDockingCandidateIndex == groupIndex && isDocking() {
                        group := v_groupZone.stack[v_groupDraggingIndex]
                        tabs = append(tabs, group.windows)
                }


                if v_groupDraggingIndex == groupIndex && v_groupDockingCandidateIndex >= 0 && isDocking() {
                        canvas.drawRect(th.black&0x77, r)
                } else {
                        canvas.drawRect(th.black, rect.mk(r.x - 1, r.y - 1, r.w + 2, r.h + 2))
                        canvas.drawRect(th.white, rect.mk(r.x    , r.y    , r.w    , r.h    ))
                        canvas.drawRect(th.blue & 0x999999FF, titlebarRect);

                        if len(tabs) > 1 {
                                for i, win in tabs {
                                        if putButton(&pos, win.title, group.current == i, groupIndex == getActiveGroup()) {
                                                // Deny drag (because button press)
                                                v_windowDetachCandidateName = win.title
                                                newCurrent = i
                                        }
                                }
                        } else if len(tabs) == 1 {
                                v_font.draw(tabs[0].title, pos.add(th.Vf2{10, 2}), th.white)
                        }
                }

                window.endScissor()
                group.current = newCurrent
        }
 
        if v_windowDetachCandidateName != "" {
                v_groupDraggingIndex = -1
        }

        if v_groupDraggingIndex >= 0 {
                // Apply drag
                group := v_groupZone.stack[v_groupDraggingIndex]

                group.rect.x += v_mouseDelta.x
                group.rect.y += v_mouseDelta.y
        }
}

fn setJoinWindows*(set: bool) {
        groupZoneSetJoin(&v_groupZone, set)
}

fn beginWindow*(title: str, r: rect.Rect) {
        groupZoneAcquire(&v_groupZone, title, r)
}


// DRAGGING
// 1. Check if left mouse button is down
// 2. Iterate through windows
// 3. Check if we intersect with the window
// 4. Initiate window dragging
// 5. Drag the dragged window by specified mouse delta in following frames
//
// JOINING TABS
// 1. Iterate through windows
// 2. Check if mouse is above another window's titlebar
// 3. Attach to that another window
//
// SPLITTING TABS
// 1. Iterate through windows
// 2. Check if mouse is pressed on any certain tab
// 3. Save it as a held tab
// 4. When held tab goes out of titlebar, move it to a new group
