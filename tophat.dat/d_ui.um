import (
        "map.um"
        "th.um"; "rect.um"; "canvas.um"; "input.um"
        "d_font.um"; "d_util.um"
)

type (
        Window = struct {
                title: str
                rect: rect.Rect
        }

        Group = struct {
                windows: []Window
                current: uint
                rect: rect.Rect
        }
        
        GroupZone = struct {
                map: map.Map
                stack: []^Group 
                join: bool
                firstJoin: bool
        }
)

var (
        v_font: d_font.Font
        
        v_groupZone: GroupZone
        v_groupDraggingIndex: int
        v_groupLastTitle: str

        v_mousePos: th.Vf2
        v_mouseDelta: th.Vf2
        v_mouseLeftDown: bool
        v_mouseLeftNudged: bool 
)

///////////////////////
// Utility
fn rectInPoint(r: rect.Rect, p: th.Vf2): bool {
        return p.x > r.x && p.y > r.y && p.x < (r.x + r.w) && p.y < (r.y + r.h)
}

fn rectInset(r: rect.Rect, by: real): rect.Rect {
        return rect.mk(r.x-by, r.y-by, r.w+by*2, r.h+by*2)
}

///////////////////////
// Group
fn groupCreateFromWindow(window: Window): Group {
        windows := make([]Window, 1)
        windows[0] = window
        return Group{windows: windows, current: 0, rect: window.rect}
}

fn groupAppendWindow(group: ^Group, window: Window) {
        group.windows = append(group.windows, window) 
}

fn groupCreateFromScratch(r: rect.Rect): Group {
        return Group{windows: make([]Window, 0), current: 0, rect: r}
}

///////////////////////
// Group Zone
fn groupZoneInit(): GroupZone {
        return GroupZone{stack: make([]^Group, 0)}
}

fn groupZoneAcquire(zone: ^GroupZone, title: str, r: rect.Rect): ^Group {
        group := ^Group(zone.map.get(title))

        if group == null {
                zone.map.set(title, groupCreateFromWindow(Window{title: title, rect: r}))
                group = ^Group(zone.map.get(title))

                if len(zone.stack) > 0 && zone.join && !zone.firstJoin {
                        groupAppendWindow(zone.stack[len(zone.stack)-1], Window{title: title, rect: r})
                } else {
                        zone.firstJoin = false
                        zone.stack = append(zone.stack, group)
                }
        }
        
        return group
}

fn groupZoneSetJoin(zone: ^GroupZone, set: bool) {
        zone.join = set
        zone.firstJoin = true
}

///////////////////////
// UI
fn init*(font: d_font.Font) {
        v_font = font
        v_groupZone = groupZoneInit()
}

fn begin*() {
        newMousePos := input.getMousePos()
        v_mouseDelta = newMousePos.sub(v_mousePos)
        v_mousePos = newMousePos
        v_mouseLeftDown = input.isPressed(input.mouse1)
        v_mouseLeftNudged = input.isJustPressed(input.mouse1)
        groupZoneSetJoin(&v_groupZone, false)
}

fn putButton(pos: ^th.Vf2, text: str, highlight: bool, canBeHovered: bool): bool {
        const padding = th.Vf2{10, 2}
        textSize := v_font.measure(text)
        r := rect.Rect{pos.x, pos.y, textSize.x + padding.x*2, textSize.y + padding.y*2}
        hovered := rectInPoint(r, v_mousePos) && canBeHovered
        pressed := hovered && v_mouseLeftDown
        orMultiple := int(!highlight)
        
        if pressed {
                canvas.drawRect(th.blue | (0x000000 * orMultiple), r)
        } else if hovered {
                canvas.drawRect(th.blue | (0x333333 * orMultiple), r)
        } else {
                canvas.drawRect(th.blue | (0x666666 * orMultiple), r)
        }


        v_font.draw(text, pos.add(padding), th.white)

        pos.x += r.w+1

        return hovered && v_mouseLeftNudged
}

fn getActiveGroup(): int {
        for i := len(v_groupZone.stack)-1; i >= 0; i-- {
                if rectInPoint(v_groupZone.stack[i].rect, v_mousePos) {
                        return i
                }
        }
        return -1
}

fn end*() {
        // Move windows
        if !v_mouseLeftDown {
                v_groupDraggingIndex = -1
        }

        if v_mouseLeftNudged {
                groupIndex := getActiveGroup()
                if groupIndex >= 0 { 
                        group := v_groupZone.stack[groupIndex]
                        v_groupZone.stack = delete(v_groupZone.stack, groupIndex)
                        v_groupZone.stack = append(v_groupZone.stack, group)
                                
                        v_groupDraggingIndex = len(v_groupZone.stack)-1
                }
        }
        
        if v_groupDraggingIndex >= 0 {
                group := v_groupZone.stack[v_groupDraggingIndex]

                group.rect.x += v_mouseDelta.x
                group.rect.y += v_mouseDelta.y
        }
        

        // Draw windows
        for groupIndex, group in v_groupZone.stack {
                r := group.rect 

                canvas.drawRect(th.black, rect.mk(r.x - 1, r.y - 1, r.w + 2, r.h + 2))
                canvas.drawRect(th.white, rect.mk(r.x    , r.y    , r.w    , r.h    ))
                
                pos := th.Vf2{r.x, r.y}

                newCurrent := group.current

                for i, win in group.windows {
                        if putButton(&pos, win.title, group.current == i, groupIndex == getActiveGroup()) {
                                newCurrent = i
                        }
                }

                group.current = newCurrent
        }
}

fn setJoinWindows*(set: bool) {
        groupZoneSetJoin(&v_groupZone, set)
}

fn beginWindow*(title: str, r: rect.Rect) {
        groupZoneAcquire(&v_groupZone, title, r)
}


// DRAGGING
// 1. Check if left mouse button is down
// 2. Iterate through windows
// 3. Check if we intersect with the window
// 4. Initiate window dragging
// 5. Drag the dragged window by specified mouse delta in following frames
//
// DOCKING TABS
// 1. Iterate through windows
// 2. Check if mouse is above another window
// 3. Attach to that another window
