import ("th.um"; "rect.um"; "canvas.um"; "input.um"
        "d_world.um"; "d_dialog.um")

const (
        shapeBlock              = 0
        shapeLeftUpSlope        = 1
        shapeRightUpSlope       = 2
        shapeLeftDownSlope      = 3
        shapeRightDownSlope     = 4
)

type (
        Shape* = struct {
                rect: rect.Rect
                shape: int
        }

        Character* = struct {
                rect: rect.Rect
                vel: th.Vf2
                onGround: bool
                onSlope: bool
        }
)

var (
        sceneId*: int
        world*: d_world.World
        chara*: Character
        dialog*: d_dialog.Dialog
        camera: th.Vf2
        cameraPos: th.Vf2
        cameraAntiPanVel: th.Vf2
        cameraAntiPan: th.Vf2
)

fn centerPlayerOnCamera() {
        if cameraAntiPan.x < -50 {
                cameraAntiPan.x = -50
        }
        if cameraAntiPan.x > 50 {
                cameraAntiPan.x = 50
        }
        if cameraAntiPan.y < -50 {
                cameraAntiPan.y = -50
        }
        if cameraAntiPan.y > 50 {
                cameraAntiPan.y = 50
        }
        cameraPos.x += ((chara.rect.x-(640-chara.rect.w)/2)-cameraPos.x)/4
        cameraPos.y += ((chara.rect.y-(480-chara.rect.h)/2)-cameraPos.y)/4
        camera.x = cameraPos.x + cameraAntiPan.x
        camera.y = cameraPos.y + cameraAntiPan.y
}

fn cameraOffsetRect(r: rect.Rect): rect.Rect {
        r.x -= camera.x
        r.y -= camera.y
        return r
}

fn moveCharacter() {
        chara.vel.x = 0
        if chara.onSlope {
                chara.vel.y += 2.2
        } else {
                chara.vel.y += 0.1
        }

        if input.isPressed(input.key_up) && chara.onGround {
                chara.vel.y = -4.36
        }
        if input.isPressed(input.key_left) {
                chara.vel.x = -2
        }
        if input.isPressed(input.key_right) {
                chara.vel.x = 2
        }
        if chara.rect.y > 2e3 {
                // NOTE: Respawn
                chara.vel.x = 0
                chara.vel.y = 0
                chara.rect.x = world.playerSpawnPos.x * world.tileset.tileSizeX
                chara.rect.y = world.playerSpawnPos.y * world.tileset.tileSizeY
        }

        if chara.vel.y > 10 {
                chara.vel.y = 10
        }

        cameraAntiPanVel.x += chara.vel.x
        cameraAntiPanVel.x /= 2.6
        cameraAntiPanVel.y = chara.vel.y
        cameraAntiPanVel.y /= 2.6
        cameraAntiPan.x += cameraAntiPanVel.x/5.0
        cameraAntiPan.y += cameraAntiPanVel.y/5.0
        chara.rect.x += chara.vel.x
        chara.rect.y += chara.vel.y

        chara.onGround = false
        chara.onSlope = false
}

fn collCalcRectSnap(r, along: rect.Rect): th.Vf2 {
        x_left := r.x + r.w - along.x
        y_up := r.y + r.h - along.y

        x_right := along.x + along.w - r.x
        y_down := along.y + along.h - r.y

        var (min_x: real; min_y: real)

        if fabs(x_left) < fabs(x_right) {
                min_x = -x_left
        } else {
                min_x = x_right
        }

        if fabs(y_up) < fabs(y_down) {
                min_y = -y_up
        } else {
                min_y = y_down
        }

        if fabs(min_x) < fabs(min_y) {
                return th.Vf2{min_x, 0}
        } 
        return th.Vf2{0, min_y}
}

fn collRectVsRect(r1, r2: rect.Rect): bool {
        return (r1.x + r1.w) > (r2.x) && (r1.y + r1.h) > (r2.y) && (r1.x) < (r2.x + r2.w) && (r1.y) < (r2.y + r2.h)
}

fn collSortShapesByProximity(shapes: ^[]Shape, along: th.Vf2) {
        for i := 0; i < len(shapes^); i++ {
                closest := &shapes[i]
                mindist := real(99999999)
                for j := i; j < len(shapes^); j++ {
                        current := shapes[j].rect
                        point := th.Vf2{current.x + current.w / 2, current.y + current.h / 2}
                        dist := point.distanceTo(along)
                        if dist < mindist {
                                mindist = dist
                                closest = &shapes[j]
                        }
                }
                tmp := closest^
                closest^ = shapes[i]
                shapes[i] = tmp
        }
}

fn playerVsShape(s: Shape) {
        r := s.rect
        snap := collCalcRectSnap(chara.rect, r)
                
        // Not a valid collision (probably pushed back by other blocks?)
        if collRectVsRect(chara.rect, r) == false {
                return
        }
        
        switch s.shape {
        case shapeLeftUpSlope:
                cornerX := chara.rect.x + chara.rect.w - r.x;
                if cornerX > r.w {
                        cornerX = r.w
                }
                cornerY := chara.rect.y + chara.rect.h - r.y;
                hitY := r.h - ((r.h/r.w) * (cornerX))
                if hitY > r.h {
                        hitY = r.h
                }
                
                if cornerY > hitY {
                        chara.vel.y = 0;
                        chara.onGround = true;
                        chara.onSlope = true;
                        chara.rect.y += hitY-cornerY;
                }
        case shapeRightUpSlope:
                cornerX := chara.rect.x - r.x;
                if cornerX < 0 {
                        cornerX = 0;
                }
                cornerY := chara.rect.y + chara.rect.h - r.y;
                hitY := (r.h/r.w) * (cornerX)

                if cornerY > hitY {
                        chara.vel.y = 0;
                        chara.onGround = true;
                        chara.onSlope = true;
                        chara.rect.y += hitY-cornerY;
                }
        case shapeLeftDownSlope:
                cornerX := chara.rect.x + chara.rect.w - r.x;
                if cornerX > r.w {
                        cornerX = r.w
                }
                cornerY := chara.rect.y - r.y;
                hitY := (r.h/r.w) * (cornerX)

                if cornerY < hitY {
                        if chara.vel.y < 0 {
                                chara.vel.y = 0;
                        }
                        chara.rect.y += hitY-cornerY;
                }
        case shapeRightDownSlope:
                cornerX := chara.rect.x - r.x;
                if cornerX < 0 {
                        cornerX = 0;
                }
                cornerY := chara.rect.y - r.y;
                hitY := r.h - ((r.h/r.w) * (cornerX))

                if cornerY < hitY {
                        if chara.vel.y < 0 {
                                chara.vel.y = 0;
                        }
                        chara.rect.y += hitY-cornerY;
                }
        case shapeBlock:
                if snap.x != 0 {
                        chara.vel.x = 0
                } else if (snap.y > 0 && chara.vel.y < 0) || (snap.y < 0 && chara.vel.y > 0) {
                        chara.vel.y = 0
                }
                if snap.y < 0 {
                        chara.onGround = true
                }
                chara.rect.x += snap.x
                chara.rect.y += snap.y
        }
}

fn playerConstructColidingSolids(): []Shape {
        tangents := world.getTangentTiles(rect.Rect{chara.rect.x-1, chara.rect.y-1, chara.rect.w+1, chara.rect.h+1})
        solids := []Shape{}
        nonBlockSolids := []Shape{}

        for tangent in tangents {
                shapeRect := rect.Rect{tangent.x*world.tileset.tileSizeX, tangent.y*world.tileset.tileSizeY, world.tileset.tileSizeX, world.tileset.tileSizeY} 
                shapeType := -1

                switch tangent.id {
                case 1, 5, 7:   shapeType = shapeBlock
                case 9:         shapeType = shapeLeftUpSlope
                case 10:        shapeType = shapeRightUpSlope
                case 13:        shapeType = shapeLeftDownSlope
                case 14:        shapeType = shapeRightDownSlope
                case 15:        shapeType = shapeLeftUpSlope
                                shapeRect.h /= 2;
                case 16:        shapeType = shapeRightUpSlope
                                shapeRect.h /= 2;
                case 4:         shapeType = shapeLeftUpSlope
                                shapeRect.y += world.tileset.tileSizeY/2;
                                shapeRect.h /= 2;
                case 8:         shapeType = shapeRightUpSlope
                                shapeRect.y += world.tileset.tileSizeY/2;
                                shapeRect.h /= 2;
                case 11:        shapeType = shapeRightDownSlope
                                shapeRect.h /= 2;
                case 12:        shapeType = shapeLeftDownSlope
                                shapeRect.h /= 2;
                // TODO: Investigate why uncommenting this causes a bug where you can pass through blocks
                // default:        break
                }
                
                if shapeType == shapeBlock {
                        solids = append(solids, Shape{shapeRect, shapeType})
                } else {
                        nonBlockSolids = append(nonBlockSolids, Shape{shapeRect, shapeType})
                }
        }


        //collSortShapesByProximity(&nonBlockSolids, th.Vf2{chara.rect.x+chara.rect.w/2, chara.rect.y+chara.rect.h/2})
        solids = append(solids, nonBlockSolids)
        collSortShapesByProximity(&solids, th.Vf2{chara.rect.x+chara.rect.w/2, chara.rect.y+chara.rect.h/2})
        return solids
}

fn playerSolveCollision() {
        solids := playerConstructColidingSolids()

        for solid in solids {
                playerVsShape(solid)
        }
}

fn drawRectTangents(r: rect.Rect) {
        solids := playerConstructColidingSolids()

        i := 0
        for solid in solids {
                rec := cameraOffsetRect(solid.rect)
                switch solid.shape {
                case shapeBlock:
                        canvas.drawRect(0x00FF0055, rec)
                case shapeLeftUpSlope, shapeRightDownSlope:
                        canvas.drawLine(0x00FF0055, th.Vf2{rec.x, rec.y+rec.h}, th.Vf2{rec.x+rec.w, rec.y}, 2)
                case shapeRightUpSlope, shapeLeftDownSlope:
                        canvas.drawLine(0x00FF0055, th.Vf2{rec.x, rec.y}, th.Vf2{rec.x+rec.w, rec.y+rec.h}, 2)
                }
                canvas.drawText(repr(i), th.Vf2{rec.x, rec.y}, th.white, 1)
                i++
        }
}

fn init*() {
        chara = Character{rect: rect.Rect{world.playerSpawnPos.x*world.tileset.tileSizeX, world.playerSpawnPos.y*world.tileset.tileSizeY, world.tileset.tileSizeX, world.tileset.tileSizeY}}

        cameraPos.x = chara.rect.x-(640-chara.rect.w)/2
        cameraPos.y = chara.rect.y-(480-chara.rect.h)/2
}

fn draw*() {
        // UPDATE PLAYER & CAMERA //
        moveCharacter()
        playerSolveCollision()
        centerPlayerOnCamera()

        // UPDATE DIALOG //
        dialog.update()

        // RENDER WORLD //
        world.drawLayer(camera, -1)
        if chara.onGround { 
                canvas.drawRect(th.red, cameraOffsetRect(chara.rect))
        } else {
                canvas.drawRect(th.blue, cameraOffsetRect(chara.rect))
        }
        world.drawLayer(camera, 0)
        world.drawLayer(camera, 1)

        // RENDER DIALOG //
        tempPos := dialog.position
        dialog.position = tempPos.sub(camera)
        dialog.draw()
        dialog.position = tempPos

/*
        // DEBUG OVERYALS //
        drawRectTangents(chara.rect)
*/
}
