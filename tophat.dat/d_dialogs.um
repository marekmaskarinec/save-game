import ("map.um"; "image.um"; "th.um"; "rect.um"; "canvas.um"
        "d_dialog.um"; "d_font.um"; "d_util.um")

type (
        Persona* = struct {
                name: str
                boximg: image.Image
                boximgY: int
                faceimg: image.Image
                faceimgY: int
                font: d_font.Font
                fontColor: uint32
                speed: real
                emotes: map.Map // str -> int
        }

        Dialogs* = struct {
                personas: map.Map
                list: []d_dialog.Dialog
        }
)

fn init*(): Dialogs {
        return Dialogs{list: make([]d_dialog.Dialog, 0)}
}

fn (d: ^Dialogs) register*(name: str, boximgPath: str, boximgY: int, faceimgPath: str, faceimgY: int, fontPath: str, fontH: int, fontColor: uint32, speed: real, emotes: []str) {
        persona := new(Persona)
        persona.name = name
        persona.boximg = image.load(boximgPath)
        persona.boximgY = boximgY
        persona.faceimg = image.load(faceimgPath)
        persona.faceimgY = faceimgY
        persona.font = d_font.loadFont(fontPath, fontH)
        persona.fontColor = fontColor
        persona.speed = speed

        for id, emote in emotes {
                persona.emotes.set(emote, int(id+1))
        }

        d.personas.set(name, persona)
}


fn (d: ^Dialogs) say*(name, emotion: str, message: str, pos: th.Vf2) {
        persona := ^Persona(d.personas.get(name))
        // TODO: Fallback text if persona doesn't exist
        if persona != null {
                emotePos := 0
                if len(emotion) > 0 {
                        emote := ^int(persona.emotes.get(emotion))
                        if emote != null { 
                                emotePos = emote^*64
                        }
                }

                d_util.imageCropRect(persona.faceimg, rect.Rect{emotePos, persona.faceimgY*64, 64, 64})
                dialog := d_dialog.setup(message, persona.speed, persona.faceimg, persona.boximg, th.Vf2{0, persona.boximgY*48}, persona.fontColor, &persona.font)
                dialog.position = pos
                d.list = append(d.list, dialog)
        }
}

fn (d: ^Dialogs) close() {
        if len(d.list) > 0 {
                d.list = delete(d.list, len(d.list)-1)
        }
}

fn (d: ^Dialogs) update*() {
        for x, _ in d.list {
                d.list[x].update()
        }
}

fn (d: ^Dialogs) draw*() {
        for x, _ in d.list {
                d.list[x].draw()
                if x == len(d.list)-1 {
                        box := d.list[x].getBox()
                        offs := d.list[x].spriteOffset
                        d_util.drawRectNinepatch(d.list[x].sprite, rect.mk(offs.x+48, offs.y, 48, 48), rect.mk(16, 16, 16, 16), box)
                }
        }
}